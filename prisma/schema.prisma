generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id String @unique @id @default(cuid())
  email String @unique
  username String @unique
  password String
  avatar String? 

  tokens Token[]
  notifications Notifications[]
  trackingUsers TrackingUser[]
  links LinksInProfile? @relation
  role                UserRole   @default(NOT_ACTIVE) 
  additionalRole AdditionalRole @default(MEMBER)
  steamUser SteamUser? @relation
  commentsAsAuthor     Comment[] @relation()
  jwtTokens           JwtToken[]
  reportUsers ReportUser[] @relation()
  verdicts Verdict[] @relation()
  contentReports ContentReports[] @relation
  isEmailVerified Boolean @default(false) @map("is_email_verified")
  isBanned Boolean @default(false) @map("is_banned")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("user")
}
model TrackingUser {
  id String @id @default(uuid()) @unique

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String 
  name String
  steamid String
  dateBanned DateTime? 
  avatar String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
}

model Notifications {
  id String @id @default(uuid()) @unique

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  type NotificationType
  title String
  description String?
  isViewed Boolean @default(false)
  
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
}

enum NotificationType {
  SYSTEM
  STANDARD
  COMMENT
  CS
  SUBSCRIBE
}

model Token {
  id String @id @default(uuid())

  token String @unique
  type TokenType
  expiresIn DateTime @map("expires_in")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @map("user_id")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  @@map("tokens")
}

model StackDownloadingMatches {
  id String @unique
  createdAt   DateTime @default(now()) @map("created_at")
}

model SteamUser {
  id String @unique @id
  personaName String? @map("persona_name")
  profileUrl String? @map("profile_url")
  avatar String?
  realname String?
  level String?
  timeCreated String? @map("time_created")

  steamId2 String?
  steamId3 String?
  steamIdHex String?
  countryCode String?

  lastUpdateSteamInformation DateTime

  viewers Int @default(1)

  user User? @relation(fields: [userId], references: [id])
  userId String? @unique @map("user_id")

  steamUserBans SteamUserBans? @relation
  commentsAsRecipient Comment[] @relation()
  reportsAsRecipient ReportUser [] @relation()

  matches Match[]
  generalPlayerStatistics GeneralPlayerStatistics?
  isGettedGeneralPlayerStatistics Boolean @default(false)
  sharedCode String? @map("shared_code")
  sharedCodeError DateTime?
  gameAuthenticationCode String? @map("game_authentification_code")


  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("steam_user")
  
}

model MatchForAnalysis {
  sharedCode String @id @unique
  matchId String 
  date String 
  demoUrl String
  dateUnix Int
  score String
  duration String
  playerId String
  createdAt   DateTime @default(now()) @map("created_at")
}

model Match {
  id String @id @unique
  type MatchType
  
  participants SteamUser[]
  playersStatistic PlayerStatisticsInMatch[] 
  score String
  parsedMatch Json
  kill_stats Json?
  date String 
  dateUnix Int
  sharedCode String @unique @map("shared_code")
  demoUrl String

  duration String
  region String
  map String
  avg_rank Int

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  @@map("matches")
}

model GeneralPlayerStatistics {
  id String @unique @id @default(cuid())
  steam SteamUser @relation(fields: [userId], references: [id])
  userId String @unique
  MapRanks MapRanks[]
  wingman Int?
  wingmanMathes Int?
  wingmanWins Int?
  premier Int?
  faceit Int?
  faceit_elo Int?
  TotalMatches Int?
  wins Int?
  inGameSinse DateTime?
 WeaponStats WeaponStats[] 
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
}

model MapRanks {
  id String @unique @id @default(cuid())
  name String
  rank Int
  
  generalPlayerStatistics GeneralPlayerStatistics @relation(fields: [playerId], references: [id],onDelete: Cascade)
  playerId String

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  @@map("map_ranks")
}


model PlayerStatisticsInMatch {
  id        String     @id @default(uuid())

  match     Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  matchId   String
  steamid String
  name String?
  kills_total Int
  deaths_total Int
  assists_total Int
  headshot_kills_total Int
  ace_rounds_total Int
  k4_rounds_total Int
  k3_rounds_total Int
  damage_total Int
  mvps Int
  crosshair_code String   
  player_color String
  team Int?
  result MatchResult
  clutchV2 Int @default(0)
  clutchV3 Int @default(0)
  clutchV4 Int @default(0)
  clutchV5 Int @default(0)

  utility_damage_total Int
  
  rank Int
  score Int
  comp_wins Int
  team_surrendered Boolean @default(false)
  team_score_first_half Int
  team_score_second_half Int
  isSuspicious Boolean @default(false)
  
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("player_statistics_in_match")
}


model SteamUserBans {
  id String @unique @id
  steam SteamUser @relation(fields: [id], references: [id])
  communityBanned Boolean? @default(false)
  daysSinceLastBan Int?
  economyBan String?
  gameBans Int?
  vacBanned Boolean? @default(false)
  vacBans Int? 
  csBan Boolean @default(false)
  cs_banned_since DateTime?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
}

model vac {
  number Int
  createdAt DateTime @id @default(now()) @map("created_at")
}

model LinksInProfile {
  id String @unique @id @default(cuid())
  user User @relation(fields: [id], references: [id], onDelete: Cascade)
  tradeLink String?
  twitch String?
  youtube String?
  telegram String?
  discord String?

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
}

model Comment {
  id          String   @unique @id @default(cuid())
  content     String
  images      Images[] 
  
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String  @map("author_id")
  recipient   SteamUser @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  recipientId String  @map("recipient_id")
  commentReport ContentReports[]

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("comment")
}

model Images {
  id        String @unique @id @default(cuid())
  url       String
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId     String    @map("comment_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
}

model JwtToken {
  id          String   @unique @id @default(cuid())
  refreshToken    String @map("refresh_token")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("jwt_token")
}

model ReportUser {
  id String   @unique @id @default(cuid())
  youtubeLink String @unique @map("youtube_link")
  demoLink String?
  comment String?

  author User @relation(fields: [authorId] , references: [id], onDelete: Cascade)
  authorId String

  recipient SteamUser @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  recipientId String
 
  contentReportId ContentReports[]
  
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  verdicts Verdict[] @relation()

  @@map("report_user")
}

model Verdict {
  id String   @unique @id @default(cuid())
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  report ReportUser @relation(fields: [reportId], references: [id], onDelete: Cascade)
  reportId String
  verdicts String[] @default([])// Массив строк для хранения вердиктов
  comment String?

  

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("verdict")
}

model WeaponStats {
  id         String   @id @default(cuid())
  name       String
  fire       Int
  userId     String
  generalPlayerStatistics       GeneralPlayerStatistics     @relation(fields: [userId], references: [id], onDelete: Cascade)
  hits       Hit[]
}

model Hit {
  id            String   @id @default(cuid())
  weaponId      String
  hitLocation    String
  hits          Int
  totalDamage   Int
  kills         Int
  weapon       WeaponStats   @relation(fields: [weaponId], references: [id], onDelete: Cascade)
}

model ContentReports {
  id           String   @unique @id @default(cuid())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String   @map("user_id")
  
  comment      Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId    String?  @map("comment_id")

  report      ReportUser? @relation(fields: [reportId], references: [id], onDelete: Cascade)
  reportId    String?  @map("verdict_id")

  userComment String
  type ContentReportType 
  isResolved    Boolean  @default(false) 
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  @@unique([userId,reportId])
  @@unique([userId,commentId])
  @@map("report")

}

enum UserRole {
  NOT_ACTIVE          // Обычный пользователь
  ACTIVE // Верифицированный пользователь по почте
  VERIFIED // Верифицированный пользователь по Steam
  DISABLED

  @@map("user_role")
}
 enum AdditionalRole {
  MEMBER
  DONOR
  MODERATOR      
  ADMIN          
  CREATOR
  @@map("additional_role")
 }

 enum TokenType {
  EMAIL_VERIFY
  PASSWORD_RECOVERY
  TELEGRAM_VERIFY
 }

enum MatchResult {
  WIN
  LOSE
  DRAW
}

 enum MatchType {
  ERROR
  MATCHMAKING
  PREMIER
  WINGMAN
  FACEIT
 }

 enum ContentReportType {
  COMMENT
  REPORT
 }