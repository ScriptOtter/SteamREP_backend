
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model TrackingUser
 * 
 */
export type TrackingUser = $Result.DefaultSelection<Prisma.$TrackingUserPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model SteamUser
 * 
 */
export type SteamUser = $Result.DefaultSelection<Prisma.$SteamUserPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model GeneralPlayerStatistics
 * 
 */
export type GeneralPlayerStatistics = $Result.DefaultSelection<Prisma.$GeneralPlayerStatisticsPayload>
/**
 * Model MapRanks
 * 
 */
export type MapRanks = $Result.DefaultSelection<Prisma.$MapRanksPayload>
/**
 * Model MapStats
 * 
 */
export type MapStats = $Result.DefaultSelection<Prisma.$MapStatsPayload>
/**
 * Model WeaponStats
 * 
 */
export type WeaponStats = $Result.DefaultSelection<Prisma.$WeaponStatsPayload>
/**
 * Model Hit
 * 
 */
export type Hit = $Result.DefaultSelection<Prisma.$HitPayload>
/**
 * Model PlayerStatisticsInMatch
 * 
 */
export type PlayerStatisticsInMatch = $Result.DefaultSelection<Prisma.$PlayerStatisticsInMatchPayload>
/**
 * Model SteamUserBans
 * 
 */
export type SteamUserBans = $Result.DefaultSelection<Prisma.$SteamUserBansPayload>
/**
 * Model LinksInProfile
 * 
 */
export type LinksInProfile = $Result.DefaultSelection<Prisma.$LinksInProfilePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Images
 * 
 */
export type Images = $Result.DefaultSelection<Prisma.$ImagesPayload>
/**
 * Model JwtToken
 * 
 */
export type JwtToken = $Result.DefaultSelection<Prisma.$JwtTokenPayload>
/**
 * Model ReportUser
 * 
 */
export type ReportUser = $Result.DefaultSelection<Prisma.$ReportUserPayload>
/**
 * Model Verdict
 * 
 */
export type Verdict = $Result.DefaultSelection<Prisma.$VerdictPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationType: {
  SYSTEM: 'SYSTEM',
  STANDARD: 'STANDARD',
  COMMENT: 'COMMENT',
  CS: 'CS',
  SUBSCRIBE: 'SUBSCRIBE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const UserRole: {
  NOT_ACTIVE: 'NOT_ACTIVE',
  ACTIVE: 'ACTIVE',
  VERIFIED: 'VERIFIED',
  DISABLED: 'DISABLED'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AdditionalRole: {
  MEMBER: 'MEMBER',
  DONOR: 'DONOR',
  MODERATOR: 'MODERATOR',
  ADMIN: 'ADMIN',
  CREATOR: 'CREATOR'
};

export type AdditionalRole = (typeof AdditionalRole)[keyof typeof AdditionalRole]


export const TokenType: {
  EMAIL_VERIFY: 'EMAIL_VERIFY',
  PASSWORD_RECOVERY: 'PASSWORD_RECOVERY',
  TELEGRAM_VERIFY: 'TELEGRAM_VERIFY'
};

export type TokenType = (typeof TokenType)[keyof typeof TokenType]


export const MatchType: {
  MATCHMAKING: 'MATCHMAKING',
  PREMIER: 'PREMIER',
  WINGMAN: 'WINGMAN',
  FACEIT: 'FACEIT'
};

export type MatchType = (typeof MatchType)[keyof typeof MatchType]

}

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AdditionalRole = $Enums.AdditionalRole

export const AdditionalRole: typeof $Enums.AdditionalRole

export type TokenType = $Enums.TokenType

export const TokenType: typeof $Enums.TokenType

export type MatchType = $Enums.MatchType

export const MatchType: typeof $Enums.MatchType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trackingUser`: Exposes CRUD operations for the **TrackingUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrackingUsers
    * const trackingUsers = await prisma.trackingUser.findMany()
    * ```
    */
  get trackingUser(): Prisma.TrackingUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.steamUser`: Exposes CRUD operations for the **SteamUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SteamUsers
    * const steamUsers = await prisma.steamUser.findMany()
    * ```
    */
  get steamUser(): Prisma.SteamUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generalPlayerStatistics`: Exposes CRUD operations for the **GeneralPlayerStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneralPlayerStatistics
    * const generalPlayerStatistics = await prisma.generalPlayerStatistics.findMany()
    * ```
    */
  get generalPlayerStatistics(): Prisma.GeneralPlayerStatisticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapRanks`: Exposes CRUD operations for the **MapRanks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapRanks
    * const mapRanks = await prisma.mapRanks.findMany()
    * ```
    */
  get mapRanks(): Prisma.MapRanksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapStats`: Exposes CRUD operations for the **MapStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapStats
    * const mapStats = await prisma.mapStats.findMany()
    * ```
    */
  get mapStats(): Prisma.MapStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weaponStats`: Exposes CRUD operations for the **WeaponStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeaponStats
    * const weaponStats = await prisma.weaponStats.findMany()
    * ```
    */
  get weaponStats(): Prisma.WeaponStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hit`: Exposes CRUD operations for the **Hit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hits
    * const hits = await prisma.hit.findMany()
    * ```
    */
  get hit(): Prisma.HitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerStatisticsInMatch`: Exposes CRUD operations for the **PlayerStatisticsInMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerStatisticsInMatches
    * const playerStatisticsInMatches = await prisma.playerStatisticsInMatch.findMany()
    * ```
    */
  get playerStatisticsInMatch(): Prisma.PlayerStatisticsInMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.steamUserBans`: Exposes CRUD operations for the **SteamUserBans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SteamUserBans
    * const steamUserBans = await prisma.steamUserBans.findMany()
    * ```
    */
  get steamUserBans(): Prisma.SteamUserBansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linksInProfile`: Exposes CRUD operations for the **LinksInProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinksInProfiles
    * const linksInProfiles = await prisma.linksInProfile.findMany()
    * ```
    */
  get linksInProfile(): Prisma.LinksInProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.images`: Exposes CRUD operations for the **Images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.images.findMany()
    * ```
    */
  get images(): Prisma.ImagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jwtToken`: Exposes CRUD operations for the **JwtToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JwtTokens
    * const jwtTokens = await prisma.jwtToken.findMany()
    * ```
    */
  get jwtToken(): Prisma.JwtTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportUser`: Exposes CRUD operations for the **ReportUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportUsers
    * const reportUsers = await prisma.reportUser.findMany()
    * ```
    */
  get reportUser(): Prisma.ReportUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdict`: Exposes CRUD operations for the **Verdict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verdicts
    * const verdicts = await prisma.verdict.findMany()
    * ```
    */
  get verdict(): Prisma.VerdictDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    TrackingUser: 'TrackingUser',
    Notifications: 'Notifications',
    Token: 'Token',
    SteamUser: 'SteamUser',
    Match: 'Match',
    GeneralPlayerStatistics: 'GeneralPlayerStatistics',
    MapRanks: 'MapRanks',
    MapStats: 'MapStats',
    WeaponStats: 'WeaponStats',
    Hit: 'Hit',
    PlayerStatisticsInMatch: 'PlayerStatisticsInMatch',
    SteamUserBans: 'SteamUserBans',
    LinksInProfile: 'LinksInProfile',
    Comment: 'Comment',
    Images: 'Images',
    JwtToken: 'JwtToken',
    ReportUser: 'ReportUser',
    Verdict: 'Verdict'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "trackingUser" | "notifications" | "token" | "steamUser" | "match" | "generalPlayerStatistics" | "mapRanks" | "mapStats" | "weaponStats" | "hit" | "playerStatisticsInMatch" | "steamUserBans" | "linksInProfile" | "comment" | "images" | "jwtToken" | "reportUser" | "verdict"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      TrackingUser: {
        payload: Prisma.$TrackingUserPayload<ExtArgs>
        fields: Prisma.TrackingUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrackingUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrackingUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>
          }
          findFirst: {
            args: Prisma.TrackingUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrackingUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>
          }
          findMany: {
            args: Prisma.TrackingUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>[]
          }
          create: {
            args: Prisma.TrackingUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>
          }
          createMany: {
            args: Prisma.TrackingUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrackingUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>[]
          }
          delete: {
            args: Prisma.TrackingUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>
          }
          update: {
            args: Prisma.TrackingUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>
          }
          deleteMany: {
            args: Prisma.TrackingUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrackingUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrackingUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>[]
          }
          upsert: {
            args: Prisma.TrackingUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingUserPayload>
          }
          aggregate: {
            args: Prisma.TrackingUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackingUser>
          }
          groupBy: {
            args: Prisma.TrackingUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackingUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrackingUserCountArgs<ExtArgs>
            result: $Utils.Optional<TrackingUserCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      SteamUser: {
        payload: Prisma.$SteamUserPayload<ExtArgs>
        fields: Prisma.SteamUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SteamUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SteamUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>
          }
          findFirst: {
            args: Prisma.SteamUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SteamUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>
          }
          findMany: {
            args: Prisma.SteamUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>[]
          }
          create: {
            args: Prisma.SteamUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>
          }
          createMany: {
            args: Prisma.SteamUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SteamUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>[]
          }
          delete: {
            args: Prisma.SteamUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>
          }
          update: {
            args: Prisma.SteamUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>
          }
          deleteMany: {
            args: Prisma.SteamUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SteamUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SteamUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>[]
          }
          upsert: {
            args: Prisma.SteamUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserPayload>
          }
          aggregate: {
            args: Prisma.SteamUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSteamUser>
          }
          groupBy: {
            args: Prisma.SteamUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<SteamUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.SteamUserCountArgs<ExtArgs>
            result: $Utils.Optional<SteamUserCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      GeneralPlayerStatistics: {
        payload: Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>
        fields: Prisma.GeneralPlayerStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneralPlayerStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneralPlayerStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>
          }
          findFirst: {
            args: Prisma.GeneralPlayerStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneralPlayerStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>
          }
          findMany: {
            args: Prisma.GeneralPlayerStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>[]
          }
          create: {
            args: Prisma.GeneralPlayerStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>
          }
          createMany: {
            args: Prisma.GeneralPlayerStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneralPlayerStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>[]
          }
          delete: {
            args: Prisma.GeneralPlayerStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>
          }
          update: {
            args: Prisma.GeneralPlayerStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.GeneralPlayerStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneralPlayerStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeneralPlayerStatisticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>[]
          }
          upsert: {
            args: Prisma.GeneralPlayerStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneralPlayerStatisticsPayload>
          }
          aggregate: {
            args: Prisma.GeneralPlayerStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneralPlayerStatistics>
          }
          groupBy: {
            args: Prisma.GeneralPlayerStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneralPlayerStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneralPlayerStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<GeneralPlayerStatisticsCountAggregateOutputType> | number
          }
        }
      }
      MapRanks: {
        payload: Prisma.$MapRanksPayload<ExtArgs>
        fields: Prisma.MapRanksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapRanksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapRanksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>
          }
          findFirst: {
            args: Prisma.MapRanksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapRanksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>
          }
          findMany: {
            args: Prisma.MapRanksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>[]
          }
          create: {
            args: Prisma.MapRanksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>
          }
          createMany: {
            args: Prisma.MapRanksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapRanksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>[]
          }
          delete: {
            args: Prisma.MapRanksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>
          }
          update: {
            args: Prisma.MapRanksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>
          }
          deleteMany: {
            args: Prisma.MapRanksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapRanksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapRanksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>[]
          }
          upsert: {
            args: Prisma.MapRanksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapRanksPayload>
          }
          aggregate: {
            args: Prisma.MapRanksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapRanks>
          }
          groupBy: {
            args: Prisma.MapRanksGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapRanksGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapRanksCountArgs<ExtArgs>
            result: $Utils.Optional<MapRanksCountAggregateOutputType> | number
          }
        }
      }
      MapStats: {
        payload: Prisma.$MapStatsPayload<ExtArgs>
        fields: Prisma.MapStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>
          }
          findFirst: {
            args: Prisma.MapStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>
          }
          findMany: {
            args: Prisma.MapStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>[]
          }
          create: {
            args: Prisma.MapStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>
          }
          createMany: {
            args: Prisma.MapStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>[]
          }
          delete: {
            args: Prisma.MapStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>
          }
          update: {
            args: Prisma.MapStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>
          }
          deleteMany: {
            args: Prisma.MapStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>[]
          }
          upsert: {
            args: Prisma.MapStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapStatsPayload>
          }
          aggregate: {
            args: Prisma.MapStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapStats>
          }
          groupBy: {
            args: Prisma.MapStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapStatsCountArgs<ExtArgs>
            result: $Utils.Optional<MapStatsCountAggregateOutputType> | number
          }
        }
      }
      WeaponStats: {
        payload: Prisma.$WeaponStatsPayload<ExtArgs>
        fields: Prisma.WeaponStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeaponStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeaponStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>
          }
          findFirst: {
            args: Prisma.WeaponStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeaponStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>
          }
          findMany: {
            args: Prisma.WeaponStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>[]
          }
          create: {
            args: Prisma.WeaponStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>
          }
          createMany: {
            args: Prisma.WeaponStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeaponStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>[]
          }
          delete: {
            args: Prisma.WeaponStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>
          }
          update: {
            args: Prisma.WeaponStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>
          }
          deleteMany: {
            args: Prisma.WeaponStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeaponStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeaponStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>[]
          }
          upsert: {
            args: Prisma.WeaponStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponStatsPayload>
          }
          aggregate: {
            args: Prisma.WeaponStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeaponStats>
          }
          groupBy: {
            args: Prisma.WeaponStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeaponStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeaponStatsCountArgs<ExtArgs>
            result: $Utils.Optional<WeaponStatsCountAggregateOutputType> | number
          }
        }
      }
      Hit: {
        payload: Prisma.$HitPayload<ExtArgs>
        fields: Prisma.HitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>
          }
          findFirst: {
            args: Prisma.HitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>
          }
          findMany: {
            args: Prisma.HitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>[]
          }
          create: {
            args: Prisma.HitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>
          }
          createMany: {
            args: Prisma.HitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>[]
          }
          delete: {
            args: Prisma.HitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>
          }
          update: {
            args: Prisma.HitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>
          }
          deleteMany: {
            args: Prisma.HitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>[]
          }
          upsert: {
            args: Prisma.HitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HitPayload>
          }
          aggregate: {
            args: Prisma.HitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHit>
          }
          groupBy: {
            args: Prisma.HitGroupByArgs<ExtArgs>
            result: $Utils.Optional<HitGroupByOutputType>[]
          }
          count: {
            args: Prisma.HitCountArgs<ExtArgs>
            result: $Utils.Optional<HitCountAggregateOutputType> | number
          }
        }
      }
      PlayerStatisticsInMatch: {
        payload: Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>
        fields: Prisma.PlayerStatisticsInMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerStatisticsInMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerStatisticsInMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>
          }
          findFirst: {
            args: Prisma.PlayerStatisticsInMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerStatisticsInMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>
          }
          findMany: {
            args: Prisma.PlayerStatisticsInMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>[]
          }
          create: {
            args: Prisma.PlayerStatisticsInMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>
          }
          createMany: {
            args: Prisma.PlayerStatisticsInMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerStatisticsInMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>[]
          }
          delete: {
            args: Prisma.PlayerStatisticsInMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>
          }
          update: {
            args: Prisma.PlayerStatisticsInMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>
          }
          deleteMany: {
            args: Prisma.PlayerStatisticsInMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerStatisticsInMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerStatisticsInMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>[]
          }
          upsert: {
            args: Prisma.PlayerStatisticsInMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerStatisticsInMatchPayload>
          }
          aggregate: {
            args: Prisma.PlayerStatisticsInMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerStatisticsInMatch>
          }
          groupBy: {
            args: Prisma.PlayerStatisticsInMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerStatisticsInMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerStatisticsInMatchCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerStatisticsInMatchCountAggregateOutputType> | number
          }
        }
      }
      SteamUserBans: {
        payload: Prisma.$SteamUserBansPayload<ExtArgs>
        fields: Prisma.SteamUserBansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SteamUserBansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SteamUserBansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>
          }
          findFirst: {
            args: Prisma.SteamUserBansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SteamUserBansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>
          }
          findMany: {
            args: Prisma.SteamUserBansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>[]
          }
          create: {
            args: Prisma.SteamUserBansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>
          }
          createMany: {
            args: Prisma.SteamUserBansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SteamUserBansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>[]
          }
          delete: {
            args: Prisma.SteamUserBansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>
          }
          update: {
            args: Prisma.SteamUserBansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>
          }
          deleteMany: {
            args: Prisma.SteamUserBansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SteamUserBansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SteamUserBansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>[]
          }
          upsert: {
            args: Prisma.SteamUserBansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SteamUserBansPayload>
          }
          aggregate: {
            args: Prisma.SteamUserBansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSteamUserBans>
          }
          groupBy: {
            args: Prisma.SteamUserBansGroupByArgs<ExtArgs>
            result: $Utils.Optional<SteamUserBansGroupByOutputType>[]
          }
          count: {
            args: Prisma.SteamUserBansCountArgs<ExtArgs>
            result: $Utils.Optional<SteamUserBansCountAggregateOutputType> | number
          }
        }
      }
      LinksInProfile: {
        payload: Prisma.$LinksInProfilePayload<ExtArgs>
        fields: Prisma.LinksInProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinksInProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinksInProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>
          }
          findFirst: {
            args: Prisma.LinksInProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinksInProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>
          }
          findMany: {
            args: Prisma.LinksInProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>[]
          }
          create: {
            args: Prisma.LinksInProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>
          }
          createMany: {
            args: Prisma.LinksInProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinksInProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>[]
          }
          delete: {
            args: Prisma.LinksInProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>
          }
          update: {
            args: Prisma.LinksInProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>
          }
          deleteMany: {
            args: Prisma.LinksInProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinksInProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinksInProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>[]
          }
          upsert: {
            args: Prisma.LinksInProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinksInProfilePayload>
          }
          aggregate: {
            args: Prisma.LinksInProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinksInProfile>
          }
          groupBy: {
            args: Prisma.LinksInProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinksInProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinksInProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LinksInProfileCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Images: {
        payload: Prisma.$ImagesPayload<ExtArgs>
        fields: Prisma.ImagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          findFirst: {
            args: Prisma.ImagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          findMany: {
            args: Prisma.ImagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>[]
          }
          create: {
            args: Prisma.ImagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          createMany: {
            args: Prisma.ImagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>[]
          }
          delete: {
            args: Prisma.ImagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          update: {
            args: Prisma.ImagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          deleteMany: {
            args: Prisma.ImagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>[]
          }
          upsert: {
            args: Prisma.ImagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagesPayload>
          }
          aggregate: {
            args: Prisma.ImagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImages>
          }
          groupBy: {
            args: Prisma.ImagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImagesCountArgs<ExtArgs>
            result: $Utils.Optional<ImagesCountAggregateOutputType> | number
          }
        }
      }
      JwtToken: {
        payload: Prisma.$JwtTokenPayload<ExtArgs>
        fields: Prisma.JwtTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JwtTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JwtTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>
          }
          findFirst: {
            args: Prisma.JwtTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JwtTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>
          }
          findMany: {
            args: Prisma.JwtTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>[]
          }
          create: {
            args: Prisma.JwtTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>
          }
          createMany: {
            args: Prisma.JwtTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JwtTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>[]
          }
          delete: {
            args: Prisma.JwtTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>
          }
          update: {
            args: Prisma.JwtTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>
          }
          deleteMany: {
            args: Prisma.JwtTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JwtTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JwtTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>[]
          }
          upsert: {
            args: Prisma.JwtTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JwtTokenPayload>
          }
          aggregate: {
            args: Prisma.JwtTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJwtToken>
          }
          groupBy: {
            args: Prisma.JwtTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<JwtTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.JwtTokenCountArgs<ExtArgs>
            result: $Utils.Optional<JwtTokenCountAggregateOutputType> | number
          }
        }
      }
      ReportUser: {
        payload: Prisma.$ReportUserPayload<ExtArgs>
        fields: Prisma.ReportUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          findFirst: {
            args: Prisma.ReportUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          findMany: {
            args: Prisma.ReportUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>[]
          }
          create: {
            args: Prisma.ReportUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          createMany: {
            args: Prisma.ReportUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>[]
          }
          delete: {
            args: Prisma.ReportUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          update: {
            args: Prisma.ReportUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          deleteMany: {
            args: Prisma.ReportUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>[]
          }
          upsert: {
            args: Prisma.ReportUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUserPayload>
          }
          aggregate: {
            args: Prisma.ReportUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportUser>
          }
          groupBy: {
            args: Prisma.ReportUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportUserCountArgs<ExtArgs>
            result: $Utils.Optional<ReportUserCountAggregateOutputType> | number
          }
        }
      }
      Verdict: {
        payload: Prisma.$VerdictPayload<ExtArgs>
        fields: Prisma.VerdictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findFirst: {
            args: Prisma.VerdictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findMany: {
            args: Prisma.VerdictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          create: {
            args: Prisma.VerdictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          createMany: {
            args: Prisma.VerdictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          delete: {
            args: Prisma.VerdictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          update: {
            args: Prisma.VerdictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          deleteMany: {
            args: Prisma.VerdictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          upsert: {
            args: Prisma.VerdictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          aggregate: {
            args: Prisma.VerdictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdict>
          }
          groupBy: {
            args: Prisma.VerdictGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    trackingUser?: TrackingUserOmit
    notifications?: NotificationsOmit
    token?: TokenOmit
    steamUser?: SteamUserOmit
    match?: MatchOmit
    generalPlayerStatistics?: GeneralPlayerStatisticsOmit
    mapRanks?: MapRanksOmit
    mapStats?: MapStatsOmit
    weaponStats?: WeaponStatsOmit
    hit?: HitOmit
    playerStatisticsInMatch?: PlayerStatisticsInMatchOmit
    steamUserBans?: SteamUserBansOmit
    linksInProfile?: LinksInProfileOmit
    comment?: CommentOmit
    images?: ImagesOmit
    jwtToken?: JwtTokenOmit
    reportUser?: ReportUserOmit
    verdict?: VerdictOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tokens: number
    notifications: number
    trackingUsers: number
    commentsAsAuthor: number
    jwtTokens: number
    reportUsers: number
    verdicts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | UserCountOutputTypeCountTokensArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    trackingUsers?: boolean | UserCountOutputTypeCountTrackingUsersArgs
    commentsAsAuthor?: boolean | UserCountOutputTypeCountCommentsAsAuthorArgs
    jwtTokens?: boolean | UserCountOutputTypeCountJwtTokensArgs
    reportUsers?: boolean | UserCountOutputTypeCountReportUsersArgs
    verdicts?: boolean | UserCountOutputTypeCountVerdictsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrackingUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackingUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsAsAuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JwtTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }


  /**
   * Count Type SteamUserCountOutputType
   */

  export type SteamUserCountOutputType = {
    commentsAsRecipient: number
    reportsAsRecipient: number
    matches: number
    playerStatisticsInMatch: number
  }

  export type SteamUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commentsAsRecipient?: boolean | SteamUserCountOutputTypeCountCommentsAsRecipientArgs
    reportsAsRecipient?: boolean | SteamUserCountOutputTypeCountReportsAsRecipientArgs
    matches?: boolean | SteamUserCountOutputTypeCountMatchesArgs
    playerStatisticsInMatch?: boolean | SteamUserCountOutputTypeCountPlayerStatisticsInMatchArgs
  }

  // Custom InputTypes
  /**
   * SteamUserCountOutputType without action
   */
  export type SteamUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserCountOutputType
     */
    select?: SteamUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SteamUserCountOutputType without action
   */
  export type SteamUserCountOutputTypeCountCommentsAsRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * SteamUserCountOutputType without action
   */
  export type SteamUserCountOutputTypeCountReportsAsRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUserWhereInput
  }

  /**
   * SteamUserCountOutputType without action
   */
  export type SteamUserCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * SteamUserCountOutputType without action
   */
  export type SteamUserCountOutputTypeCountPlayerStatisticsInMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerStatisticsInMatchWhereInput
  }


  /**
   * Count Type MatchCountOutputType
   */

  export type MatchCountOutputType = {
    participants: number
    playersStatistic: number
  }

  export type MatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | MatchCountOutputTypeCountParticipantsArgs
    playersStatistic?: boolean | MatchCountOutputTypeCountPlayersStatisticArgs
  }

  // Custom InputTypes
  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SteamUserWhereInput
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountPlayersStatisticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerStatisticsInMatchWhereInput
  }


  /**
   * Count Type GeneralPlayerStatisticsCountOutputType
   */

  export type GeneralPlayerStatisticsCountOutputType = {
    MapRanks: number
    WeaponStats: number
  }

  export type GeneralPlayerStatisticsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MapRanks?: boolean | GeneralPlayerStatisticsCountOutputTypeCountMapRanksArgs
    WeaponStats?: boolean | GeneralPlayerStatisticsCountOutputTypeCountWeaponStatsArgs
  }

  // Custom InputTypes
  /**
   * GeneralPlayerStatisticsCountOutputType without action
   */
  export type GeneralPlayerStatisticsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatisticsCountOutputType
     */
    select?: GeneralPlayerStatisticsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneralPlayerStatisticsCountOutputType without action
   */
  export type GeneralPlayerStatisticsCountOutputTypeCountMapRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapRanksWhereInput
  }

  /**
   * GeneralPlayerStatisticsCountOutputType without action
   */
  export type GeneralPlayerStatisticsCountOutputTypeCountWeaponStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponStatsWhereInput
  }


  /**
   * Count Type MapRanksCountOutputType
   */

  export type MapRanksCountOutputType = {
    mapStat: number
  }

  export type MapRanksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mapStat?: boolean | MapRanksCountOutputTypeCountMapStatArgs
  }

  // Custom InputTypes
  /**
   * MapRanksCountOutputType without action
   */
  export type MapRanksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanksCountOutputType
     */
    select?: MapRanksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MapRanksCountOutputType without action
   */
  export type MapRanksCountOutputTypeCountMapStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapStatsWhereInput
  }


  /**
   * Count Type WeaponStatsCountOutputType
   */

  export type WeaponStatsCountOutputType = {
    hits: number
  }

  export type WeaponStatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hits?: boolean | WeaponStatsCountOutputTypeCountHitsArgs
  }

  // Custom InputTypes
  /**
   * WeaponStatsCountOutputType without action
   */
  export type WeaponStatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStatsCountOutputType
     */
    select?: WeaponStatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeaponStatsCountOutputType without action
   */
  export type WeaponStatsCountOutputTypeCountHitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HitWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    images: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | CommentCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagesWhereInput
  }


  /**
   * Count Type ReportUserCountOutputType
   */

  export type ReportUserCountOutputType = {
    verdicts: number
  }

  export type ReportUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdicts?: boolean | ReportUserCountOutputTypeCountVerdictsArgs
  }

  // Custom InputTypes
  /**
   * ReportUserCountOutputType without action
   */
  export type ReportUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUserCountOutputType
     */
    select?: ReportUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportUserCountOutputType without action
   */
  export type ReportUserCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    additionalRole: $Enums.AdditionalRole | null
    isEmailVerified: boolean | null
    isBanned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    additionalRole: $Enums.AdditionalRole | null
    isEmailVerified: boolean | null
    isBanned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    avatar: number
    role: number
    additionalRole: number
    isEmailVerified: number
    isBanned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatar?: true
    role?: true
    additionalRole?: true
    isEmailVerified?: true
    isBanned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatar?: true
    role?: true
    additionalRole?: true
    isEmailVerified?: true
    isBanned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    avatar?: true
    role?: true
    additionalRole?: true
    isEmailVerified?: true
    isBanned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    avatar: string | null
    role: $Enums.UserRole
    additionalRole: $Enums.AdditionalRole
    isEmailVerified: boolean
    isBanned: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    additionalRole?: boolean
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokens?: boolean | User$tokensArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    trackingUsers?: boolean | User$trackingUsersArgs<ExtArgs>
    links?: boolean | User$linksArgs<ExtArgs>
    steamUser?: boolean | User$steamUserArgs<ExtArgs>
    commentsAsAuthor?: boolean | User$commentsAsAuthorArgs<ExtArgs>
    jwtTokens?: boolean | User$jwtTokensArgs<ExtArgs>
    reportUsers?: boolean | User$reportUsersArgs<ExtArgs>
    verdicts?: boolean | User$verdictsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    additionalRole?: boolean
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    additionalRole?: boolean
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    avatar?: boolean
    role?: boolean
    additionalRole?: boolean
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password" | "avatar" | "role" | "additionalRole" | "isEmailVerified" | "isBanned" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | User$tokensArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    trackingUsers?: boolean | User$trackingUsersArgs<ExtArgs>
    links?: boolean | User$linksArgs<ExtArgs>
    steamUser?: boolean | User$steamUserArgs<ExtArgs>
    commentsAsAuthor?: boolean | User$commentsAsAuthorArgs<ExtArgs>
    jwtTokens?: boolean | User$jwtTokensArgs<ExtArgs>
    reportUsers?: boolean | User$reportUsersArgs<ExtArgs>
    verdicts?: boolean | User$verdictsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tokens: Prisma.$TokenPayload<ExtArgs>[]
      notifications: Prisma.$NotificationsPayload<ExtArgs>[]
      trackingUsers: Prisma.$TrackingUserPayload<ExtArgs>[]
      links: Prisma.$LinksInProfilePayload<ExtArgs> | null
      steamUser: Prisma.$SteamUserPayload<ExtArgs> | null
      commentsAsAuthor: Prisma.$CommentPayload<ExtArgs>[]
      jwtTokens: Prisma.$JwtTokenPayload<ExtArgs>[]
      reportUsers: Prisma.$ReportUserPayload<ExtArgs>[]
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password: string
      avatar: string | null
      role: $Enums.UserRole
      additionalRole: $Enums.AdditionalRole
      isEmailVerified: boolean
      isBanned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tokens<T extends User$tokensArgs<ExtArgs> = {}>(args?: Subset<T, User$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trackingUsers<T extends User$trackingUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$trackingUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    links<T extends User$linksArgs<ExtArgs> = {}>(args?: Subset<T, User$linksArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    steamUser<T extends User$steamUserArgs<ExtArgs> = {}>(args?: Subset<T, User$steamUserArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    commentsAsAuthor<T extends User$commentsAsAuthorArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsAsAuthorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jwtTokens<T extends User$jwtTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$jwtTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportUsers<T extends User$reportUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$reportUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdicts<T extends User$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, User$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly additionalRole: FieldRef<"User", 'AdditionalRole'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tokens
   */
  export type User$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * User.trackingUsers
   */
  export type User$trackingUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    where?: TrackingUserWhereInput
    orderBy?: TrackingUserOrderByWithRelationInput | TrackingUserOrderByWithRelationInput[]
    cursor?: TrackingUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackingUserScalarFieldEnum | TrackingUserScalarFieldEnum[]
  }

  /**
   * User.links
   */
  export type User$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    where?: LinksInProfileWhereInput
  }

  /**
   * User.steamUser
   */
  export type User$steamUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    where?: SteamUserWhereInput
  }

  /**
   * User.commentsAsAuthor
   */
  export type User$commentsAsAuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.jwtTokens
   */
  export type User$jwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    where?: JwtTokenWhereInput
    orderBy?: JwtTokenOrderByWithRelationInput | JwtTokenOrderByWithRelationInput[]
    cursor?: JwtTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JwtTokenScalarFieldEnum | JwtTokenScalarFieldEnum[]
  }

  /**
   * User.reportUsers
   */
  export type User$reportUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    where?: ReportUserWhereInput
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    cursor?: ReportUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * User.verdicts
   */
  export type User$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model TrackingUser
   */

  export type AggregateTrackingUser = {
    _count: TrackingUserCountAggregateOutputType | null
    _min: TrackingUserMinAggregateOutputType | null
    _max: TrackingUserMaxAggregateOutputType | null
  }

  export type TrackingUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    steamid: string | null
    dateBanned: Date | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrackingUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    steamid: string | null
    dateBanned: Date | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrackingUserCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    steamid: number
    dateBanned: number
    avatar: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrackingUserMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    steamid?: true
    dateBanned?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrackingUserMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    steamid?: true
    dateBanned?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrackingUserCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    steamid?: true
    dateBanned?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrackingUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackingUser to aggregate.
     */
    where?: TrackingUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingUsers to fetch.
     */
    orderBy?: TrackingUserOrderByWithRelationInput | TrackingUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrackingUsers
    **/
    _count?: true | TrackingUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackingUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackingUserMaxAggregateInputType
  }

  export type GetTrackingUserAggregateType<T extends TrackingUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackingUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackingUser[P]>
      : GetScalarType<T[P], AggregateTrackingUser[P]>
  }




  export type TrackingUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackingUserWhereInput
    orderBy?: TrackingUserOrderByWithAggregationInput | TrackingUserOrderByWithAggregationInput[]
    by: TrackingUserScalarFieldEnum[] | TrackingUserScalarFieldEnum
    having?: TrackingUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackingUserCountAggregateInputType | true
    _min?: TrackingUserMinAggregateInputType
    _max?: TrackingUserMaxAggregateInputType
  }

  export type TrackingUserGroupByOutputType = {
    id: string
    userId: string
    name: string
    steamid: string
    dateBanned: Date | null
    avatar: string
    createdAt: Date
    updatedAt: Date
    _count: TrackingUserCountAggregateOutputType | null
    _min: TrackingUserMinAggregateOutputType | null
    _max: TrackingUserMaxAggregateOutputType | null
  }

  type GetTrackingUserGroupByPayload<T extends TrackingUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackingUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackingUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackingUserGroupByOutputType[P]>
            : GetScalarType<T[P], TrackingUserGroupByOutputType[P]>
        }
      >
    >


  export type TrackingUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    steamid?: boolean
    dateBanned?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingUser"]>

  export type TrackingUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    steamid?: boolean
    dateBanned?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingUser"]>

  export type TrackingUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    steamid?: boolean
    dateBanned?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingUser"]>

  export type TrackingUserSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    steamid?: boolean
    dateBanned?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrackingUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "steamid" | "dateBanned" | "avatar" | "createdAt" | "updatedAt", ExtArgs["result"]["trackingUser"]>
  export type TrackingUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrackingUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TrackingUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TrackingUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrackingUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      steamid: string
      dateBanned: Date | null
      avatar: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trackingUser"]>
    composites: {}
  }

  type TrackingUserGetPayload<S extends boolean | null | undefined | TrackingUserDefaultArgs> = $Result.GetResult<Prisma.$TrackingUserPayload, S>

  type TrackingUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrackingUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrackingUserCountAggregateInputType | true
    }

  export interface TrackingUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrackingUser'], meta: { name: 'TrackingUser' } }
    /**
     * Find zero or one TrackingUser that matches the filter.
     * @param {TrackingUserFindUniqueArgs} args - Arguments to find a TrackingUser
     * @example
     * // Get one TrackingUser
     * const trackingUser = await prisma.trackingUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrackingUserFindUniqueArgs>(args: SelectSubset<T, TrackingUserFindUniqueArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrackingUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrackingUserFindUniqueOrThrowArgs} args - Arguments to find a TrackingUser
     * @example
     * // Get one TrackingUser
     * const trackingUser = await prisma.trackingUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrackingUserFindUniqueOrThrowArgs>(args: SelectSubset<T, TrackingUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrackingUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingUserFindFirstArgs} args - Arguments to find a TrackingUser
     * @example
     * // Get one TrackingUser
     * const trackingUser = await prisma.trackingUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrackingUserFindFirstArgs>(args?: SelectSubset<T, TrackingUserFindFirstArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrackingUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingUserFindFirstOrThrowArgs} args - Arguments to find a TrackingUser
     * @example
     * // Get one TrackingUser
     * const trackingUser = await prisma.trackingUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrackingUserFindFirstOrThrowArgs>(args?: SelectSubset<T, TrackingUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrackingUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrackingUsers
     * const trackingUsers = await prisma.trackingUser.findMany()
     * 
     * // Get first 10 TrackingUsers
     * const trackingUsers = await prisma.trackingUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackingUserWithIdOnly = await prisma.trackingUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrackingUserFindManyArgs>(args?: SelectSubset<T, TrackingUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrackingUser.
     * @param {TrackingUserCreateArgs} args - Arguments to create a TrackingUser.
     * @example
     * // Create one TrackingUser
     * const TrackingUser = await prisma.trackingUser.create({
     *   data: {
     *     // ... data to create a TrackingUser
     *   }
     * })
     * 
     */
    create<T extends TrackingUserCreateArgs>(args: SelectSubset<T, TrackingUserCreateArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrackingUsers.
     * @param {TrackingUserCreateManyArgs} args - Arguments to create many TrackingUsers.
     * @example
     * // Create many TrackingUsers
     * const trackingUser = await prisma.trackingUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrackingUserCreateManyArgs>(args?: SelectSubset<T, TrackingUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrackingUsers and returns the data saved in the database.
     * @param {TrackingUserCreateManyAndReturnArgs} args - Arguments to create many TrackingUsers.
     * @example
     * // Create many TrackingUsers
     * const trackingUser = await prisma.trackingUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrackingUsers and only return the `id`
     * const trackingUserWithIdOnly = await prisma.trackingUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrackingUserCreateManyAndReturnArgs>(args?: SelectSubset<T, TrackingUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrackingUser.
     * @param {TrackingUserDeleteArgs} args - Arguments to delete one TrackingUser.
     * @example
     * // Delete one TrackingUser
     * const TrackingUser = await prisma.trackingUser.delete({
     *   where: {
     *     // ... filter to delete one TrackingUser
     *   }
     * })
     * 
     */
    delete<T extends TrackingUserDeleteArgs>(args: SelectSubset<T, TrackingUserDeleteArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrackingUser.
     * @param {TrackingUserUpdateArgs} args - Arguments to update one TrackingUser.
     * @example
     * // Update one TrackingUser
     * const trackingUser = await prisma.trackingUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrackingUserUpdateArgs>(args: SelectSubset<T, TrackingUserUpdateArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrackingUsers.
     * @param {TrackingUserDeleteManyArgs} args - Arguments to filter TrackingUsers to delete.
     * @example
     * // Delete a few TrackingUsers
     * const { count } = await prisma.trackingUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrackingUserDeleteManyArgs>(args?: SelectSubset<T, TrackingUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackingUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrackingUsers
     * const trackingUser = await prisma.trackingUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrackingUserUpdateManyArgs>(args: SelectSubset<T, TrackingUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackingUsers and returns the data updated in the database.
     * @param {TrackingUserUpdateManyAndReturnArgs} args - Arguments to update many TrackingUsers.
     * @example
     * // Update many TrackingUsers
     * const trackingUser = await prisma.trackingUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrackingUsers and only return the `id`
     * const trackingUserWithIdOnly = await prisma.trackingUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrackingUserUpdateManyAndReturnArgs>(args: SelectSubset<T, TrackingUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrackingUser.
     * @param {TrackingUserUpsertArgs} args - Arguments to update or create a TrackingUser.
     * @example
     * // Update or create a TrackingUser
     * const trackingUser = await prisma.trackingUser.upsert({
     *   create: {
     *     // ... data to create a TrackingUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrackingUser we want to update
     *   }
     * })
     */
    upsert<T extends TrackingUserUpsertArgs>(args: SelectSubset<T, TrackingUserUpsertArgs<ExtArgs>>): Prisma__TrackingUserClient<$Result.GetResult<Prisma.$TrackingUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrackingUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingUserCountArgs} args - Arguments to filter TrackingUsers to count.
     * @example
     * // Count the number of TrackingUsers
     * const count = await prisma.trackingUser.count({
     *   where: {
     *     // ... the filter for the TrackingUsers we want to count
     *   }
     * })
    **/
    count<T extends TrackingUserCountArgs>(
      args?: Subset<T, TrackingUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackingUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrackingUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackingUserAggregateArgs>(args: Subset<T, TrackingUserAggregateArgs>): Prisma.PrismaPromise<GetTrackingUserAggregateType<T>>

    /**
     * Group by TrackingUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackingUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackingUserGroupByArgs['orderBy'] }
        : { orderBy?: TrackingUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackingUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackingUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrackingUser model
   */
  readonly fields: TrackingUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrackingUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackingUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrackingUser model
   */
  interface TrackingUserFieldRefs {
    readonly id: FieldRef<"TrackingUser", 'String'>
    readonly userId: FieldRef<"TrackingUser", 'String'>
    readonly name: FieldRef<"TrackingUser", 'String'>
    readonly steamid: FieldRef<"TrackingUser", 'String'>
    readonly dateBanned: FieldRef<"TrackingUser", 'DateTime'>
    readonly avatar: FieldRef<"TrackingUser", 'String'>
    readonly createdAt: FieldRef<"TrackingUser", 'DateTime'>
    readonly updatedAt: FieldRef<"TrackingUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrackingUser findUnique
   */
  export type TrackingUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * Filter, which TrackingUser to fetch.
     */
    where: TrackingUserWhereUniqueInput
  }

  /**
   * TrackingUser findUniqueOrThrow
   */
  export type TrackingUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * Filter, which TrackingUser to fetch.
     */
    where: TrackingUserWhereUniqueInput
  }

  /**
   * TrackingUser findFirst
   */
  export type TrackingUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * Filter, which TrackingUser to fetch.
     */
    where?: TrackingUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingUsers to fetch.
     */
    orderBy?: TrackingUserOrderByWithRelationInput | TrackingUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackingUsers.
     */
    cursor?: TrackingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackingUsers.
     */
    distinct?: TrackingUserScalarFieldEnum | TrackingUserScalarFieldEnum[]
  }

  /**
   * TrackingUser findFirstOrThrow
   */
  export type TrackingUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * Filter, which TrackingUser to fetch.
     */
    where?: TrackingUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingUsers to fetch.
     */
    orderBy?: TrackingUserOrderByWithRelationInput | TrackingUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackingUsers.
     */
    cursor?: TrackingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackingUsers.
     */
    distinct?: TrackingUserScalarFieldEnum | TrackingUserScalarFieldEnum[]
  }

  /**
   * TrackingUser findMany
   */
  export type TrackingUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * Filter, which TrackingUsers to fetch.
     */
    where?: TrackingUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingUsers to fetch.
     */
    orderBy?: TrackingUserOrderByWithRelationInput | TrackingUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrackingUsers.
     */
    cursor?: TrackingUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingUsers.
     */
    skip?: number
    distinct?: TrackingUserScalarFieldEnum | TrackingUserScalarFieldEnum[]
  }

  /**
   * TrackingUser create
   */
  export type TrackingUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * The data needed to create a TrackingUser.
     */
    data: XOR<TrackingUserCreateInput, TrackingUserUncheckedCreateInput>
  }

  /**
   * TrackingUser createMany
   */
  export type TrackingUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrackingUsers.
     */
    data: TrackingUserCreateManyInput | TrackingUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrackingUser createManyAndReturn
   */
  export type TrackingUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * The data used to create many TrackingUsers.
     */
    data: TrackingUserCreateManyInput | TrackingUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrackingUser update
   */
  export type TrackingUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * The data needed to update a TrackingUser.
     */
    data: XOR<TrackingUserUpdateInput, TrackingUserUncheckedUpdateInput>
    /**
     * Choose, which TrackingUser to update.
     */
    where: TrackingUserWhereUniqueInput
  }

  /**
   * TrackingUser updateMany
   */
  export type TrackingUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrackingUsers.
     */
    data: XOR<TrackingUserUpdateManyMutationInput, TrackingUserUncheckedUpdateManyInput>
    /**
     * Filter which TrackingUsers to update
     */
    where?: TrackingUserWhereInput
    /**
     * Limit how many TrackingUsers to update.
     */
    limit?: number
  }

  /**
   * TrackingUser updateManyAndReturn
   */
  export type TrackingUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * The data used to update TrackingUsers.
     */
    data: XOR<TrackingUserUpdateManyMutationInput, TrackingUserUncheckedUpdateManyInput>
    /**
     * Filter which TrackingUsers to update
     */
    where?: TrackingUserWhereInput
    /**
     * Limit how many TrackingUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrackingUser upsert
   */
  export type TrackingUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * The filter to search for the TrackingUser to update in case it exists.
     */
    where: TrackingUserWhereUniqueInput
    /**
     * In case the TrackingUser found by the `where` argument doesn't exist, create a new TrackingUser with this data.
     */
    create: XOR<TrackingUserCreateInput, TrackingUserUncheckedCreateInput>
    /**
     * In case the TrackingUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackingUserUpdateInput, TrackingUserUncheckedUpdateInput>
  }

  /**
   * TrackingUser delete
   */
  export type TrackingUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
    /**
     * Filter which TrackingUser to delete.
     */
    where: TrackingUserWhereUniqueInput
  }

  /**
   * TrackingUser deleteMany
   */
  export type TrackingUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackingUsers to delete
     */
    where?: TrackingUserWhereInput
    /**
     * Limit how many TrackingUsers to delete.
     */
    limit?: number
  }

  /**
   * TrackingUser without action
   */
  export type TrackingUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingUser
     */
    select?: TrackingUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingUser
     */
    omit?: TrackingUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingUserInclude<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    description: string | null
    isViewed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    description: string | null
    isViewed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    description: number
    isViewed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    isViewed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    isViewed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    isViewed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    description: string | null
    isViewed: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    isViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    isViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    isViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    isViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "description" | "isViewed" | "createdAt" | "updatedAt", ExtArgs["result"]["notifications"]>
  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      description: string | null
      isViewed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsFindManyArgs>(args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends NotificationsCreateArgs>(args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsCreateManyArgs>(args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends NotificationsDeleteArgs>(args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsUpdateArgs>(args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsUpdateManyArgs>(args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notifications model
   */
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'String'>
    readonly userId: FieldRef<"Notifications", 'String'>
    readonly type: FieldRef<"Notifications", 'NotificationType'>
    readonly title: FieldRef<"Notifications", 'String'>
    readonly description: FieldRef<"Notifications", 'String'>
    readonly isViewed: FieldRef<"Notifications", 'Boolean'>
    readonly createdAt: FieldRef<"Notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"Notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications createManyAndReturn
   */
  export type NotificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notifications updateManyAndReturn
   */
  export type NotificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    expiresIn: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    expiresIn: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    token: number
    type: number
    expiresIn: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokenMinAggregateInputType = {
    id?: true
    token?: true
    type?: true
    expiresIn?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    token?: true
    type?: true
    expiresIn?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    token?: true
    type?: true
    expiresIn?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    token: string
    type: $Enums.TokenType
    expiresIn: Date
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    expiresIn?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    expiresIn?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    expiresIn?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    token?: boolean
    type?: boolean
    expiresIn?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "type" | "expiresIn" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      type: $Enums.TokenType
      expiresIn: Date
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly token: FieldRef<"Token", 'String'>
    readonly type: FieldRef<"Token", 'TokenType'>
    readonly expiresIn: FieldRef<"Token", 'DateTime'>
    readonly userId: FieldRef<"Token", 'String'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly updatedAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model SteamUser
   */

  export type AggregateSteamUser = {
    _count: SteamUserCountAggregateOutputType | null
    _avg: SteamUserAvgAggregateOutputType | null
    _sum: SteamUserSumAggregateOutputType | null
    _min: SteamUserMinAggregateOutputType | null
    _max: SteamUserMaxAggregateOutputType | null
  }

  export type SteamUserAvgAggregateOutputType = {
    viewers: number | null
  }

  export type SteamUserSumAggregateOutputType = {
    viewers: number | null
  }

  export type SteamUserMinAggregateOutputType = {
    id: string | null
    personaName: string | null
    profileUrl: string | null
    avatar: string | null
    realname: string | null
    level: string | null
    timeCreated: string | null
    steamId2: string | null
    steamId3: string | null
    steamIdHex: string | null
    countryCode: string | null
    lastUpdateSteamInformation: Date | null
    viewers: number | null
    userId: string | null
    sharedCode: string | null
    gameAuthenticationCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SteamUserMaxAggregateOutputType = {
    id: string | null
    personaName: string | null
    profileUrl: string | null
    avatar: string | null
    realname: string | null
    level: string | null
    timeCreated: string | null
    steamId2: string | null
    steamId3: string | null
    steamIdHex: string | null
    countryCode: string | null
    lastUpdateSteamInformation: Date | null
    viewers: number | null
    userId: string | null
    sharedCode: string | null
    gameAuthenticationCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SteamUserCountAggregateOutputType = {
    id: number
    personaName: number
    profileUrl: number
    avatar: number
    realname: number
    level: number
    timeCreated: number
    steamId2: number
    steamId3: number
    steamIdHex: number
    countryCode: number
    lastUpdateSteamInformation: number
    viewers: number
    userId: number
    sharedCode: number
    gameAuthenticationCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SteamUserAvgAggregateInputType = {
    viewers?: true
  }

  export type SteamUserSumAggregateInputType = {
    viewers?: true
  }

  export type SteamUserMinAggregateInputType = {
    id?: true
    personaName?: true
    profileUrl?: true
    avatar?: true
    realname?: true
    level?: true
    timeCreated?: true
    steamId2?: true
    steamId3?: true
    steamIdHex?: true
    countryCode?: true
    lastUpdateSteamInformation?: true
    viewers?: true
    userId?: true
    sharedCode?: true
    gameAuthenticationCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SteamUserMaxAggregateInputType = {
    id?: true
    personaName?: true
    profileUrl?: true
    avatar?: true
    realname?: true
    level?: true
    timeCreated?: true
    steamId2?: true
    steamId3?: true
    steamIdHex?: true
    countryCode?: true
    lastUpdateSteamInformation?: true
    viewers?: true
    userId?: true
    sharedCode?: true
    gameAuthenticationCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SteamUserCountAggregateInputType = {
    id?: true
    personaName?: true
    profileUrl?: true
    avatar?: true
    realname?: true
    level?: true
    timeCreated?: true
    steamId2?: true
    steamId3?: true
    steamIdHex?: true
    countryCode?: true
    lastUpdateSteamInformation?: true
    viewers?: true
    userId?: true
    sharedCode?: true
    gameAuthenticationCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SteamUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SteamUser to aggregate.
     */
    where?: SteamUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUsers to fetch.
     */
    orderBy?: SteamUserOrderByWithRelationInput | SteamUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SteamUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SteamUsers
    **/
    _count?: true | SteamUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SteamUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SteamUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SteamUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SteamUserMaxAggregateInputType
  }

  export type GetSteamUserAggregateType<T extends SteamUserAggregateArgs> = {
        [P in keyof T & keyof AggregateSteamUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSteamUser[P]>
      : GetScalarType<T[P], AggregateSteamUser[P]>
  }




  export type SteamUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SteamUserWhereInput
    orderBy?: SteamUserOrderByWithAggregationInput | SteamUserOrderByWithAggregationInput[]
    by: SteamUserScalarFieldEnum[] | SteamUserScalarFieldEnum
    having?: SteamUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SteamUserCountAggregateInputType | true
    _avg?: SteamUserAvgAggregateInputType
    _sum?: SteamUserSumAggregateInputType
    _min?: SteamUserMinAggregateInputType
    _max?: SteamUserMaxAggregateInputType
  }

  export type SteamUserGroupByOutputType = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname: string | null
    level: string | null
    timeCreated: string
    steamId2: string | null
    steamId3: string | null
    steamIdHex: string | null
    countryCode: string | null
    lastUpdateSteamInformation: Date
    viewers: number
    userId: string | null
    sharedCode: string | null
    gameAuthenticationCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: SteamUserCountAggregateOutputType | null
    _avg: SteamUserAvgAggregateOutputType | null
    _sum: SteamUserSumAggregateOutputType | null
    _min: SteamUserMinAggregateOutputType | null
    _max: SteamUserMaxAggregateOutputType | null
  }

  type GetSteamUserGroupByPayload<T extends SteamUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SteamUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SteamUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SteamUserGroupByOutputType[P]>
            : GetScalarType<T[P], SteamUserGroupByOutputType[P]>
        }
      >
    >


  export type SteamUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personaName?: boolean
    profileUrl?: boolean
    avatar?: boolean
    realname?: boolean
    level?: boolean
    timeCreated?: boolean
    steamId2?: boolean
    steamId3?: boolean
    steamIdHex?: boolean
    countryCode?: boolean
    lastUpdateSteamInformation?: boolean
    viewers?: boolean
    userId?: boolean
    sharedCode?: boolean
    gameAuthenticationCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SteamUser$userArgs<ExtArgs>
    steamUserBans?: boolean | SteamUser$steamUserBansArgs<ExtArgs>
    commentsAsRecipient?: boolean | SteamUser$commentsAsRecipientArgs<ExtArgs>
    reportsAsRecipient?: boolean | SteamUser$reportsAsRecipientArgs<ExtArgs>
    matches?: boolean | SteamUser$matchesArgs<ExtArgs>
    playerStatisticsInMatch?: boolean | SteamUser$playerStatisticsInMatchArgs<ExtArgs>
    generalPlayerStatistics?: boolean | SteamUser$generalPlayerStatisticsArgs<ExtArgs>
    _count?: boolean | SteamUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["steamUser"]>

  export type SteamUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personaName?: boolean
    profileUrl?: boolean
    avatar?: boolean
    realname?: boolean
    level?: boolean
    timeCreated?: boolean
    steamId2?: boolean
    steamId3?: boolean
    steamIdHex?: boolean
    countryCode?: boolean
    lastUpdateSteamInformation?: boolean
    viewers?: boolean
    userId?: boolean
    sharedCode?: boolean
    gameAuthenticationCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SteamUser$userArgs<ExtArgs>
  }, ExtArgs["result"]["steamUser"]>

  export type SteamUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personaName?: boolean
    profileUrl?: boolean
    avatar?: boolean
    realname?: boolean
    level?: boolean
    timeCreated?: boolean
    steamId2?: boolean
    steamId3?: boolean
    steamIdHex?: boolean
    countryCode?: boolean
    lastUpdateSteamInformation?: boolean
    viewers?: boolean
    userId?: boolean
    sharedCode?: boolean
    gameAuthenticationCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SteamUser$userArgs<ExtArgs>
  }, ExtArgs["result"]["steamUser"]>

  export type SteamUserSelectScalar = {
    id?: boolean
    personaName?: boolean
    profileUrl?: boolean
    avatar?: boolean
    realname?: boolean
    level?: boolean
    timeCreated?: boolean
    steamId2?: boolean
    steamId3?: boolean
    steamIdHex?: boolean
    countryCode?: boolean
    lastUpdateSteamInformation?: boolean
    viewers?: boolean
    userId?: boolean
    sharedCode?: boolean
    gameAuthenticationCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SteamUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personaName" | "profileUrl" | "avatar" | "realname" | "level" | "timeCreated" | "steamId2" | "steamId3" | "steamIdHex" | "countryCode" | "lastUpdateSteamInformation" | "viewers" | "userId" | "sharedCode" | "gameAuthenticationCode" | "createdAt" | "updatedAt", ExtArgs["result"]["steamUser"]>
  export type SteamUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SteamUser$userArgs<ExtArgs>
    steamUserBans?: boolean | SteamUser$steamUserBansArgs<ExtArgs>
    commentsAsRecipient?: boolean | SteamUser$commentsAsRecipientArgs<ExtArgs>
    reportsAsRecipient?: boolean | SteamUser$reportsAsRecipientArgs<ExtArgs>
    matches?: boolean | SteamUser$matchesArgs<ExtArgs>
    playerStatisticsInMatch?: boolean | SteamUser$playerStatisticsInMatchArgs<ExtArgs>
    generalPlayerStatistics?: boolean | SteamUser$generalPlayerStatisticsArgs<ExtArgs>
    _count?: boolean | SteamUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SteamUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SteamUser$userArgs<ExtArgs>
  }
  export type SteamUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SteamUser$userArgs<ExtArgs>
  }

  export type $SteamUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SteamUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      steamUserBans: Prisma.$SteamUserBansPayload<ExtArgs> | null
      commentsAsRecipient: Prisma.$CommentPayload<ExtArgs>[]
      reportsAsRecipient: Prisma.$ReportUserPayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
      playerStatisticsInMatch: Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>[]
      generalPlayerStatistics: Prisma.$GeneralPlayerStatisticsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      personaName: string
      profileUrl: string
      avatar: string
      realname: string | null
      level: string | null
      timeCreated: string
      steamId2: string | null
      steamId3: string | null
      steamIdHex: string | null
      countryCode: string | null
      lastUpdateSteamInformation: Date
      viewers: number
      userId: string | null
      sharedCode: string | null
      gameAuthenticationCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["steamUser"]>
    composites: {}
  }

  type SteamUserGetPayload<S extends boolean | null | undefined | SteamUserDefaultArgs> = $Result.GetResult<Prisma.$SteamUserPayload, S>

  type SteamUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SteamUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SteamUserCountAggregateInputType | true
    }

  export interface SteamUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SteamUser'], meta: { name: 'SteamUser' } }
    /**
     * Find zero or one SteamUser that matches the filter.
     * @param {SteamUserFindUniqueArgs} args - Arguments to find a SteamUser
     * @example
     * // Get one SteamUser
     * const steamUser = await prisma.steamUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SteamUserFindUniqueArgs>(args: SelectSubset<T, SteamUserFindUniqueArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SteamUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SteamUserFindUniqueOrThrowArgs} args - Arguments to find a SteamUser
     * @example
     * // Get one SteamUser
     * const steamUser = await prisma.steamUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SteamUserFindUniqueOrThrowArgs>(args: SelectSubset<T, SteamUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SteamUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserFindFirstArgs} args - Arguments to find a SteamUser
     * @example
     * // Get one SteamUser
     * const steamUser = await prisma.steamUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SteamUserFindFirstArgs>(args?: SelectSubset<T, SteamUserFindFirstArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SteamUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserFindFirstOrThrowArgs} args - Arguments to find a SteamUser
     * @example
     * // Get one SteamUser
     * const steamUser = await prisma.steamUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SteamUserFindFirstOrThrowArgs>(args?: SelectSubset<T, SteamUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SteamUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SteamUsers
     * const steamUsers = await prisma.steamUser.findMany()
     * 
     * // Get first 10 SteamUsers
     * const steamUsers = await prisma.steamUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const steamUserWithIdOnly = await prisma.steamUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SteamUserFindManyArgs>(args?: SelectSubset<T, SteamUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SteamUser.
     * @param {SteamUserCreateArgs} args - Arguments to create a SteamUser.
     * @example
     * // Create one SteamUser
     * const SteamUser = await prisma.steamUser.create({
     *   data: {
     *     // ... data to create a SteamUser
     *   }
     * })
     * 
     */
    create<T extends SteamUserCreateArgs>(args: SelectSubset<T, SteamUserCreateArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SteamUsers.
     * @param {SteamUserCreateManyArgs} args - Arguments to create many SteamUsers.
     * @example
     * // Create many SteamUsers
     * const steamUser = await prisma.steamUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SteamUserCreateManyArgs>(args?: SelectSubset<T, SteamUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SteamUsers and returns the data saved in the database.
     * @param {SteamUserCreateManyAndReturnArgs} args - Arguments to create many SteamUsers.
     * @example
     * // Create many SteamUsers
     * const steamUser = await prisma.steamUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SteamUsers and only return the `id`
     * const steamUserWithIdOnly = await prisma.steamUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SteamUserCreateManyAndReturnArgs>(args?: SelectSubset<T, SteamUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SteamUser.
     * @param {SteamUserDeleteArgs} args - Arguments to delete one SteamUser.
     * @example
     * // Delete one SteamUser
     * const SteamUser = await prisma.steamUser.delete({
     *   where: {
     *     // ... filter to delete one SteamUser
     *   }
     * })
     * 
     */
    delete<T extends SteamUserDeleteArgs>(args: SelectSubset<T, SteamUserDeleteArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SteamUser.
     * @param {SteamUserUpdateArgs} args - Arguments to update one SteamUser.
     * @example
     * // Update one SteamUser
     * const steamUser = await prisma.steamUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SteamUserUpdateArgs>(args: SelectSubset<T, SteamUserUpdateArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SteamUsers.
     * @param {SteamUserDeleteManyArgs} args - Arguments to filter SteamUsers to delete.
     * @example
     * // Delete a few SteamUsers
     * const { count } = await prisma.steamUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SteamUserDeleteManyArgs>(args?: SelectSubset<T, SteamUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SteamUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SteamUsers
     * const steamUser = await prisma.steamUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SteamUserUpdateManyArgs>(args: SelectSubset<T, SteamUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SteamUsers and returns the data updated in the database.
     * @param {SteamUserUpdateManyAndReturnArgs} args - Arguments to update many SteamUsers.
     * @example
     * // Update many SteamUsers
     * const steamUser = await prisma.steamUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SteamUsers and only return the `id`
     * const steamUserWithIdOnly = await prisma.steamUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SteamUserUpdateManyAndReturnArgs>(args: SelectSubset<T, SteamUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SteamUser.
     * @param {SteamUserUpsertArgs} args - Arguments to update or create a SteamUser.
     * @example
     * // Update or create a SteamUser
     * const steamUser = await prisma.steamUser.upsert({
     *   create: {
     *     // ... data to create a SteamUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SteamUser we want to update
     *   }
     * })
     */
    upsert<T extends SteamUserUpsertArgs>(args: SelectSubset<T, SteamUserUpsertArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SteamUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserCountArgs} args - Arguments to filter SteamUsers to count.
     * @example
     * // Count the number of SteamUsers
     * const count = await prisma.steamUser.count({
     *   where: {
     *     // ... the filter for the SteamUsers we want to count
     *   }
     * })
    **/
    count<T extends SteamUserCountArgs>(
      args?: Subset<T, SteamUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SteamUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SteamUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SteamUserAggregateArgs>(args: Subset<T, SteamUserAggregateArgs>): Prisma.PrismaPromise<GetSteamUserAggregateType<T>>

    /**
     * Group by SteamUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SteamUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SteamUserGroupByArgs['orderBy'] }
        : { orderBy?: SteamUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SteamUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSteamUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SteamUser model
   */
  readonly fields: SteamUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SteamUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SteamUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SteamUser$userArgs<ExtArgs> = {}>(args?: Subset<T, SteamUser$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    steamUserBans<T extends SteamUser$steamUserBansArgs<ExtArgs> = {}>(args?: Subset<T, SteamUser$steamUserBansArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    commentsAsRecipient<T extends SteamUser$commentsAsRecipientArgs<ExtArgs> = {}>(args?: Subset<T, SteamUser$commentsAsRecipientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportsAsRecipient<T extends SteamUser$reportsAsRecipientArgs<ExtArgs> = {}>(args?: Subset<T, SteamUser$reportsAsRecipientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matches<T extends SteamUser$matchesArgs<ExtArgs> = {}>(args?: Subset<T, SteamUser$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerStatisticsInMatch<T extends SteamUser$playerStatisticsInMatchArgs<ExtArgs> = {}>(args?: Subset<T, SteamUser$playerStatisticsInMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generalPlayerStatistics<T extends SteamUser$generalPlayerStatisticsArgs<ExtArgs> = {}>(args?: Subset<T, SteamUser$generalPlayerStatisticsArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SteamUser model
   */
  interface SteamUserFieldRefs {
    readonly id: FieldRef<"SteamUser", 'String'>
    readonly personaName: FieldRef<"SteamUser", 'String'>
    readonly profileUrl: FieldRef<"SteamUser", 'String'>
    readonly avatar: FieldRef<"SteamUser", 'String'>
    readonly realname: FieldRef<"SteamUser", 'String'>
    readonly level: FieldRef<"SteamUser", 'String'>
    readonly timeCreated: FieldRef<"SteamUser", 'String'>
    readonly steamId2: FieldRef<"SteamUser", 'String'>
    readonly steamId3: FieldRef<"SteamUser", 'String'>
    readonly steamIdHex: FieldRef<"SteamUser", 'String'>
    readonly countryCode: FieldRef<"SteamUser", 'String'>
    readonly lastUpdateSteamInformation: FieldRef<"SteamUser", 'DateTime'>
    readonly viewers: FieldRef<"SteamUser", 'Int'>
    readonly userId: FieldRef<"SteamUser", 'String'>
    readonly sharedCode: FieldRef<"SteamUser", 'String'>
    readonly gameAuthenticationCode: FieldRef<"SteamUser", 'String'>
    readonly createdAt: FieldRef<"SteamUser", 'DateTime'>
    readonly updatedAt: FieldRef<"SteamUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SteamUser findUnique
   */
  export type SteamUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * Filter, which SteamUser to fetch.
     */
    where: SteamUserWhereUniqueInput
  }

  /**
   * SteamUser findUniqueOrThrow
   */
  export type SteamUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * Filter, which SteamUser to fetch.
     */
    where: SteamUserWhereUniqueInput
  }

  /**
   * SteamUser findFirst
   */
  export type SteamUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * Filter, which SteamUser to fetch.
     */
    where?: SteamUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUsers to fetch.
     */
    orderBy?: SteamUserOrderByWithRelationInput | SteamUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SteamUsers.
     */
    cursor?: SteamUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SteamUsers.
     */
    distinct?: SteamUserScalarFieldEnum | SteamUserScalarFieldEnum[]
  }

  /**
   * SteamUser findFirstOrThrow
   */
  export type SteamUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * Filter, which SteamUser to fetch.
     */
    where?: SteamUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUsers to fetch.
     */
    orderBy?: SteamUserOrderByWithRelationInput | SteamUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SteamUsers.
     */
    cursor?: SteamUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SteamUsers.
     */
    distinct?: SteamUserScalarFieldEnum | SteamUserScalarFieldEnum[]
  }

  /**
   * SteamUser findMany
   */
  export type SteamUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * Filter, which SteamUsers to fetch.
     */
    where?: SteamUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUsers to fetch.
     */
    orderBy?: SteamUserOrderByWithRelationInput | SteamUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SteamUsers.
     */
    cursor?: SteamUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUsers.
     */
    skip?: number
    distinct?: SteamUserScalarFieldEnum | SteamUserScalarFieldEnum[]
  }

  /**
   * SteamUser create
   */
  export type SteamUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * The data needed to create a SteamUser.
     */
    data: XOR<SteamUserCreateInput, SteamUserUncheckedCreateInput>
  }

  /**
   * SteamUser createMany
   */
  export type SteamUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SteamUsers.
     */
    data: SteamUserCreateManyInput | SteamUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SteamUser createManyAndReturn
   */
  export type SteamUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * The data used to create many SteamUsers.
     */
    data: SteamUserCreateManyInput | SteamUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SteamUser update
   */
  export type SteamUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * The data needed to update a SteamUser.
     */
    data: XOR<SteamUserUpdateInput, SteamUserUncheckedUpdateInput>
    /**
     * Choose, which SteamUser to update.
     */
    where: SteamUserWhereUniqueInput
  }

  /**
   * SteamUser updateMany
   */
  export type SteamUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SteamUsers.
     */
    data: XOR<SteamUserUpdateManyMutationInput, SteamUserUncheckedUpdateManyInput>
    /**
     * Filter which SteamUsers to update
     */
    where?: SteamUserWhereInput
    /**
     * Limit how many SteamUsers to update.
     */
    limit?: number
  }

  /**
   * SteamUser updateManyAndReturn
   */
  export type SteamUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * The data used to update SteamUsers.
     */
    data: XOR<SteamUserUpdateManyMutationInput, SteamUserUncheckedUpdateManyInput>
    /**
     * Filter which SteamUsers to update
     */
    where?: SteamUserWhereInput
    /**
     * Limit how many SteamUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SteamUser upsert
   */
  export type SteamUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * The filter to search for the SteamUser to update in case it exists.
     */
    where: SteamUserWhereUniqueInput
    /**
     * In case the SteamUser found by the `where` argument doesn't exist, create a new SteamUser with this data.
     */
    create: XOR<SteamUserCreateInput, SteamUserUncheckedCreateInput>
    /**
     * In case the SteamUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SteamUserUpdateInput, SteamUserUncheckedUpdateInput>
  }

  /**
   * SteamUser delete
   */
  export type SteamUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    /**
     * Filter which SteamUser to delete.
     */
    where: SteamUserWhereUniqueInput
  }

  /**
   * SteamUser deleteMany
   */
  export type SteamUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SteamUsers to delete
     */
    where?: SteamUserWhereInput
    /**
     * Limit how many SteamUsers to delete.
     */
    limit?: number
  }

  /**
   * SteamUser.user
   */
  export type SteamUser$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SteamUser.steamUserBans
   */
  export type SteamUser$steamUserBansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    where?: SteamUserBansWhereInput
  }

  /**
   * SteamUser.commentsAsRecipient
   */
  export type SteamUser$commentsAsRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * SteamUser.reportsAsRecipient
   */
  export type SteamUser$reportsAsRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    where?: ReportUserWhereInput
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    cursor?: ReportUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * SteamUser.matches
   */
  export type SteamUser$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * SteamUser.playerStatisticsInMatch
   */
  export type SteamUser$playerStatisticsInMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    where?: PlayerStatisticsInMatchWhereInput
    orderBy?: PlayerStatisticsInMatchOrderByWithRelationInput | PlayerStatisticsInMatchOrderByWithRelationInput[]
    cursor?: PlayerStatisticsInMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerStatisticsInMatchScalarFieldEnum | PlayerStatisticsInMatchScalarFieldEnum[]
  }

  /**
   * SteamUser.generalPlayerStatistics
   */
  export type SteamUser$generalPlayerStatisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    where?: GeneralPlayerStatisticsWhereInput
  }

  /**
   * SteamUser without action
   */
  export type SteamUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchMinAggregateOutputType = {
    id: string | null
    type: $Enums.MatchType | null
    matchId: string | null
    score: string | null
    date: Date | null
    sharedCode: string | null
    replay: string | null
    result: boolean | null
    duration: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: string | null
    type: $Enums.MatchType | null
    matchId: string | null
    score: string | null
    date: Date | null
    sharedCode: string | null
    replay: string | null
    result: boolean | null
    duration: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    type: number
    matchId: number
    score: number
    date: number
    sharedCode: number
    replay: number
    result: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatchMinAggregateInputType = {
    id?: true
    type?: true
    matchId?: true
    score?: true
    date?: true
    sharedCode?: true
    replay?: true
    result?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    type?: true
    matchId?: true
    score?: true
    date?: true
    sharedCode?: true
    replay?: true
    result?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    type?: true
    matchId?: true
    score?: true
    date?: true
    sharedCode?: true
    replay?: true
    result?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date
    sharedCode: string
    replay: string
    result: boolean
    duration: string
    createdAt: Date
    updatedAt: Date
    _count: MatchCountAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    matchId?: boolean
    score?: boolean
    date?: boolean
    sharedCode?: boolean
    replay?: boolean
    result?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | Match$participantsArgs<ExtArgs>
    playersStatistic?: boolean | Match$playersStatisticArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    matchId?: boolean
    score?: boolean
    date?: boolean
    sharedCode?: boolean
    replay?: boolean
    result?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["match"]>

  export type MatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    matchId?: boolean
    score?: boolean
    date?: boolean
    sharedCode?: boolean
    replay?: boolean
    result?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    type?: boolean
    matchId?: boolean
    score?: boolean
    date?: boolean
    sharedCode?: boolean
    replay?: boolean
    result?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "matchId" | "score" | "date" | "sharedCode" | "replay" | "result" | "duration" | "createdAt" | "updatedAt", ExtArgs["result"]["match"]>
  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Match$participantsArgs<ExtArgs>
    playersStatistic?: boolean | Match$playersStatisticArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      participants: Prisma.$SteamUserPayload<ExtArgs>[]
      playersStatistic: Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.MatchType
      matchId: string
      score: string
      date: Date
      sharedCode: string
      replay: string
      result: boolean
      duration: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches and returns the data updated in the database.
     * @param {MatchUpdateManyAndReturnArgs} args - Arguments to update many Matches.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Match$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Match$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playersStatistic<T extends Match$playersStatisticArgs<ExtArgs> = {}>(args?: Subset<T, Match$playersStatisticArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'String'>
    readonly type: FieldRef<"Match", 'MatchType'>
    readonly matchId: FieldRef<"Match", 'String'>
    readonly score: FieldRef<"Match", 'String'>
    readonly date: FieldRef<"Match", 'DateTime'>
    readonly sharedCode: FieldRef<"Match", 'String'>
    readonly replay: FieldRef<"Match", 'String'>
    readonly result: FieldRef<"Match", 'Boolean'>
    readonly duration: FieldRef<"Match", 'String'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
    readonly updatedAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match updateManyAndReturn
   */
  export type MatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to delete.
     */
    limit?: number
  }

  /**
   * Match.participants
   */
  export type Match$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUser
     */
    select?: SteamUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUser
     */
    omit?: SteamUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserInclude<ExtArgs> | null
    where?: SteamUserWhereInput
    orderBy?: SteamUserOrderByWithRelationInput | SteamUserOrderByWithRelationInput[]
    cursor?: SteamUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SteamUserScalarFieldEnum | SteamUserScalarFieldEnum[]
  }

  /**
   * Match.playersStatistic
   */
  export type Match$playersStatisticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    where?: PlayerStatisticsInMatchWhereInput
    orderBy?: PlayerStatisticsInMatchOrderByWithRelationInput | PlayerStatisticsInMatchOrderByWithRelationInput[]
    cursor?: PlayerStatisticsInMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerStatisticsInMatchScalarFieldEnum | PlayerStatisticsInMatchScalarFieldEnum[]
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model GeneralPlayerStatistics
   */

  export type AggregateGeneralPlayerStatistics = {
    _count: GeneralPlayerStatisticsCountAggregateOutputType | null
    _min: GeneralPlayerStatisticsMinAggregateOutputType | null
    _max: GeneralPlayerStatisticsMaxAggregateOutputType | null
  }

  export type GeneralPlayerStatisticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type GeneralPlayerStatisticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
  }

  export type GeneralPlayerStatisticsCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type GeneralPlayerStatisticsMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type GeneralPlayerStatisticsMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type GeneralPlayerStatisticsCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type GeneralPlayerStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneralPlayerStatistics to aggregate.
     */
    where?: GeneralPlayerStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneralPlayerStatistics to fetch.
     */
    orderBy?: GeneralPlayerStatisticsOrderByWithRelationInput | GeneralPlayerStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneralPlayerStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneralPlayerStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneralPlayerStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneralPlayerStatistics
    **/
    _count?: true | GeneralPlayerStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneralPlayerStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneralPlayerStatisticsMaxAggregateInputType
  }

  export type GetGeneralPlayerStatisticsAggregateType<T extends GeneralPlayerStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneralPlayerStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneralPlayerStatistics[P]>
      : GetScalarType<T[P], AggregateGeneralPlayerStatistics[P]>
  }




  export type GeneralPlayerStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneralPlayerStatisticsWhereInput
    orderBy?: GeneralPlayerStatisticsOrderByWithAggregationInput | GeneralPlayerStatisticsOrderByWithAggregationInput[]
    by: GeneralPlayerStatisticsScalarFieldEnum[] | GeneralPlayerStatisticsScalarFieldEnum
    having?: GeneralPlayerStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneralPlayerStatisticsCountAggregateInputType | true
    _min?: GeneralPlayerStatisticsMinAggregateInputType
    _max?: GeneralPlayerStatisticsMaxAggregateInputType
  }

  export type GeneralPlayerStatisticsGroupByOutputType = {
    id: string
    userId: string
    _count: GeneralPlayerStatisticsCountAggregateOutputType | null
    _min: GeneralPlayerStatisticsMinAggregateOutputType | null
    _max: GeneralPlayerStatisticsMaxAggregateOutputType | null
  }

  type GetGeneralPlayerStatisticsGroupByPayload<T extends GeneralPlayerStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneralPlayerStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneralPlayerStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneralPlayerStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], GeneralPlayerStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type GeneralPlayerStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
    MapRanks?: boolean | GeneralPlayerStatistics$MapRanksArgs<ExtArgs>
    WeaponStats?: boolean | GeneralPlayerStatistics$WeaponStatsArgs<ExtArgs>
    _count?: boolean | GeneralPlayerStatisticsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generalPlayerStatistics"]>

  export type GeneralPlayerStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generalPlayerStatistics"]>

  export type GeneralPlayerStatisticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generalPlayerStatistics"]>

  export type GeneralPlayerStatisticsSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type GeneralPlayerStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId", ExtArgs["result"]["generalPlayerStatistics"]>
  export type GeneralPlayerStatisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
    MapRanks?: boolean | GeneralPlayerStatistics$MapRanksArgs<ExtArgs>
    WeaponStats?: boolean | GeneralPlayerStatistics$WeaponStatsArgs<ExtArgs>
    _count?: boolean | GeneralPlayerStatisticsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeneralPlayerStatisticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }
  export type GeneralPlayerStatisticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }

  export type $GeneralPlayerStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneralPlayerStatistics"
    objects: {
      steam: Prisma.$SteamUserPayload<ExtArgs>
      MapRanks: Prisma.$MapRanksPayload<ExtArgs>[]
      WeaponStats: Prisma.$WeaponStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
    }, ExtArgs["result"]["generalPlayerStatistics"]>
    composites: {}
  }

  type GeneralPlayerStatisticsGetPayload<S extends boolean | null | undefined | GeneralPlayerStatisticsDefaultArgs> = $Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload, S>

  type GeneralPlayerStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneralPlayerStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneralPlayerStatisticsCountAggregateInputType | true
    }

  export interface GeneralPlayerStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneralPlayerStatistics'], meta: { name: 'GeneralPlayerStatistics' } }
    /**
     * Find zero or one GeneralPlayerStatistics that matches the filter.
     * @param {GeneralPlayerStatisticsFindUniqueArgs} args - Arguments to find a GeneralPlayerStatistics
     * @example
     * // Get one GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneralPlayerStatisticsFindUniqueArgs>(args: SelectSubset<T, GeneralPlayerStatisticsFindUniqueArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeneralPlayerStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneralPlayerStatisticsFindUniqueOrThrowArgs} args - Arguments to find a GeneralPlayerStatistics
     * @example
     * // Get one GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneralPlayerStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneralPlayerStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneralPlayerStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralPlayerStatisticsFindFirstArgs} args - Arguments to find a GeneralPlayerStatistics
     * @example
     * // Get one GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneralPlayerStatisticsFindFirstArgs>(args?: SelectSubset<T, GeneralPlayerStatisticsFindFirstArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneralPlayerStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralPlayerStatisticsFindFirstOrThrowArgs} args - Arguments to find a GeneralPlayerStatistics
     * @example
     * // Get one GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneralPlayerStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneralPlayerStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeneralPlayerStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralPlayerStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.findMany()
     * 
     * // Get first 10 GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generalPlayerStatisticsWithIdOnly = await prisma.generalPlayerStatistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneralPlayerStatisticsFindManyArgs>(args?: SelectSubset<T, GeneralPlayerStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeneralPlayerStatistics.
     * @param {GeneralPlayerStatisticsCreateArgs} args - Arguments to create a GeneralPlayerStatistics.
     * @example
     * // Create one GeneralPlayerStatistics
     * const GeneralPlayerStatistics = await prisma.generalPlayerStatistics.create({
     *   data: {
     *     // ... data to create a GeneralPlayerStatistics
     *   }
     * })
     * 
     */
    create<T extends GeneralPlayerStatisticsCreateArgs>(args: SelectSubset<T, GeneralPlayerStatisticsCreateArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeneralPlayerStatistics.
     * @param {GeneralPlayerStatisticsCreateManyArgs} args - Arguments to create many GeneralPlayerStatistics.
     * @example
     * // Create many GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneralPlayerStatisticsCreateManyArgs>(args?: SelectSubset<T, GeneralPlayerStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneralPlayerStatistics and returns the data saved in the database.
     * @param {GeneralPlayerStatisticsCreateManyAndReturnArgs} args - Arguments to create many GeneralPlayerStatistics.
     * @example
     * // Create many GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneralPlayerStatistics and only return the `id`
     * const generalPlayerStatisticsWithIdOnly = await prisma.generalPlayerStatistics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneralPlayerStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneralPlayerStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeneralPlayerStatistics.
     * @param {GeneralPlayerStatisticsDeleteArgs} args - Arguments to delete one GeneralPlayerStatistics.
     * @example
     * // Delete one GeneralPlayerStatistics
     * const GeneralPlayerStatistics = await prisma.generalPlayerStatistics.delete({
     *   where: {
     *     // ... filter to delete one GeneralPlayerStatistics
     *   }
     * })
     * 
     */
    delete<T extends GeneralPlayerStatisticsDeleteArgs>(args: SelectSubset<T, GeneralPlayerStatisticsDeleteArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeneralPlayerStatistics.
     * @param {GeneralPlayerStatisticsUpdateArgs} args - Arguments to update one GeneralPlayerStatistics.
     * @example
     * // Update one GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneralPlayerStatisticsUpdateArgs>(args: SelectSubset<T, GeneralPlayerStatisticsUpdateArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeneralPlayerStatistics.
     * @param {GeneralPlayerStatisticsDeleteManyArgs} args - Arguments to filter GeneralPlayerStatistics to delete.
     * @example
     * // Delete a few GeneralPlayerStatistics
     * const { count } = await prisma.generalPlayerStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneralPlayerStatisticsDeleteManyArgs>(args?: SelectSubset<T, GeneralPlayerStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneralPlayerStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralPlayerStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneralPlayerStatisticsUpdateManyArgs>(args: SelectSubset<T, GeneralPlayerStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneralPlayerStatistics and returns the data updated in the database.
     * @param {GeneralPlayerStatisticsUpdateManyAndReturnArgs} args - Arguments to update many GeneralPlayerStatistics.
     * @example
     * // Update many GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeneralPlayerStatistics and only return the `id`
     * const generalPlayerStatisticsWithIdOnly = await prisma.generalPlayerStatistics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeneralPlayerStatisticsUpdateManyAndReturnArgs>(args: SelectSubset<T, GeneralPlayerStatisticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeneralPlayerStatistics.
     * @param {GeneralPlayerStatisticsUpsertArgs} args - Arguments to update or create a GeneralPlayerStatistics.
     * @example
     * // Update or create a GeneralPlayerStatistics
     * const generalPlayerStatistics = await prisma.generalPlayerStatistics.upsert({
     *   create: {
     *     // ... data to create a GeneralPlayerStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneralPlayerStatistics we want to update
     *   }
     * })
     */
    upsert<T extends GeneralPlayerStatisticsUpsertArgs>(args: SelectSubset<T, GeneralPlayerStatisticsUpsertArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeneralPlayerStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralPlayerStatisticsCountArgs} args - Arguments to filter GeneralPlayerStatistics to count.
     * @example
     * // Count the number of GeneralPlayerStatistics
     * const count = await prisma.generalPlayerStatistics.count({
     *   where: {
     *     // ... the filter for the GeneralPlayerStatistics we want to count
     *   }
     * })
    **/
    count<T extends GeneralPlayerStatisticsCountArgs>(
      args?: Subset<T, GeneralPlayerStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneralPlayerStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneralPlayerStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralPlayerStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneralPlayerStatisticsAggregateArgs>(args: Subset<T, GeneralPlayerStatisticsAggregateArgs>): Prisma.PrismaPromise<GetGeneralPlayerStatisticsAggregateType<T>>

    /**
     * Group by GeneralPlayerStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneralPlayerStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneralPlayerStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneralPlayerStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: GeneralPlayerStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneralPlayerStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneralPlayerStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneralPlayerStatistics model
   */
  readonly fields: GeneralPlayerStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneralPlayerStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneralPlayerStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steam<T extends SteamUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SteamUserDefaultArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MapRanks<T extends GeneralPlayerStatistics$MapRanksArgs<ExtArgs> = {}>(args?: Subset<T, GeneralPlayerStatistics$MapRanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WeaponStats<T extends GeneralPlayerStatistics$WeaponStatsArgs<ExtArgs> = {}>(args?: Subset<T, GeneralPlayerStatistics$WeaponStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneralPlayerStatistics model
   */
  interface GeneralPlayerStatisticsFieldRefs {
    readonly id: FieldRef<"GeneralPlayerStatistics", 'String'>
    readonly userId: FieldRef<"GeneralPlayerStatistics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GeneralPlayerStatistics findUnique
   */
  export type GeneralPlayerStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GeneralPlayerStatistics to fetch.
     */
    where: GeneralPlayerStatisticsWhereUniqueInput
  }

  /**
   * GeneralPlayerStatistics findUniqueOrThrow
   */
  export type GeneralPlayerStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GeneralPlayerStatistics to fetch.
     */
    where: GeneralPlayerStatisticsWhereUniqueInput
  }

  /**
   * GeneralPlayerStatistics findFirst
   */
  export type GeneralPlayerStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GeneralPlayerStatistics to fetch.
     */
    where?: GeneralPlayerStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneralPlayerStatistics to fetch.
     */
    orderBy?: GeneralPlayerStatisticsOrderByWithRelationInput | GeneralPlayerStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneralPlayerStatistics.
     */
    cursor?: GeneralPlayerStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneralPlayerStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneralPlayerStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneralPlayerStatistics.
     */
    distinct?: GeneralPlayerStatisticsScalarFieldEnum | GeneralPlayerStatisticsScalarFieldEnum[]
  }

  /**
   * GeneralPlayerStatistics findFirstOrThrow
   */
  export type GeneralPlayerStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GeneralPlayerStatistics to fetch.
     */
    where?: GeneralPlayerStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneralPlayerStatistics to fetch.
     */
    orderBy?: GeneralPlayerStatisticsOrderByWithRelationInput | GeneralPlayerStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneralPlayerStatistics.
     */
    cursor?: GeneralPlayerStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneralPlayerStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneralPlayerStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneralPlayerStatistics.
     */
    distinct?: GeneralPlayerStatisticsScalarFieldEnum | GeneralPlayerStatisticsScalarFieldEnum[]
  }

  /**
   * GeneralPlayerStatistics findMany
   */
  export type GeneralPlayerStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which GeneralPlayerStatistics to fetch.
     */
    where?: GeneralPlayerStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneralPlayerStatistics to fetch.
     */
    orderBy?: GeneralPlayerStatisticsOrderByWithRelationInput | GeneralPlayerStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneralPlayerStatistics.
     */
    cursor?: GeneralPlayerStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneralPlayerStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneralPlayerStatistics.
     */
    skip?: number
    distinct?: GeneralPlayerStatisticsScalarFieldEnum | GeneralPlayerStatisticsScalarFieldEnum[]
  }

  /**
   * GeneralPlayerStatistics create
   */
  export type GeneralPlayerStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneralPlayerStatistics.
     */
    data: XOR<GeneralPlayerStatisticsCreateInput, GeneralPlayerStatisticsUncheckedCreateInput>
  }

  /**
   * GeneralPlayerStatistics createMany
   */
  export type GeneralPlayerStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneralPlayerStatistics.
     */
    data: GeneralPlayerStatisticsCreateManyInput | GeneralPlayerStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneralPlayerStatistics createManyAndReturn
   */
  export type GeneralPlayerStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * The data used to create many GeneralPlayerStatistics.
     */
    data: GeneralPlayerStatisticsCreateManyInput | GeneralPlayerStatisticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneralPlayerStatistics update
   */
  export type GeneralPlayerStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneralPlayerStatistics.
     */
    data: XOR<GeneralPlayerStatisticsUpdateInput, GeneralPlayerStatisticsUncheckedUpdateInput>
    /**
     * Choose, which GeneralPlayerStatistics to update.
     */
    where: GeneralPlayerStatisticsWhereUniqueInput
  }

  /**
   * GeneralPlayerStatistics updateMany
   */
  export type GeneralPlayerStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneralPlayerStatistics.
     */
    data: XOR<GeneralPlayerStatisticsUpdateManyMutationInput, GeneralPlayerStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which GeneralPlayerStatistics to update
     */
    where?: GeneralPlayerStatisticsWhereInput
    /**
     * Limit how many GeneralPlayerStatistics to update.
     */
    limit?: number
  }

  /**
   * GeneralPlayerStatistics updateManyAndReturn
   */
  export type GeneralPlayerStatisticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * The data used to update GeneralPlayerStatistics.
     */
    data: XOR<GeneralPlayerStatisticsUpdateManyMutationInput, GeneralPlayerStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which GeneralPlayerStatistics to update
     */
    where?: GeneralPlayerStatisticsWhereInput
    /**
     * Limit how many GeneralPlayerStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneralPlayerStatistics upsert
   */
  export type GeneralPlayerStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneralPlayerStatistics to update in case it exists.
     */
    where: GeneralPlayerStatisticsWhereUniqueInput
    /**
     * In case the GeneralPlayerStatistics found by the `where` argument doesn't exist, create a new GeneralPlayerStatistics with this data.
     */
    create: XOR<GeneralPlayerStatisticsCreateInput, GeneralPlayerStatisticsUncheckedCreateInput>
    /**
     * In case the GeneralPlayerStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneralPlayerStatisticsUpdateInput, GeneralPlayerStatisticsUncheckedUpdateInput>
  }

  /**
   * GeneralPlayerStatistics delete
   */
  export type GeneralPlayerStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
    /**
     * Filter which GeneralPlayerStatistics to delete.
     */
    where: GeneralPlayerStatisticsWhereUniqueInput
  }

  /**
   * GeneralPlayerStatistics deleteMany
   */
  export type GeneralPlayerStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneralPlayerStatistics to delete
     */
    where?: GeneralPlayerStatisticsWhereInput
    /**
     * Limit how many GeneralPlayerStatistics to delete.
     */
    limit?: number
  }

  /**
   * GeneralPlayerStatistics.MapRanks
   */
  export type GeneralPlayerStatistics$MapRanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    where?: MapRanksWhereInput
    orderBy?: MapRanksOrderByWithRelationInput | MapRanksOrderByWithRelationInput[]
    cursor?: MapRanksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapRanksScalarFieldEnum | MapRanksScalarFieldEnum[]
  }

  /**
   * GeneralPlayerStatistics.WeaponStats
   */
  export type GeneralPlayerStatistics$WeaponStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    where?: WeaponStatsWhereInput
    orderBy?: WeaponStatsOrderByWithRelationInput | WeaponStatsOrderByWithRelationInput[]
    cursor?: WeaponStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponStatsScalarFieldEnum | WeaponStatsScalarFieldEnum[]
  }

  /**
   * GeneralPlayerStatistics without action
   */
  export type GeneralPlayerStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneralPlayerStatistics
     */
    select?: GeneralPlayerStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneralPlayerStatistics
     */
    omit?: GeneralPlayerStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneralPlayerStatisticsInclude<ExtArgs> | null
  }


  /**
   * Model MapRanks
   */

  export type AggregateMapRanks = {
    _count: MapRanksCountAggregateOutputType | null
    _min: MapRanksMinAggregateOutputType | null
    _max: MapRanksMaxAggregateOutputType | null
  }

  export type MapRanksMinAggregateOutputType = {
    id: string | null
    name: string | null
    playerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapRanksMaxAggregateOutputType = {
    id: string | null
    name: string | null
    playerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapRanksCountAggregateOutputType = {
    id: number
    name: number
    playerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MapRanksMinAggregateInputType = {
    id?: true
    name?: true
    playerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapRanksMaxAggregateInputType = {
    id?: true
    name?: true
    playerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapRanksCountAggregateInputType = {
    id?: true
    name?: true
    playerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MapRanksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapRanks to aggregate.
     */
    where?: MapRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapRanks to fetch.
     */
    orderBy?: MapRanksOrderByWithRelationInput | MapRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapRanks
    **/
    _count?: true | MapRanksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapRanksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapRanksMaxAggregateInputType
  }

  export type GetMapRanksAggregateType<T extends MapRanksAggregateArgs> = {
        [P in keyof T & keyof AggregateMapRanks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapRanks[P]>
      : GetScalarType<T[P], AggregateMapRanks[P]>
  }




  export type MapRanksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapRanksWhereInput
    orderBy?: MapRanksOrderByWithAggregationInput | MapRanksOrderByWithAggregationInput[]
    by: MapRanksScalarFieldEnum[] | MapRanksScalarFieldEnum
    having?: MapRanksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapRanksCountAggregateInputType | true
    _min?: MapRanksMinAggregateInputType
    _max?: MapRanksMaxAggregateInputType
  }

  export type MapRanksGroupByOutputType = {
    id: string
    name: string
    playerId: string
    createdAt: Date
    updatedAt: Date
    _count: MapRanksCountAggregateOutputType | null
    _min: MapRanksMinAggregateOutputType | null
    _max: MapRanksMaxAggregateOutputType | null
  }

  type GetMapRanksGroupByPayload<T extends MapRanksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapRanksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapRanksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapRanksGroupByOutputType[P]>
            : GetScalarType<T[P], MapRanksGroupByOutputType[P]>
        }
      >
    >


  export type MapRanksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    playerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mapStat?: boolean | MapRanks$mapStatArgs<ExtArgs>
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
    _count?: boolean | MapRanksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapRanks"]>

  export type MapRanksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    playerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapRanks"]>

  export type MapRanksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    playerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapRanks"]>

  export type MapRanksSelectScalar = {
    id?: boolean
    name?: boolean
    playerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MapRanksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "playerId" | "createdAt" | "updatedAt", ExtArgs["result"]["mapRanks"]>
  export type MapRanksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mapStat?: boolean | MapRanks$mapStatArgs<ExtArgs>
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
    _count?: boolean | MapRanksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MapRanksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }
  export type MapRanksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }

  export type $MapRanksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapRanks"
    objects: {
      mapStat: Prisma.$MapStatsPayload<ExtArgs>[]
      generalPlayerStatistics: Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      playerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mapRanks"]>
    composites: {}
  }

  type MapRanksGetPayload<S extends boolean | null | undefined | MapRanksDefaultArgs> = $Result.GetResult<Prisma.$MapRanksPayload, S>

  type MapRanksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapRanksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapRanksCountAggregateInputType | true
    }

  export interface MapRanksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapRanks'], meta: { name: 'MapRanks' } }
    /**
     * Find zero or one MapRanks that matches the filter.
     * @param {MapRanksFindUniqueArgs} args - Arguments to find a MapRanks
     * @example
     * // Get one MapRanks
     * const mapRanks = await prisma.mapRanks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapRanksFindUniqueArgs>(args: SelectSubset<T, MapRanksFindUniqueArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MapRanks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapRanksFindUniqueOrThrowArgs} args - Arguments to find a MapRanks
     * @example
     * // Get one MapRanks
     * const mapRanks = await prisma.mapRanks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapRanksFindUniqueOrThrowArgs>(args: SelectSubset<T, MapRanksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRanksFindFirstArgs} args - Arguments to find a MapRanks
     * @example
     * // Get one MapRanks
     * const mapRanks = await prisma.mapRanks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapRanksFindFirstArgs>(args?: SelectSubset<T, MapRanksFindFirstArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapRanks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRanksFindFirstOrThrowArgs} args - Arguments to find a MapRanks
     * @example
     * // Get one MapRanks
     * const mapRanks = await prisma.mapRanks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapRanksFindFirstOrThrowArgs>(args?: SelectSubset<T, MapRanksFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MapRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRanksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapRanks
     * const mapRanks = await prisma.mapRanks.findMany()
     * 
     * // Get first 10 MapRanks
     * const mapRanks = await prisma.mapRanks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapRanksWithIdOnly = await prisma.mapRanks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapRanksFindManyArgs>(args?: SelectSubset<T, MapRanksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MapRanks.
     * @param {MapRanksCreateArgs} args - Arguments to create a MapRanks.
     * @example
     * // Create one MapRanks
     * const MapRanks = await prisma.mapRanks.create({
     *   data: {
     *     // ... data to create a MapRanks
     *   }
     * })
     * 
     */
    create<T extends MapRanksCreateArgs>(args: SelectSubset<T, MapRanksCreateArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MapRanks.
     * @param {MapRanksCreateManyArgs} args - Arguments to create many MapRanks.
     * @example
     * // Create many MapRanks
     * const mapRanks = await prisma.mapRanks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapRanksCreateManyArgs>(args?: SelectSubset<T, MapRanksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapRanks and returns the data saved in the database.
     * @param {MapRanksCreateManyAndReturnArgs} args - Arguments to create many MapRanks.
     * @example
     * // Create many MapRanks
     * const mapRanks = await prisma.mapRanks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapRanks and only return the `id`
     * const mapRanksWithIdOnly = await prisma.mapRanks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapRanksCreateManyAndReturnArgs>(args?: SelectSubset<T, MapRanksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MapRanks.
     * @param {MapRanksDeleteArgs} args - Arguments to delete one MapRanks.
     * @example
     * // Delete one MapRanks
     * const MapRanks = await prisma.mapRanks.delete({
     *   where: {
     *     // ... filter to delete one MapRanks
     *   }
     * })
     * 
     */
    delete<T extends MapRanksDeleteArgs>(args: SelectSubset<T, MapRanksDeleteArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MapRanks.
     * @param {MapRanksUpdateArgs} args - Arguments to update one MapRanks.
     * @example
     * // Update one MapRanks
     * const mapRanks = await prisma.mapRanks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapRanksUpdateArgs>(args: SelectSubset<T, MapRanksUpdateArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MapRanks.
     * @param {MapRanksDeleteManyArgs} args - Arguments to filter MapRanks to delete.
     * @example
     * // Delete a few MapRanks
     * const { count } = await prisma.mapRanks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapRanksDeleteManyArgs>(args?: SelectSubset<T, MapRanksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRanksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapRanks
     * const mapRanks = await prisma.mapRanks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapRanksUpdateManyArgs>(args: SelectSubset<T, MapRanksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapRanks and returns the data updated in the database.
     * @param {MapRanksUpdateManyAndReturnArgs} args - Arguments to update many MapRanks.
     * @example
     * // Update many MapRanks
     * const mapRanks = await prisma.mapRanks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapRanks and only return the `id`
     * const mapRanksWithIdOnly = await prisma.mapRanks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapRanksUpdateManyAndReturnArgs>(args: SelectSubset<T, MapRanksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MapRanks.
     * @param {MapRanksUpsertArgs} args - Arguments to update or create a MapRanks.
     * @example
     * // Update or create a MapRanks
     * const mapRanks = await prisma.mapRanks.upsert({
     *   create: {
     *     // ... data to create a MapRanks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapRanks we want to update
     *   }
     * })
     */
    upsert<T extends MapRanksUpsertArgs>(args: SelectSubset<T, MapRanksUpsertArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MapRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRanksCountArgs} args - Arguments to filter MapRanks to count.
     * @example
     * // Count the number of MapRanks
     * const count = await prisma.mapRanks.count({
     *   where: {
     *     // ... the filter for the MapRanks we want to count
     *   }
     * })
    **/
    count<T extends MapRanksCountArgs>(
      args?: Subset<T, MapRanksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapRanksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRanksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapRanksAggregateArgs>(args: Subset<T, MapRanksAggregateArgs>): Prisma.PrismaPromise<GetMapRanksAggregateType<T>>

    /**
     * Group by MapRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapRanksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapRanksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapRanksGroupByArgs['orderBy'] }
        : { orderBy?: MapRanksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapRanksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapRanksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapRanks model
   */
  readonly fields: MapRanksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapRanks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapRanksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mapStat<T extends MapRanks$mapStatArgs<ExtArgs> = {}>(args?: Subset<T, MapRanks$mapStatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generalPlayerStatistics<T extends GeneralPlayerStatisticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GeneralPlayerStatisticsDefaultArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapRanks model
   */
  interface MapRanksFieldRefs {
    readonly id: FieldRef<"MapRanks", 'String'>
    readonly name: FieldRef<"MapRanks", 'String'>
    readonly playerId: FieldRef<"MapRanks", 'String'>
    readonly createdAt: FieldRef<"MapRanks", 'DateTime'>
    readonly updatedAt: FieldRef<"MapRanks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MapRanks findUnique
   */
  export type MapRanksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * Filter, which MapRanks to fetch.
     */
    where: MapRanksWhereUniqueInput
  }

  /**
   * MapRanks findUniqueOrThrow
   */
  export type MapRanksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * Filter, which MapRanks to fetch.
     */
    where: MapRanksWhereUniqueInput
  }

  /**
   * MapRanks findFirst
   */
  export type MapRanksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * Filter, which MapRanks to fetch.
     */
    where?: MapRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapRanks to fetch.
     */
    orderBy?: MapRanksOrderByWithRelationInput | MapRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapRanks.
     */
    cursor?: MapRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapRanks.
     */
    distinct?: MapRanksScalarFieldEnum | MapRanksScalarFieldEnum[]
  }

  /**
   * MapRanks findFirstOrThrow
   */
  export type MapRanksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * Filter, which MapRanks to fetch.
     */
    where?: MapRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapRanks to fetch.
     */
    orderBy?: MapRanksOrderByWithRelationInput | MapRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapRanks.
     */
    cursor?: MapRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapRanks.
     */
    distinct?: MapRanksScalarFieldEnum | MapRanksScalarFieldEnum[]
  }

  /**
   * MapRanks findMany
   */
  export type MapRanksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * Filter, which MapRanks to fetch.
     */
    where?: MapRanksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapRanks to fetch.
     */
    orderBy?: MapRanksOrderByWithRelationInput | MapRanksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapRanks.
     */
    cursor?: MapRanksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapRanks.
     */
    skip?: number
    distinct?: MapRanksScalarFieldEnum | MapRanksScalarFieldEnum[]
  }

  /**
   * MapRanks create
   */
  export type MapRanksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * The data needed to create a MapRanks.
     */
    data: XOR<MapRanksCreateInput, MapRanksUncheckedCreateInput>
  }

  /**
   * MapRanks createMany
   */
  export type MapRanksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapRanks.
     */
    data: MapRanksCreateManyInput | MapRanksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapRanks createManyAndReturn
   */
  export type MapRanksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * The data used to create many MapRanks.
     */
    data: MapRanksCreateManyInput | MapRanksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapRanks update
   */
  export type MapRanksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * The data needed to update a MapRanks.
     */
    data: XOR<MapRanksUpdateInput, MapRanksUncheckedUpdateInput>
    /**
     * Choose, which MapRanks to update.
     */
    where: MapRanksWhereUniqueInput
  }

  /**
   * MapRanks updateMany
   */
  export type MapRanksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapRanks.
     */
    data: XOR<MapRanksUpdateManyMutationInput, MapRanksUncheckedUpdateManyInput>
    /**
     * Filter which MapRanks to update
     */
    where?: MapRanksWhereInput
    /**
     * Limit how many MapRanks to update.
     */
    limit?: number
  }

  /**
   * MapRanks updateManyAndReturn
   */
  export type MapRanksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * The data used to update MapRanks.
     */
    data: XOR<MapRanksUpdateManyMutationInput, MapRanksUncheckedUpdateManyInput>
    /**
     * Filter which MapRanks to update
     */
    where?: MapRanksWhereInput
    /**
     * Limit how many MapRanks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapRanks upsert
   */
  export type MapRanksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * The filter to search for the MapRanks to update in case it exists.
     */
    where: MapRanksWhereUniqueInput
    /**
     * In case the MapRanks found by the `where` argument doesn't exist, create a new MapRanks with this data.
     */
    create: XOR<MapRanksCreateInput, MapRanksUncheckedCreateInput>
    /**
     * In case the MapRanks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapRanksUpdateInput, MapRanksUncheckedUpdateInput>
  }

  /**
   * MapRanks delete
   */
  export type MapRanksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
    /**
     * Filter which MapRanks to delete.
     */
    where: MapRanksWhereUniqueInput
  }

  /**
   * MapRanks deleteMany
   */
  export type MapRanksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapRanks to delete
     */
    where?: MapRanksWhereInput
    /**
     * Limit how many MapRanks to delete.
     */
    limit?: number
  }

  /**
   * MapRanks.mapStat
   */
  export type MapRanks$mapStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    where?: MapStatsWhereInput
    orderBy?: MapStatsOrderByWithRelationInput | MapStatsOrderByWithRelationInput[]
    cursor?: MapStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapStatsScalarFieldEnum | MapStatsScalarFieldEnum[]
  }

  /**
   * MapRanks without action
   */
  export type MapRanksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapRanks
     */
    select?: MapRanksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapRanks
     */
    omit?: MapRanksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapRanksInclude<ExtArgs> | null
  }


  /**
   * Model MapStats
   */

  export type AggregateMapStats = {
    _count: MapStatsCountAggregateOutputType | null
    _avg: MapStatsAvgAggregateOutputType | null
    _sum: MapStatsSumAggregateOutputType | null
    _min: MapStatsMinAggregateOutputType | null
    _max: MapStatsMaxAggregateOutputType | null
  }

  export type MapStatsAvgAggregateOutputType = {
    total_matches: number | null
    win_matches: number | null
    ct_total_rounds: number | null
    ct_win_rounds: number | null
    t_total_rounds: number | null
    t_win_rounds: number | null
  }

  export type MapStatsSumAggregateOutputType = {
    total_matches: number | null
    win_matches: number | null
    ct_total_rounds: number | null
    ct_win_rounds: number | null
    t_total_rounds: number | null
    t_win_rounds: number | null
  }

  export type MapStatsMinAggregateOutputType = {
    id: string | null
    total_matches: number | null
    win_matches: number | null
    ct_total_rounds: number | null
    ct_win_rounds: number | null
    t_total_rounds: number | null
    t_win_rounds: number | null
    mapId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapStatsMaxAggregateOutputType = {
    id: string | null
    total_matches: number | null
    win_matches: number | null
    ct_total_rounds: number | null
    ct_win_rounds: number | null
    t_total_rounds: number | null
    t_win_rounds: number | null
    mapId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapStatsCountAggregateOutputType = {
    id: number
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    mapId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MapStatsAvgAggregateInputType = {
    total_matches?: true
    win_matches?: true
    ct_total_rounds?: true
    ct_win_rounds?: true
    t_total_rounds?: true
    t_win_rounds?: true
  }

  export type MapStatsSumAggregateInputType = {
    total_matches?: true
    win_matches?: true
    ct_total_rounds?: true
    ct_win_rounds?: true
    t_total_rounds?: true
    t_win_rounds?: true
  }

  export type MapStatsMinAggregateInputType = {
    id?: true
    total_matches?: true
    win_matches?: true
    ct_total_rounds?: true
    ct_win_rounds?: true
    t_total_rounds?: true
    t_win_rounds?: true
    mapId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapStatsMaxAggregateInputType = {
    id?: true
    total_matches?: true
    win_matches?: true
    ct_total_rounds?: true
    ct_win_rounds?: true
    t_total_rounds?: true
    t_win_rounds?: true
    mapId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapStatsCountAggregateInputType = {
    id?: true
    total_matches?: true
    win_matches?: true
    ct_total_rounds?: true
    ct_win_rounds?: true
    t_total_rounds?: true
    t_win_rounds?: true
    mapId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MapStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapStats to aggregate.
     */
    where?: MapStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapStats to fetch.
     */
    orderBy?: MapStatsOrderByWithRelationInput | MapStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapStats
    **/
    _count?: true | MapStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapStatsMaxAggregateInputType
  }

  export type GetMapStatsAggregateType<T extends MapStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateMapStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapStats[P]>
      : GetScalarType<T[P], AggregateMapStats[P]>
  }




  export type MapStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapStatsWhereInput
    orderBy?: MapStatsOrderByWithAggregationInput | MapStatsOrderByWithAggregationInput[]
    by: MapStatsScalarFieldEnum[] | MapStatsScalarFieldEnum
    having?: MapStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapStatsCountAggregateInputType | true
    _avg?: MapStatsAvgAggregateInputType
    _sum?: MapStatsSumAggregateInputType
    _min?: MapStatsMinAggregateInputType
    _max?: MapStatsMaxAggregateInputType
  }

  export type MapStatsGroupByOutputType = {
    id: string
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    mapId: string
    createdAt: Date
    updatedAt: Date
    _count: MapStatsCountAggregateOutputType | null
    _avg: MapStatsAvgAggregateOutputType | null
    _sum: MapStatsSumAggregateOutputType | null
    _min: MapStatsMinAggregateOutputType | null
    _max: MapStatsMaxAggregateOutputType | null
  }

  type GetMapStatsGroupByPayload<T extends MapStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapStatsGroupByOutputType[P]>
            : GetScalarType<T[P], MapStatsGroupByOutputType[P]>
        }
      >
    >


  export type MapStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_matches?: boolean
    win_matches?: boolean
    ct_total_rounds?: boolean
    ct_win_rounds?: boolean
    t_total_rounds?: boolean
    t_win_rounds?: boolean
    mapId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MapRanks?: boolean | MapRanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapStats"]>

  export type MapStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_matches?: boolean
    win_matches?: boolean
    ct_total_rounds?: boolean
    ct_win_rounds?: boolean
    t_total_rounds?: boolean
    t_win_rounds?: boolean
    mapId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MapRanks?: boolean | MapRanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapStats"]>

  export type MapStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_matches?: boolean
    win_matches?: boolean
    ct_total_rounds?: boolean
    ct_win_rounds?: boolean
    t_total_rounds?: boolean
    t_win_rounds?: boolean
    mapId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MapRanks?: boolean | MapRanksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapStats"]>

  export type MapStatsSelectScalar = {
    id?: boolean
    total_matches?: boolean
    win_matches?: boolean
    ct_total_rounds?: boolean
    ct_win_rounds?: boolean
    t_total_rounds?: boolean
    t_win_rounds?: boolean
    mapId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MapStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "total_matches" | "win_matches" | "ct_total_rounds" | "ct_win_rounds" | "t_total_rounds" | "t_win_rounds" | "mapId" | "createdAt" | "updatedAt", ExtArgs["result"]["mapStats"]>
  export type MapStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MapRanks?: boolean | MapRanksDefaultArgs<ExtArgs>
  }
  export type MapStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MapRanks?: boolean | MapRanksDefaultArgs<ExtArgs>
  }
  export type MapStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MapRanks?: boolean | MapRanksDefaultArgs<ExtArgs>
  }

  export type $MapStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapStats"
    objects: {
      MapRanks: Prisma.$MapRanksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      total_matches: number
      win_matches: number
      ct_total_rounds: number
      ct_win_rounds: number
      t_total_rounds: number
      t_win_rounds: number
      mapId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mapStats"]>
    composites: {}
  }

  type MapStatsGetPayload<S extends boolean | null | undefined | MapStatsDefaultArgs> = $Result.GetResult<Prisma.$MapStatsPayload, S>

  type MapStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapStatsCountAggregateInputType | true
    }

  export interface MapStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapStats'], meta: { name: 'MapStats' } }
    /**
     * Find zero or one MapStats that matches the filter.
     * @param {MapStatsFindUniqueArgs} args - Arguments to find a MapStats
     * @example
     * // Get one MapStats
     * const mapStats = await prisma.mapStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapStatsFindUniqueArgs>(args: SelectSubset<T, MapStatsFindUniqueArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MapStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapStatsFindUniqueOrThrowArgs} args - Arguments to find a MapStats
     * @example
     * // Get one MapStats
     * const mapStats = await prisma.mapStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, MapStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapStatsFindFirstArgs} args - Arguments to find a MapStats
     * @example
     * // Get one MapStats
     * const mapStats = await prisma.mapStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapStatsFindFirstArgs>(args?: SelectSubset<T, MapStatsFindFirstArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapStatsFindFirstOrThrowArgs} args - Arguments to find a MapStats
     * @example
     * // Get one MapStats
     * const mapStats = await prisma.mapStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, MapStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MapStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapStats
     * const mapStats = await prisma.mapStats.findMany()
     * 
     * // Get first 10 MapStats
     * const mapStats = await prisma.mapStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapStatsWithIdOnly = await prisma.mapStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapStatsFindManyArgs>(args?: SelectSubset<T, MapStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MapStats.
     * @param {MapStatsCreateArgs} args - Arguments to create a MapStats.
     * @example
     * // Create one MapStats
     * const MapStats = await prisma.mapStats.create({
     *   data: {
     *     // ... data to create a MapStats
     *   }
     * })
     * 
     */
    create<T extends MapStatsCreateArgs>(args: SelectSubset<T, MapStatsCreateArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MapStats.
     * @param {MapStatsCreateManyArgs} args - Arguments to create many MapStats.
     * @example
     * // Create many MapStats
     * const mapStats = await prisma.mapStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapStatsCreateManyArgs>(args?: SelectSubset<T, MapStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapStats and returns the data saved in the database.
     * @param {MapStatsCreateManyAndReturnArgs} args - Arguments to create many MapStats.
     * @example
     * // Create many MapStats
     * const mapStats = await prisma.mapStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapStats and only return the `id`
     * const mapStatsWithIdOnly = await prisma.mapStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, MapStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MapStats.
     * @param {MapStatsDeleteArgs} args - Arguments to delete one MapStats.
     * @example
     * // Delete one MapStats
     * const MapStats = await prisma.mapStats.delete({
     *   where: {
     *     // ... filter to delete one MapStats
     *   }
     * })
     * 
     */
    delete<T extends MapStatsDeleteArgs>(args: SelectSubset<T, MapStatsDeleteArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MapStats.
     * @param {MapStatsUpdateArgs} args - Arguments to update one MapStats.
     * @example
     * // Update one MapStats
     * const mapStats = await prisma.mapStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapStatsUpdateArgs>(args: SelectSubset<T, MapStatsUpdateArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MapStats.
     * @param {MapStatsDeleteManyArgs} args - Arguments to filter MapStats to delete.
     * @example
     * // Delete a few MapStats
     * const { count } = await prisma.mapStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapStatsDeleteManyArgs>(args?: SelectSubset<T, MapStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapStats
     * const mapStats = await prisma.mapStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapStatsUpdateManyArgs>(args: SelectSubset<T, MapStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapStats and returns the data updated in the database.
     * @param {MapStatsUpdateManyAndReturnArgs} args - Arguments to update many MapStats.
     * @example
     * // Update many MapStats
     * const mapStats = await prisma.mapStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapStats and only return the `id`
     * const mapStatsWithIdOnly = await prisma.mapStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, MapStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MapStats.
     * @param {MapStatsUpsertArgs} args - Arguments to update or create a MapStats.
     * @example
     * // Update or create a MapStats
     * const mapStats = await prisma.mapStats.upsert({
     *   create: {
     *     // ... data to create a MapStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapStats we want to update
     *   }
     * })
     */
    upsert<T extends MapStatsUpsertArgs>(args: SelectSubset<T, MapStatsUpsertArgs<ExtArgs>>): Prisma__MapStatsClient<$Result.GetResult<Prisma.$MapStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MapStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapStatsCountArgs} args - Arguments to filter MapStats to count.
     * @example
     * // Count the number of MapStats
     * const count = await prisma.mapStats.count({
     *   where: {
     *     // ... the filter for the MapStats we want to count
     *   }
     * })
    **/
    count<T extends MapStatsCountArgs>(
      args?: Subset<T, MapStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapStatsAggregateArgs>(args: Subset<T, MapStatsAggregateArgs>): Prisma.PrismaPromise<GetMapStatsAggregateType<T>>

    /**
     * Group by MapStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapStatsGroupByArgs['orderBy'] }
        : { orderBy?: MapStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapStats model
   */
  readonly fields: MapStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MapRanks<T extends MapRanksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MapRanksDefaultArgs<ExtArgs>>): Prisma__MapRanksClient<$Result.GetResult<Prisma.$MapRanksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapStats model
   */
  interface MapStatsFieldRefs {
    readonly id: FieldRef<"MapStats", 'String'>
    readonly total_matches: FieldRef<"MapStats", 'Int'>
    readonly win_matches: FieldRef<"MapStats", 'Int'>
    readonly ct_total_rounds: FieldRef<"MapStats", 'Int'>
    readonly ct_win_rounds: FieldRef<"MapStats", 'Int'>
    readonly t_total_rounds: FieldRef<"MapStats", 'Int'>
    readonly t_win_rounds: FieldRef<"MapStats", 'Int'>
    readonly mapId: FieldRef<"MapStats", 'String'>
    readonly createdAt: FieldRef<"MapStats", 'DateTime'>
    readonly updatedAt: FieldRef<"MapStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MapStats findUnique
   */
  export type MapStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * Filter, which MapStats to fetch.
     */
    where: MapStatsWhereUniqueInput
  }

  /**
   * MapStats findUniqueOrThrow
   */
  export type MapStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * Filter, which MapStats to fetch.
     */
    where: MapStatsWhereUniqueInput
  }

  /**
   * MapStats findFirst
   */
  export type MapStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * Filter, which MapStats to fetch.
     */
    where?: MapStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapStats to fetch.
     */
    orderBy?: MapStatsOrderByWithRelationInput | MapStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapStats.
     */
    cursor?: MapStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapStats.
     */
    distinct?: MapStatsScalarFieldEnum | MapStatsScalarFieldEnum[]
  }

  /**
   * MapStats findFirstOrThrow
   */
  export type MapStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * Filter, which MapStats to fetch.
     */
    where?: MapStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapStats to fetch.
     */
    orderBy?: MapStatsOrderByWithRelationInput | MapStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapStats.
     */
    cursor?: MapStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapStats.
     */
    distinct?: MapStatsScalarFieldEnum | MapStatsScalarFieldEnum[]
  }

  /**
   * MapStats findMany
   */
  export type MapStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * Filter, which MapStats to fetch.
     */
    where?: MapStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapStats to fetch.
     */
    orderBy?: MapStatsOrderByWithRelationInput | MapStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapStats.
     */
    cursor?: MapStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapStats.
     */
    skip?: number
    distinct?: MapStatsScalarFieldEnum | MapStatsScalarFieldEnum[]
  }

  /**
   * MapStats create
   */
  export type MapStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a MapStats.
     */
    data: XOR<MapStatsCreateInput, MapStatsUncheckedCreateInput>
  }

  /**
   * MapStats createMany
   */
  export type MapStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapStats.
     */
    data: MapStatsCreateManyInput | MapStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapStats createManyAndReturn
   */
  export type MapStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * The data used to create many MapStats.
     */
    data: MapStatsCreateManyInput | MapStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapStats update
   */
  export type MapStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a MapStats.
     */
    data: XOR<MapStatsUpdateInput, MapStatsUncheckedUpdateInput>
    /**
     * Choose, which MapStats to update.
     */
    where: MapStatsWhereUniqueInput
  }

  /**
   * MapStats updateMany
   */
  export type MapStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapStats.
     */
    data: XOR<MapStatsUpdateManyMutationInput, MapStatsUncheckedUpdateManyInput>
    /**
     * Filter which MapStats to update
     */
    where?: MapStatsWhereInput
    /**
     * Limit how many MapStats to update.
     */
    limit?: number
  }

  /**
   * MapStats updateManyAndReturn
   */
  export type MapStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * The data used to update MapStats.
     */
    data: XOR<MapStatsUpdateManyMutationInput, MapStatsUncheckedUpdateManyInput>
    /**
     * Filter which MapStats to update
     */
    where?: MapStatsWhereInput
    /**
     * Limit how many MapStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapStats upsert
   */
  export type MapStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the MapStats to update in case it exists.
     */
    where: MapStatsWhereUniqueInput
    /**
     * In case the MapStats found by the `where` argument doesn't exist, create a new MapStats with this data.
     */
    create: XOR<MapStatsCreateInput, MapStatsUncheckedCreateInput>
    /**
     * In case the MapStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapStatsUpdateInput, MapStatsUncheckedUpdateInput>
  }

  /**
   * MapStats delete
   */
  export type MapStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
    /**
     * Filter which MapStats to delete.
     */
    where: MapStatsWhereUniqueInput
  }

  /**
   * MapStats deleteMany
   */
  export type MapStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapStats to delete
     */
    where?: MapStatsWhereInput
    /**
     * Limit how many MapStats to delete.
     */
    limit?: number
  }

  /**
   * MapStats without action
   */
  export type MapStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapStats
     */
    select?: MapStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapStats
     */
    omit?: MapStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapStatsInclude<ExtArgs> | null
  }


  /**
   * Model WeaponStats
   */

  export type AggregateWeaponStats = {
    _count: WeaponStatsCountAggregateOutputType | null
    _avg: WeaponStatsAvgAggregateOutputType | null
    _sum: WeaponStatsSumAggregateOutputType | null
    _min: WeaponStatsMinAggregateOutputType | null
    _max: WeaponStatsMaxAggregateOutputType | null
  }

  export type WeaponStatsAvgAggregateOutputType = {
    fire: number | null
  }

  export type WeaponStatsSumAggregateOutputType = {
    fire: number | null
  }

  export type WeaponStatsMinAggregateOutputType = {
    id: string | null
    name: string | null
    fire: number | null
    userId: string | null
  }

  export type WeaponStatsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    fire: number | null
    userId: string | null
  }

  export type WeaponStatsCountAggregateOutputType = {
    id: number
    name: number
    fire: number
    userId: number
    _all: number
  }


  export type WeaponStatsAvgAggregateInputType = {
    fire?: true
  }

  export type WeaponStatsSumAggregateInputType = {
    fire?: true
  }

  export type WeaponStatsMinAggregateInputType = {
    id?: true
    name?: true
    fire?: true
    userId?: true
  }

  export type WeaponStatsMaxAggregateInputType = {
    id?: true
    name?: true
    fire?: true
    userId?: true
  }

  export type WeaponStatsCountAggregateInputType = {
    id?: true
    name?: true
    fire?: true
    userId?: true
    _all?: true
  }

  export type WeaponStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeaponStats to aggregate.
     */
    where?: WeaponStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponStats to fetch.
     */
    orderBy?: WeaponStatsOrderByWithRelationInput | WeaponStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeaponStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeaponStats
    **/
    _count?: true | WeaponStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeaponStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeaponStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeaponStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeaponStatsMaxAggregateInputType
  }

  export type GetWeaponStatsAggregateType<T extends WeaponStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateWeaponStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeaponStats[P]>
      : GetScalarType<T[P], AggregateWeaponStats[P]>
  }




  export type WeaponStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponStatsWhereInput
    orderBy?: WeaponStatsOrderByWithAggregationInput | WeaponStatsOrderByWithAggregationInput[]
    by: WeaponStatsScalarFieldEnum[] | WeaponStatsScalarFieldEnum
    having?: WeaponStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeaponStatsCountAggregateInputType | true
    _avg?: WeaponStatsAvgAggregateInputType
    _sum?: WeaponStatsSumAggregateInputType
    _min?: WeaponStatsMinAggregateInputType
    _max?: WeaponStatsMaxAggregateInputType
  }

  export type WeaponStatsGroupByOutputType = {
    id: string
    name: string
    fire: number
    userId: string
    _count: WeaponStatsCountAggregateOutputType | null
    _avg: WeaponStatsAvgAggregateOutputType | null
    _sum: WeaponStatsSumAggregateOutputType | null
    _min: WeaponStatsMinAggregateOutputType | null
    _max: WeaponStatsMaxAggregateOutputType | null
  }

  type GetWeaponStatsGroupByPayload<T extends WeaponStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeaponStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeaponStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeaponStatsGroupByOutputType[P]>
            : GetScalarType<T[P], WeaponStatsGroupByOutputType[P]>
        }
      >
    >


  export type WeaponStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fire?: boolean
    userId?: boolean
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
    hits?: boolean | WeaponStats$hitsArgs<ExtArgs>
    _count?: boolean | WeaponStatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weaponStats"]>

  export type WeaponStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fire?: boolean
    userId?: boolean
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weaponStats"]>

  export type WeaponStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fire?: boolean
    userId?: boolean
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weaponStats"]>

  export type WeaponStatsSelectScalar = {
    id?: boolean
    name?: boolean
    fire?: boolean
    userId?: boolean
  }

  export type WeaponStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "fire" | "userId", ExtArgs["result"]["weaponStats"]>
  export type WeaponStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
    hits?: boolean | WeaponStats$hitsArgs<ExtArgs>
    _count?: boolean | WeaponStatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeaponStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }
  export type WeaponStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generalPlayerStatistics?: boolean | GeneralPlayerStatisticsDefaultArgs<ExtArgs>
  }

  export type $WeaponStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeaponStats"
    objects: {
      generalPlayerStatistics: Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>
      hits: Prisma.$HitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      fire: number
      userId: string
    }, ExtArgs["result"]["weaponStats"]>
    composites: {}
  }

  type WeaponStatsGetPayload<S extends boolean | null | undefined | WeaponStatsDefaultArgs> = $Result.GetResult<Prisma.$WeaponStatsPayload, S>

  type WeaponStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeaponStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeaponStatsCountAggregateInputType | true
    }

  export interface WeaponStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeaponStats'], meta: { name: 'WeaponStats' } }
    /**
     * Find zero or one WeaponStats that matches the filter.
     * @param {WeaponStatsFindUniqueArgs} args - Arguments to find a WeaponStats
     * @example
     * // Get one WeaponStats
     * const weaponStats = await prisma.weaponStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeaponStatsFindUniqueArgs>(args: SelectSubset<T, WeaponStatsFindUniqueArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeaponStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeaponStatsFindUniqueOrThrowArgs} args - Arguments to find a WeaponStats
     * @example
     * // Get one WeaponStats
     * const weaponStats = await prisma.weaponStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeaponStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, WeaponStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeaponStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponStatsFindFirstArgs} args - Arguments to find a WeaponStats
     * @example
     * // Get one WeaponStats
     * const weaponStats = await prisma.weaponStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeaponStatsFindFirstArgs>(args?: SelectSubset<T, WeaponStatsFindFirstArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeaponStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponStatsFindFirstOrThrowArgs} args - Arguments to find a WeaponStats
     * @example
     * // Get one WeaponStats
     * const weaponStats = await prisma.weaponStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeaponStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, WeaponStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeaponStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeaponStats
     * const weaponStats = await prisma.weaponStats.findMany()
     * 
     * // Get first 10 WeaponStats
     * const weaponStats = await prisma.weaponStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weaponStatsWithIdOnly = await prisma.weaponStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeaponStatsFindManyArgs>(args?: SelectSubset<T, WeaponStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeaponStats.
     * @param {WeaponStatsCreateArgs} args - Arguments to create a WeaponStats.
     * @example
     * // Create one WeaponStats
     * const WeaponStats = await prisma.weaponStats.create({
     *   data: {
     *     // ... data to create a WeaponStats
     *   }
     * })
     * 
     */
    create<T extends WeaponStatsCreateArgs>(args: SelectSubset<T, WeaponStatsCreateArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeaponStats.
     * @param {WeaponStatsCreateManyArgs} args - Arguments to create many WeaponStats.
     * @example
     * // Create many WeaponStats
     * const weaponStats = await prisma.weaponStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeaponStatsCreateManyArgs>(args?: SelectSubset<T, WeaponStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeaponStats and returns the data saved in the database.
     * @param {WeaponStatsCreateManyAndReturnArgs} args - Arguments to create many WeaponStats.
     * @example
     * // Create many WeaponStats
     * const weaponStats = await prisma.weaponStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeaponStats and only return the `id`
     * const weaponStatsWithIdOnly = await prisma.weaponStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeaponStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, WeaponStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeaponStats.
     * @param {WeaponStatsDeleteArgs} args - Arguments to delete one WeaponStats.
     * @example
     * // Delete one WeaponStats
     * const WeaponStats = await prisma.weaponStats.delete({
     *   where: {
     *     // ... filter to delete one WeaponStats
     *   }
     * })
     * 
     */
    delete<T extends WeaponStatsDeleteArgs>(args: SelectSubset<T, WeaponStatsDeleteArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeaponStats.
     * @param {WeaponStatsUpdateArgs} args - Arguments to update one WeaponStats.
     * @example
     * // Update one WeaponStats
     * const weaponStats = await prisma.weaponStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeaponStatsUpdateArgs>(args: SelectSubset<T, WeaponStatsUpdateArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeaponStats.
     * @param {WeaponStatsDeleteManyArgs} args - Arguments to filter WeaponStats to delete.
     * @example
     * // Delete a few WeaponStats
     * const { count } = await prisma.weaponStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeaponStatsDeleteManyArgs>(args?: SelectSubset<T, WeaponStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeaponStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeaponStats
     * const weaponStats = await prisma.weaponStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeaponStatsUpdateManyArgs>(args: SelectSubset<T, WeaponStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeaponStats and returns the data updated in the database.
     * @param {WeaponStatsUpdateManyAndReturnArgs} args - Arguments to update many WeaponStats.
     * @example
     * // Update many WeaponStats
     * const weaponStats = await prisma.weaponStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeaponStats and only return the `id`
     * const weaponStatsWithIdOnly = await prisma.weaponStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeaponStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, WeaponStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeaponStats.
     * @param {WeaponStatsUpsertArgs} args - Arguments to update or create a WeaponStats.
     * @example
     * // Update or create a WeaponStats
     * const weaponStats = await prisma.weaponStats.upsert({
     *   create: {
     *     // ... data to create a WeaponStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeaponStats we want to update
     *   }
     * })
     */
    upsert<T extends WeaponStatsUpsertArgs>(args: SelectSubset<T, WeaponStatsUpsertArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeaponStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponStatsCountArgs} args - Arguments to filter WeaponStats to count.
     * @example
     * // Count the number of WeaponStats
     * const count = await prisma.weaponStats.count({
     *   where: {
     *     // ... the filter for the WeaponStats we want to count
     *   }
     * })
    **/
    count<T extends WeaponStatsCountArgs>(
      args?: Subset<T, WeaponStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeaponStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeaponStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeaponStatsAggregateArgs>(args: Subset<T, WeaponStatsAggregateArgs>): Prisma.PrismaPromise<GetWeaponStatsAggregateType<T>>

    /**
     * Group by WeaponStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeaponStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeaponStatsGroupByArgs['orderBy'] }
        : { orderBy?: WeaponStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeaponStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeaponStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeaponStats model
   */
  readonly fields: WeaponStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeaponStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeaponStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generalPlayerStatistics<T extends GeneralPlayerStatisticsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GeneralPlayerStatisticsDefaultArgs<ExtArgs>>): Prisma__GeneralPlayerStatisticsClient<$Result.GetResult<Prisma.$GeneralPlayerStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hits<T extends WeaponStats$hitsArgs<ExtArgs> = {}>(args?: Subset<T, WeaponStats$hitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeaponStats model
   */
  interface WeaponStatsFieldRefs {
    readonly id: FieldRef<"WeaponStats", 'String'>
    readonly name: FieldRef<"WeaponStats", 'String'>
    readonly fire: FieldRef<"WeaponStats", 'Int'>
    readonly userId: FieldRef<"WeaponStats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeaponStats findUnique
   */
  export type WeaponStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * Filter, which WeaponStats to fetch.
     */
    where: WeaponStatsWhereUniqueInput
  }

  /**
   * WeaponStats findUniqueOrThrow
   */
  export type WeaponStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * Filter, which WeaponStats to fetch.
     */
    where: WeaponStatsWhereUniqueInput
  }

  /**
   * WeaponStats findFirst
   */
  export type WeaponStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * Filter, which WeaponStats to fetch.
     */
    where?: WeaponStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponStats to fetch.
     */
    orderBy?: WeaponStatsOrderByWithRelationInput | WeaponStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeaponStats.
     */
    cursor?: WeaponStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeaponStats.
     */
    distinct?: WeaponStatsScalarFieldEnum | WeaponStatsScalarFieldEnum[]
  }

  /**
   * WeaponStats findFirstOrThrow
   */
  export type WeaponStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * Filter, which WeaponStats to fetch.
     */
    where?: WeaponStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponStats to fetch.
     */
    orderBy?: WeaponStatsOrderByWithRelationInput | WeaponStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeaponStats.
     */
    cursor?: WeaponStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeaponStats.
     */
    distinct?: WeaponStatsScalarFieldEnum | WeaponStatsScalarFieldEnum[]
  }

  /**
   * WeaponStats findMany
   */
  export type WeaponStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * Filter, which WeaponStats to fetch.
     */
    where?: WeaponStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponStats to fetch.
     */
    orderBy?: WeaponStatsOrderByWithRelationInput | WeaponStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeaponStats.
     */
    cursor?: WeaponStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponStats.
     */
    skip?: number
    distinct?: WeaponStatsScalarFieldEnum | WeaponStatsScalarFieldEnum[]
  }

  /**
   * WeaponStats create
   */
  export type WeaponStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a WeaponStats.
     */
    data: XOR<WeaponStatsCreateInput, WeaponStatsUncheckedCreateInput>
  }

  /**
   * WeaponStats createMany
   */
  export type WeaponStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeaponStats.
     */
    data: WeaponStatsCreateManyInput | WeaponStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeaponStats createManyAndReturn
   */
  export type WeaponStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * The data used to create many WeaponStats.
     */
    data: WeaponStatsCreateManyInput | WeaponStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeaponStats update
   */
  export type WeaponStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a WeaponStats.
     */
    data: XOR<WeaponStatsUpdateInput, WeaponStatsUncheckedUpdateInput>
    /**
     * Choose, which WeaponStats to update.
     */
    where: WeaponStatsWhereUniqueInput
  }

  /**
   * WeaponStats updateMany
   */
  export type WeaponStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeaponStats.
     */
    data: XOR<WeaponStatsUpdateManyMutationInput, WeaponStatsUncheckedUpdateManyInput>
    /**
     * Filter which WeaponStats to update
     */
    where?: WeaponStatsWhereInput
    /**
     * Limit how many WeaponStats to update.
     */
    limit?: number
  }

  /**
   * WeaponStats updateManyAndReturn
   */
  export type WeaponStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * The data used to update WeaponStats.
     */
    data: XOR<WeaponStatsUpdateManyMutationInput, WeaponStatsUncheckedUpdateManyInput>
    /**
     * Filter which WeaponStats to update
     */
    where?: WeaponStatsWhereInput
    /**
     * Limit how many WeaponStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WeaponStats upsert
   */
  export type WeaponStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the WeaponStats to update in case it exists.
     */
    where: WeaponStatsWhereUniqueInput
    /**
     * In case the WeaponStats found by the `where` argument doesn't exist, create a new WeaponStats with this data.
     */
    create: XOR<WeaponStatsCreateInput, WeaponStatsUncheckedCreateInput>
    /**
     * In case the WeaponStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeaponStatsUpdateInput, WeaponStatsUncheckedUpdateInput>
  }

  /**
   * WeaponStats delete
   */
  export type WeaponStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
    /**
     * Filter which WeaponStats to delete.
     */
    where: WeaponStatsWhereUniqueInput
  }

  /**
   * WeaponStats deleteMany
   */
  export type WeaponStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeaponStats to delete
     */
    where?: WeaponStatsWhereInput
    /**
     * Limit how many WeaponStats to delete.
     */
    limit?: number
  }

  /**
   * WeaponStats.hits
   */
  export type WeaponStats$hitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    where?: HitWhereInput
    orderBy?: HitOrderByWithRelationInput | HitOrderByWithRelationInput[]
    cursor?: HitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HitScalarFieldEnum | HitScalarFieldEnum[]
  }

  /**
   * WeaponStats without action
   */
  export type WeaponStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponStats
     */
    select?: WeaponStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponStats
     */
    omit?: WeaponStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponStatsInclude<ExtArgs> | null
  }


  /**
   * Model Hit
   */

  export type AggregateHit = {
    _count: HitCountAggregateOutputType | null
    _avg: HitAvgAggregateOutputType | null
    _sum: HitSumAggregateOutputType | null
    _min: HitMinAggregateOutputType | null
    _max: HitMaxAggregateOutputType | null
  }

  export type HitAvgAggregateOutputType = {
    hits: number | null
    totalDamage: number | null
    kills: number | null
  }

  export type HitSumAggregateOutputType = {
    hits: number | null
    totalDamage: number | null
    kills: number | null
  }

  export type HitMinAggregateOutputType = {
    id: string | null
    weaponId: string | null
    hitLocation: string | null
    hits: number | null
    totalDamage: number | null
    kills: number | null
  }

  export type HitMaxAggregateOutputType = {
    id: string | null
    weaponId: string | null
    hitLocation: string | null
    hits: number | null
    totalDamage: number | null
    kills: number | null
  }

  export type HitCountAggregateOutputType = {
    id: number
    weaponId: number
    hitLocation: number
    hits: number
    totalDamage: number
    kills: number
    _all: number
  }


  export type HitAvgAggregateInputType = {
    hits?: true
    totalDamage?: true
    kills?: true
  }

  export type HitSumAggregateInputType = {
    hits?: true
    totalDamage?: true
    kills?: true
  }

  export type HitMinAggregateInputType = {
    id?: true
    weaponId?: true
    hitLocation?: true
    hits?: true
    totalDamage?: true
    kills?: true
  }

  export type HitMaxAggregateInputType = {
    id?: true
    weaponId?: true
    hitLocation?: true
    hits?: true
    totalDamage?: true
    kills?: true
  }

  export type HitCountAggregateInputType = {
    id?: true
    weaponId?: true
    hitLocation?: true
    hits?: true
    totalDamage?: true
    kills?: true
    _all?: true
  }

  export type HitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hit to aggregate.
     */
    where?: HitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hits to fetch.
     */
    orderBy?: HitOrderByWithRelationInput | HitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hits
    **/
    _count?: true | HitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HitMaxAggregateInputType
  }

  export type GetHitAggregateType<T extends HitAggregateArgs> = {
        [P in keyof T & keyof AggregateHit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHit[P]>
      : GetScalarType<T[P], AggregateHit[P]>
  }




  export type HitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HitWhereInput
    orderBy?: HitOrderByWithAggregationInput | HitOrderByWithAggregationInput[]
    by: HitScalarFieldEnum[] | HitScalarFieldEnum
    having?: HitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HitCountAggregateInputType | true
    _avg?: HitAvgAggregateInputType
    _sum?: HitSumAggregateInputType
    _min?: HitMinAggregateInputType
    _max?: HitMaxAggregateInputType
  }

  export type HitGroupByOutputType = {
    id: string
    weaponId: string
    hitLocation: string
    hits: number
    totalDamage: number
    kills: number
    _count: HitCountAggregateOutputType | null
    _avg: HitAvgAggregateOutputType | null
    _sum: HitSumAggregateOutputType | null
    _min: HitMinAggregateOutputType | null
    _max: HitMaxAggregateOutputType | null
  }

  type GetHitGroupByPayload<T extends HitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HitGroupByOutputType[P]>
            : GetScalarType<T[P], HitGroupByOutputType[P]>
        }
      >
    >


  export type HitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weaponId?: boolean
    hitLocation?: boolean
    hits?: boolean
    totalDamage?: boolean
    kills?: boolean
    weapon?: boolean | WeaponStatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hit"]>

  export type HitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weaponId?: boolean
    hitLocation?: boolean
    hits?: boolean
    totalDamage?: boolean
    kills?: boolean
    weapon?: boolean | WeaponStatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hit"]>

  export type HitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weaponId?: boolean
    hitLocation?: boolean
    hits?: boolean
    totalDamage?: boolean
    kills?: boolean
    weapon?: boolean | WeaponStatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hit"]>

  export type HitSelectScalar = {
    id?: boolean
    weaponId?: boolean
    hitLocation?: boolean
    hits?: boolean
    totalDamage?: boolean
    kills?: boolean
  }

  export type HitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "weaponId" | "hitLocation" | "hits" | "totalDamage" | "kills", ExtArgs["result"]["hit"]>
  export type HitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | WeaponStatsDefaultArgs<ExtArgs>
  }
  export type HitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | WeaponStatsDefaultArgs<ExtArgs>
  }
  export type HitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | WeaponStatsDefaultArgs<ExtArgs>
  }

  export type $HitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hit"
    objects: {
      weapon: Prisma.$WeaponStatsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      weaponId: string
      hitLocation: string
      hits: number
      totalDamage: number
      kills: number
    }, ExtArgs["result"]["hit"]>
    composites: {}
  }

  type HitGetPayload<S extends boolean | null | undefined | HitDefaultArgs> = $Result.GetResult<Prisma.$HitPayload, S>

  type HitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HitCountAggregateInputType | true
    }

  export interface HitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hit'], meta: { name: 'Hit' } }
    /**
     * Find zero or one Hit that matches the filter.
     * @param {HitFindUniqueArgs} args - Arguments to find a Hit
     * @example
     * // Get one Hit
     * const hit = await prisma.hit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HitFindUniqueArgs>(args: SelectSubset<T, HitFindUniqueArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HitFindUniqueOrThrowArgs} args - Arguments to find a Hit
     * @example
     * // Get one Hit
     * const hit = await prisma.hit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HitFindUniqueOrThrowArgs>(args: SelectSubset<T, HitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitFindFirstArgs} args - Arguments to find a Hit
     * @example
     * // Get one Hit
     * const hit = await prisma.hit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HitFindFirstArgs>(args?: SelectSubset<T, HitFindFirstArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitFindFirstOrThrowArgs} args - Arguments to find a Hit
     * @example
     * // Get one Hit
     * const hit = await prisma.hit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HitFindFirstOrThrowArgs>(args?: SelectSubset<T, HitFindFirstOrThrowArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hits
     * const hits = await prisma.hit.findMany()
     * 
     * // Get first 10 Hits
     * const hits = await prisma.hit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hitWithIdOnly = await prisma.hit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HitFindManyArgs>(args?: SelectSubset<T, HitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hit.
     * @param {HitCreateArgs} args - Arguments to create a Hit.
     * @example
     * // Create one Hit
     * const Hit = await prisma.hit.create({
     *   data: {
     *     // ... data to create a Hit
     *   }
     * })
     * 
     */
    create<T extends HitCreateArgs>(args: SelectSubset<T, HitCreateArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hits.
     * @param {HitCreateManyArgs} args - Arguments to create many Hits.
     * @example
     * // Create many Hits
     * const hit = await prisma.hit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HitCreateManyArgs>(args?: SelectSubset<T, HitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hits and returns the data saved in the database.
     * @param {HitCreateManyAndReturnArgs} args - Arguments to create many Hits.
     * @example
     * // Create many Hits
     * const hit = await prisma.hit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hits and only return the `id`
     * const hitWithIdOnly = await prisma.hit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HitCreateManyAndReturnArgs>(args?: SelectSubset<T, HitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hit.
     * @param {HitDeleteArgs} args - Arguments to delete one Hit.
     * @example
     * // Delete one Hit
     * const Hit = await prisma.hit.delete({
     *   where: {
     *     // ... filter to delete one Hit
     *   }
     * })
     * 
     */
    delete<T extends HitDeleteArgs>(args: SelectSubset<T, HitDeleteArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hit.
     * @param {HitUpdateArgs} args - Arguments to update one Hit.
     * @example
     * // Update one Hit
     * const hit = await prisma.hit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HitUpdateArgs>(args: SelectSubset<T, HitUpdateArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hits.
     * @param {HitDeleteManyArgs} args - Arguments to filter Hits to delete.
     * @example
     * // Delete a few Hits
     * const { count } = await prisma.hit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HitDeleteManyArgs>(args?: SelectSubset<T, HitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hits
     * const hit = await prisma.hit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HitUpdateManyArgs>(args: SelectSubset<T, HitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hits and returns the data updated in the database.
     * @param {HitUpdateManyAndReturnArgs} args - Arguments to update many Hits.
     * @example
     * // Update many Hits
     * const hit = await prisma.hit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hits and only return the `id`
     * const hitWithIdOnly = await prisma.hit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HitUpdateManyAndReturnArgs>(args: SelectSubset<T, HitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hit.
     * @param {HitUpsertArgs} args - Arguments to update or create a Hit.
     * @example
     * // Update or create a Hit
     * const hit = await prisma.hit.upsert({
     *   create: {
     *     // ... data to create a Hit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hit we want to update
     *   }
     * })
     */
    upsert<T extends HitUpsertArgs>(args: SelectSubset<T, HitUpsertArgs<ExtArgs>>): Prisma__HitClient<$Result.GetResult<Prisma.$HitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitCountArgs} args - Arguments to filter Hits to count.
     * @example
     * // Count the number of Hits
     * const count = await prisma.hit.count({
     *   where: {
     *     // ... the filter for the Hits we want to count
     *   }
     * })
    **/
    count<T extends HitCountArgs>(
      args?: Subset<T, HitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HitAggregateArgs>(args: Subset<T, HitAggregateArgs>): Prisma.PrismaPromise<GetHitAggregateType<T>>

    /**
     * Group by Hit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HitGroupByArgs['orderBy'] }
        : { orderBy?: HitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hit model
   */
  readonly fields: HitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weapon<T extends WeaponStatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeaponStatsDefaultArgs<ExtArgs>>): Prisma__WeaponStatsClient<$Result.GetResult<Prisma.$WeaponStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hit model
   */
  interface HitFieldRefs {
    readonly id: FieldRef<"Hit", 'String'>
    readonly weaponId: FieldRef<"Hit", 'String'>
    readonly hitLocation: FieldRef<"Hit", 'String'>
    readonly hits: FieldRef<"Hit", 'Int'>
    readonly totalDamage: FieldRef<"Hit", 'Int'>
    readonly kills: FieldRef<"Hit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Hit findUnique
   */
  export type HitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * Filter, which Hit to fetch.
     */
    where: HitWhereUniqueInput
  }

  /**
   * Hit findUniqueOrThrow
   */
  export type HitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * Filter, which Hit to fetch.
     */
    where: HitWhereUniqueInput
  }

  /**
   * Hit findFirst
   */
  export type HitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * Filter, which Hit to fetch.
     */
    where?: HitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hits to fetch.
     */
    orderBy?: HitOrderByWithRelationInput | HitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hits.
     */
    cursor?: HitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hits.
     */
    distinct?: HitScalarFieldEnum | HitScalarFieldEnum[]
  }

  /**
   * Hit findFirstOrThrow
   */
  export type HitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * Filter, which Hit to fetch.
     */
    where?: HitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hits to fetch.
     */
    orderBy?: HitOrderByWithRelationInput | HitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hits.
     */
    cursor?: HitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hits.
     */
    distinct?: HitScalarFieldEnum | HitScalarFieldEnum[]
  }

  /**
   * Hit findMany
   */
  export type HitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * Filter, which Hits to fetch.
     */
    where?: HitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hits to fetch.
     */
    orderBy?: HitOrderByWithRelationInput | HitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hits.
     */
    cursor?: HitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hits.
     */
    skip?: number
    distinct?: HitScalarFieldEnum | HitScalarFieldEnum[]
  }

  /**
   * Hit create
   */
  export type HitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * The data needed to create a Hit.
     */
    data: XOR<HitCreateInput, HitUncheckedCreateInput>
  }

  /**
   * Hit createMany
   */
  export type HitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hits.
     */
    data: HitCreateManyInput | HitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hit createManyAndReturn
   */
  export type HitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * The data used to create many Hits.
     */
    data: HitCreateManyInput | HitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hit update
   */
  export type HitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * The data needed to update a Hit.
     */
    data: XOR<HitUpdateInput, HitUncheckedUpdateInput>
    /**
     * Choose, which Hit to update.
     */
    where: HitWhereUniqueInput
  }

  /**
   * Hit updateMany
   */
  export type HitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hits.
     */
    data: XOR<HitUpdateManyMutationInput, HitUncheckedUpdateManyInput>
    /**
     * Filter which Hits to update
     */
    where?: HitWhereInput
    /**
     * Limit how many Hits to update.
     */
    limit?: number
  }

  /**
   * Hit updateManyAndReturn
   */
  export type HitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * The data used to update Hits.
     */
    data: XOR<HitUpdateManyMutationInput, HitUncheckedUpdateManyInput>
    /**
     * Filter which Hits to update
     */
    where?: HitWhereInput
    /**
     * Limit how many Hits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hit upsert
   */
  export type HitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * The filter to search for the Hit to update in case it exists.
     */
    where: HitWhereUniqueInput
    /**
     * In case the Hit found by the `where` argument doesn't exist, create a new Hit with this data.
     */
    create: XOR<HitCreateInput, HitUncheckedCreateInput>
    /**
     * In case the Hit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HitUpdateInput, HitUncheckedUpdateInput>
  }

  /**
   * Hit delete
   */
  export type HitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
    /**
     * Filter which Hit to delete.
     */
    where: HitWhereUniqueInput
  }

  /**
   * Hit deleteMany
   */
  export type HitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hits to delete
     */
    where?: HitWhereInput
    /**
     * Limit how many Hits to delete.
     */
    limit?: number
  }

  /**
   * Hit without action
   */
  export type HitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hit
     */
    select?: HitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hit
     */
    omit?: HitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HitInclude<ExtArgs> | null
  }


  /**
   * Model PlayerStatisticsInMatch
   */

  export type AggregatePlayerStatisticsInMatch = {
    _count: PlayerStatisticsInMatchCountAggregateOutputType | null
    _avg: PlayerStatisticsInMatchAvgAggregateOutputType | null
    _sum: PlayerStatisticsInMatchSumAggregateOutputType | null
    _min: PlayerStatisticsInMatchMinAggregateOutputType | null
    _max: PlayerStatisticsInMatchMaxAggregateOutputType | null
  }

  export type PlayerStatisticsInMatchAvgAggregateOutputType = {
    kills_total: number | null
    deaths_total: number | null
    assists_total: number | null
    headshot_kills_total: number | null
    ace_rounds_total: number | null
    k4_rounds_total: number | null
    k3_rounds_total: number | null
    k2_rounds_total: number | null
    damage_total: number | null
    objective_total: number | null
    utility_damage_total: number | null
    mvps: number | null
    rank_if_win: number | null
    rank: number | null
    rank_if_loss: number | null
    rank_if_tie: number | null
  }

  export type PlayerStatisticsInMatchSumAggregateOutputType = {
    kills_total: number | null
    deaths_total: number | null
    assists_total: number | null
    headshot_kills_total: number | null
    ace_rounds_total: number | null
    k4_rounds_total: number | null
    k3_rounds_total: number | null
    k2_rounds_total: number | null
    damage_total: number | null
    objective_total: number | null
    utility_damage_total: number | null
    mvps: number | null
    rank_if_win: number | null
    rank: number | null
    rank_if_loss: number | null
    rank_if_tie: number | null
  }

  export type PlayerStatisticsInMatchMinAggregateOutputType = {
    id: string | null
    userId: string | null
    matchId: string | null
    kills_total: number | null
    deaths_total: number | null
    assists_total: number | null
    headshot_kills_total: number | null
    ace_rounds_total: number | null
    k4_rounds_total: number | null
    k3_rounds_total: number | null
    k2_rounds_total: number | null
    damage_total: number | null
    objective_total: number | null
    utility_damage_total: number | null
    mvps: number | null
    crosshair_code: string | null
    player_color: string | null
    rank_if_win: number | null
    rank: number | null
    rank_if_loss: number | null
    rank_if_tie: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerStatisticsInMatchMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    matchId: string | null
    kills_total: number | null
    deaths_total: number | null
    assists_total: number | null
    headshot_kills_total: number | null
    ace_rounds_total: number | null
    k4_rounds_total: number | null
    k3_rounds_total: number | null
    k2_rounds_total: number | null
    damage_total: number | null
    objective_total: number | null
    utility_damage_total: number | null
    mvps: number | null
    crosshair_code: string | null
    player_color: string | null
    rank_if_win: number | null
    rank: number | null
    rank_if_loss: number | null
    rank_if_tie: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerStatisticsInMatchCountAggregateOutputType = {
    id: number
    userId: number
    matchId: number
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: number
    player_color: number
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerStatisticsInMatchAvgAggregateInputType = {
    kills_total?: true
    deaths_total?: true
    assists_total?: true
    headshot_kills_total?: true
    ace_rounds_total?: true
    k4_rounds_total?: true
    k3_rounds_total?: true
    k2_rounds_total?: true
    damage_total?: true
    objective_total?: true
    utility_damage_total?: true
    mvps?: true
    rank_if_win?: true
    rank?: true
    rank_if_loss?: true
    rank_if_tie?: true
  }

  export type PlayerStatisticsInMatchSumAggregateInputType = {
    kills_total?: true
    deaths_total?: true
    assists_total?: true
    headshot_kills_total?: true
    ace_rounds_total?: true
    k4_rounds_total?: true
    k3_rounds_total?: true
    k2_rounds_total?: true
    damage_total?: true
    objective_total?: true
    utility_damage_total?: true
    mvps?: true
    rank_if_win?: true
    rank?: true
    rank_if_loss?: true
    rank_if_tie?: true
  }

  export type PlayerStatisticsInMatchMinAggregateInputType = {
    id?: true
    userId?: true
    matchId?: true
    kills_total?: true
    deaths_total?: true
    assists_total?: true
    headshot_kills_total?: true
    ace_rounds_total?: true
    k4_rounds_total?: true
    k3_rounds_total?: true
    k2_rounds_total?: true
    damage_total?: true
    objective_total?: true
    utility_damage_total?: true
    mvps?: true
    crosshair_code?: true
    player_color?: true
    rank_if_win?: true
    rank?: true
    rank_if_loss?: true
    rank_if_tie?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerStatisticsInMatchMaxAggregateInputType = {
    id?: true
    userId?: true
    matchId?: true
    kills_total?: true
    deaths_total?: true
    assists_total?: true
    headshot_kills_total?: true
    ace_rounds_total?: true
    k4_rounds_total?: true
    k3_rounds_total?: true
    k2_rounds_total?: true
    damage_total?: true
    objective_total?: true
    utility_damage_total?: true
    mvps?: true
    crosshair_code?: true
    player_color?: true
    rank_if_win?: true
    rank?: true
    rank_if_loss?: true
    rank_if_tie?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerStatisticsInMatchCountAggregateInputType = {
    id?: true
    userId?: true
    matchId?: true
    kills_total?: true
    deaths_total?: true
    assists_total?: true
    headshot_kills_total?: true
    ace_rounds_total?: true
    k4_rounds_total?: true
    k3_rounds_total?: true
    k2_rounds_total?: true
    damage_total?: true
    objective_total?: true
    utility_damage_total?: true
    mvps?: true
    crosshair_code?: true
    player_color?: true
    rank_if_win?: true
    rank?: true
    rank_if_loss?: true
    rank_if_tie?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerStatisticsInMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerStatisticsInMatch to aggregate.
     */
    where?: PlayerStatisticsInMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStatisticsInMatches to fetch.
     */
    orderBy?: PlayerStatisticsInMatchOrderByWithRelationInput | PlayerStatisticsInMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerStatisticsInMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStatisticsInMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStatisticsInMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerStatisticsInMatches
    **/
    _count?: true | PlayerStatisticsInMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerStatisticsInMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerStatisticsInMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerStatisticsInMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerStatisticsInMatchMaxAggregateInputType
  }

  export type GetPlayerStatisticsInMatchAggregateType<T extends PlayerStatisticsInMatchAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerStatisticsInMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerStatisticsInMatch[P]>
      : GetScalarType<T[P], AggregatePlayerStatisticsInMatch[P]>
  }




  export type PlayerStatisticsInMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerStatisticsInMatchWhereInput
    orderBy?: PlayerStatisticsInMatchOrderByWithAggregationInput | PlayerStatisticsInMatchOrderByWithAggregationInput[]
    by: PlayerStatisticsInMatchScalarFieldEnum[] | PlayerStatisticsInMatchScalarFieldEnum
    having?: PlayerStatisticsInMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerStatisticsInMatchCountAggregateInputType | true
    _avg?: PlayerStatisticsInMatchAvgAggregateInputType
    _sum?: PlayerStatisticsInMatchSumAggregateInputType
    _min?: PlayerStatisticsInMatchMinAggregateInputType
    _max?: PlayerStatisticsInMatchMaxAggregateInputType
  }

  export type PlayerStatisticsInMatchGroupByOutputType = {
    id: string
    userId: string
    matchId: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt: Date
    updatedAt: Date
    _count: PlayerStatisticsInMatchCountAggregateOutputType | null
    _avg: PlayerStatisticsInMatchAvgAggregateOutputType | null
    _sum: PlayerStatisticsInMatchSumAggregateOutputType | null
    _min: PlayerStatisticsInMatchMinAggregateOutputType | null
    _max: PlayerStatisticsInMatchMaxAggregateOutputType | null
  }

  type GetPlayerStatisticsInMatchGroupByPayload<T extends PlayerStatisticsInMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerStatisticsInMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerStatisticsInMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerStatisticsInMatchGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerStatisticsInMatchGroupByOutputType[P]>
        }
      >
    >


  export type PlayerStatisticsInMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matchId?: boolean
    kills_total?: boolean
    deaths_total?: boolean
    assists_total?: boolean
    headshot_kills_total?: boolean
    ace_rounds_total?: boolean
    k4_rounds_total?: boolean
    k3_rounds_total?: boolean
    k2_rounds_total?: boolean
    damage_total?: boolean
    objective_total?: boolean
    utility_damage_total?: boolean
    mvps?: boolean
    crosshair_code?: boolean
    player_color?: boolean
    rank_if_win?: boolean
    rank?: boolean
    rank_if_loss?: boolean
    rank_if_tie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steamUser?: boolean | SteamUserDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStatisticsInMatch"]>

  export type PlayerStatisticsInMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matchId?: boolean
    kills_total?: boolean
    deaths_total?: boolean
    assists_total?: boolean
    headshot_kills_total?: boolean
    ace_rounds_total?: boolean
    k4_rounds_total?: boolean
    k3_rounds_total?: boolean
    k2_rounds_total?: boolean
    damage_total?: boolean
    objective_total?: boolean
    utility_damage_total?: boolean
    mvps?: boolean
    crosshair_code?: boolean
    player_color?: boolean
    rank_if_win?: boolean
    rank?: boolean
    rank_if_loss?: boolean
    rank_if_tie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steamUser?: boolean | SteamUserDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStatisticsInMatch"]>

  export type PlayerStatisticsInMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matchId?: boolean
    kills_total?: boolean
    deaths_total?: boolean
    assists_total?: boolean
    headshot_kills_total?: boolean
    ace_rounds_total?: boolean
    k4_rounds_total?: boolean
    k3_rounds_total?: boolean
    k2_rounds_total?: boolean
    damage_total?: boolean
    objective_total?: boolean
    utility_damage_total?: boolean
    mvps?: boolean
    crosshair_code?: boolean
    player_color?: boolean
    rank_if_win?: boolean
    rank?: boolean
    rank_if_loss?: boolean
    rank_if_tie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steamUser?: boolean | SteamUserDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerStatisticsInMatch"]>

  export type PlayerStatisticsInMatchSelectScalar = {
    id?: boolean
    userId?: boolean
    matchId?: boolean
    kills_total?: boolean
    deaths_total?: boolean
    assists_total?: boolean
    headshot_kills_total?: boolean
    ace_rounds_total?: boolean
    k4_rounds_total?: boolean
    k3_rounds_total?: boolean
    k2_rounds_total?: boolean
    damage_total?: boolean
    objective_total?: boolean
    utility_damage_total?: boolean
    mvps?: boolean
    crosshair_code?: boolean
    player_color?: boolean
    rank_if_win?: boolean
    rank?: boolean
    rank_if_loss?: boolean
    rank_if_tie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerStatisticsInMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "matchId" | "kills_total" | "deaths_total" | "assists_total" | "headshot_kills_total" | "ace_rounds_total" | "k4_rounds_total" | "k3_rounds_total" | "k2_rounds_total" | "damage_total" | "objective_total" | "utility_damage_total" | "mvps" | "crosshair_code" | "player_color" | "rank_if_win" | "rank" | "rank_if_loss" | "rank_if_tie" | "createdAt" | "updatedAt", ExtArgs["result"]["playerStatisticsInMatch"]>
  export type PlayerStatisticsInMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steamUser?: boolean | SteamUserDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }
  export type PlayerStatisticsInMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steamUser?: boolean | SteamUserDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }
  export type PlayerStatisticsInMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steamUser?: boolean | SteamUserDefaultArgs<ExtArgs>
    match?: boolean | MatchDefaultArgs<ExtArgs>
  }

  export type $PlayerStatisticsInMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerStatisticsInMatch"
    objects: {
      steamUser: Prisma.$SteamUserPayload<ExtArgs>
      match: Prisma.$MatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      matchId: string
      kills_total: number
      deaths_total: number
      assists_total: number
      headshot_kills_total: number
      ace_rounds_total: number
      k4_rounds_total: number
      k3_rounds_total: number
      k2_rounds_total: number
      damage_total: number
      objective_total: number
      utility_damage_total: number
      mvps: number
      crosshair_code: string
      player_color: string
      rank_if_win: number
      rank: number
      rank_if_loss: number
      rank_if_tie: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerStatisticsInMatch"]>
    composites: {}
  }

  type PlayerStatisticsInMatchGetPayload<S extends boolean | null | undefined | PlayerStatisticsInMatchDefaultArgs> = $Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload, S>

  type PlayerStatisticsInMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerStatisticsInMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerStatisticsInMatchCountAggregateInputType | true
    }

  export interface PlayerStatisticsInMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerStatisticsInMatch'], meta: { name: 'PlayerStatisticsInMatch' } }
    /**
     * Find zero or one PlayerStatisticsInMatch that matches the filter.
     * @param {PlayerStatisticsInMatchFindUniqueArgs} args - Arguments to find a PlayerStatisticsInMatch
     * @example
     * // Get one PlayerStatisticsInMatch
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerStatisticsInMatchFindUniqueArgs>(args: SelectSubset<T, PlayerStatisticsInMatchFindUniqueArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerStatisticsInMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerStatisticsInMatchFindUniqueOrThrowArgs} args - Arguments to find a PlayerStatisticsInMatch
     * @example
     * // Get one PlayerStatisticsInMatch
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerStatisticsInMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerStatisticsInMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerStatisticsInMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatisticsInMatchFindFirstArgs} args - Arguments to find a PlayerStatisticsInMatch
     * @example
     * // Get one PlayerStatisticsInMatch
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerStatisticsInMatchFindFirstArgs>(args?: SelectSubset<T, PlayerStatisticsInMatchFindFirstArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerStatisticsInMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatisticsInMatchFindFirstOrThrowArgs} args - Arguments to find a PlayerStatisticsInMatch
     * @example
     * // Get one PlayerStatisticsInMatch
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerStatisticsInMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerStatisticsInMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerStatisticsInMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatisticsInMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerStatisticsInMatches
     * const playerStatisticsInMatches = await prisma.playerStatisticsInMatch.findMany()
     * 
     * // Get first 10 PlayerStatisticsInMatches
     * const playerStatisticsInMatches = await prisma.playerStatisticsInMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerStatisticsInMatchWithIdOnly = await prisma.playerStatisticsInMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerStatisticsInMatchFindManyArgs>(args?: SelectSubset<T, PlayerStatisticsInMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerStatisticsInMatch.
     * @param {PlayerStatisticsInMatchCreateArgs} args - Arguments to create a PlayerStatisticsInMatch.
     * @example
     * // Create one PlayerStatisticsInMatch
     * const PlayerStatisticsInMatch = await prisma.playerStatisticsInMatch.create({
     *   data: {
     *     // ... data to create a PlayerStatisticsInMatch
     *   }
     * })
     * 
     */
    create<T extends PlayerStatisticsInMatchCreateArgs>(args: SelectSubset<T, PlayerStatisticsInMatchCreateArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerStatisticsInMatches.
     * @param {PlayerStatisticsInMatchCreateManyArgs} args - Arguments to create many PlayerStatisticsInMatches.
     * @example
     * // Create many PlayerStatisticsInMatches
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerStatisticsInMatchCreateManyArgs>(args?: SelectSubset<T, PlayerStatisticsInMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerStatisticsInMatches and returns the data saved in the database.
     * @param {PlayerStatisticsInMatchCreateManyAndReturnArgs} args - Arguments to create many PlayerStatisticsInMatches.
     * @example
     * // Create many PlayerStatisticsInMatches
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerStatisticsInMatches and only return the `id`
     * const playerStatisticsInMatchWithIdOnly = await prisma.playerStatisticsInMatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerStatisticsInMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerStatisticsInMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerStatisticsInMatch.
     * @param {PlayerStatisticsInMatchDeleteArgs} args - Arguments to delete one PlayerStatisticsInMatch.
     * @example
     * // Delete one PlayerStatisticsInMatch
     * const PlayerStatisticsInMatch = await prisma.playerStatisticsInMatch.delete({
     *   where: {
     *     // ... filter to delete one PlayerStatisticsInMatch
     *   }
     * })
     * 
     */
    delete<T extends PlayerStatisticsInMatchDeleteArgs>(args: SelectSubset<T, PlayerStatisticsInMatchDeleteArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerStatisticsInMatch.
     * @param {PlayerStatisticsInMatchUpdateArgs} args - Arguments to update one PlayerStatisticsInMatch.
     * @example
     * // Update one PlayerStatisticsInMatch
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerStatisticsInMatchUpdateArgs>(args: SelectSubset<T, PlayerStatisticsInMatchUpdateArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerStatisticsInMatches.
     * @param {PlayerStatisticsInMatchDeleteManyArgs} args - Arguments to filter PlayerStatisticsInMatches to delete.
     * @example
     * // Delete a few PlayerStatisticsInMatches
     * const { count } = await prisma.playerStatisticsInMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerStatisticsInMatchDeleteManyArgs>(args?: SelectSubset<T, PlayerStatisticsInMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerStatisticsInMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatisticsInMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerStatisticsInMatches
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerStatisticsInMatchUpdateManyArgs>(args: SelectSubset<T, PlayerStatisticsInMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerStatisticsInMatches and returns the data updated in the database.
     * @param {PlayerStatisticsInMatchUpdateManyAndReturnArgs} args - Arguments to update many PlayerStatisticsInMatches.
     * @example
     * // Update many PlayerStatisticsInMatches
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerStatisticsInMatches and only return the `id`
     * const playerStatisticsInMatchWithIdOnly = await prisma.playerStatisticsInMatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerStatisticsInMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerStatisticsInMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerStatisticsInMatch.
     * @param {PlayerStatisticsInMatchUpsertArgs} args - Arguments to update or create a PlayerStatisticsInMatch.
     * @example
     * // Update or create a PlayerStatisticsInMatch
     * const playerStatisticsInMatch = await prisma.playerStatisticsInMatch.upsert({
     *   create: {
     *     // ... data to create a PlayerStatisticsInMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerStatisticsInMatch we want to update
     *   }
     * })
     */
    upsert<T extends PlayerStatisticsInMatchUpsertArgs>(args: SelectSubset<T, PlayerStatisticsInMatchUpsertArgs<ExtArgs>>): Prisma__PlayerStatisticsInMatchClient<$Result.GetResult<Prisma.$PlayerStatisticsInMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerStatisticsInMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatisticsInMatchCountArgs} args - Arguments to filter PlayerStatisticsInMatches to count.
     * @example
     * // Count the number of PlayerStatisticsInMatches
     * const count = await prisma.playerStatisticsInMatch.count({
     *   where: {
     *     // ... the filter for the PlayerStatisticsInMatches we want to count
     *   }
     * })
    **/
    count<T extends PlayerStatisticsInMatchCountArgs>(
      args?: Subset<T, PlayerStatisticsInMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerStatisticsInMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerStatisticsInMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatisticsInMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerStatisticsInMatchAggregateArgs>(args: Subset<T, PlayerStatisticsInMatchAggregateArgs>): Prisma.PrismaPromise<GetPlayerStatisticsInMatchAggregateType<T>>

    /**
     * Group by PlayerStatisticsInMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerStatisticsInMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerStatisticsInMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerStatisticsInMatchGroupByArgs['orderBy'] }
        : { orderBy?: PlayerStatisticsInMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerStatisticsInMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerStatisticsInMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerStatisticsInMatch model
   */
  readonly fields: PlayerStatisticsInMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerStatisticsInMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerStatisticsInMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steamUser<T extends SteamUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SteamUserDefaultArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerStatisticsInMatch model
   */
  interface PlayerStatisticsInMatchFieldRefs {
    readonly id: FieldRef<"PlayerStatisticsInMatch", 'String'>
    readonly userId: FieldRef<"PlayerStatisticsInMatch", 'String'>
    readonly matchId: FieldRef<"PlayerStatisticsInMatch", 'String'>
    readonly kills_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly deaths_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly assists_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly headshot_kills_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly ace_rounds_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly k4_rounds_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly k3_rounds_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly k2_rounds_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly damage_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly objective_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly utility_damage_total: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly mvps: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly crosshair_code: FieldRef<"PlayerStatisticsInMatch", 'String'>
    readonly player_color: FieldRef<"PlayerStatisticsInMatch", 'String'>
    readonly rank_if_win: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly rank: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly rank_if_loss: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly rank_if_tie: FieldRef<"PlayerStatisticsInMatch", 'Int'>
    readonly createdAt: FieldRef<"PlayerStatisticsInMatch", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerStatisticsInMatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerStatisticsInMatch findUnique
   */
  export type PlayerStatisticsInMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStatisticsInMatch to fetch.
     */
    where: PlayerStatisticsInMatchWhereUniqueInput
  }

  /**
   * PlayerStatisticsInMatch findUniqueOrThrow
   */
  export type PlayerStatisticsInMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStatisticsInMatch to fetch.
     */
    where: PlayerStatisticsInMatchWhereUniqueInput
  }

  /**
   * PlayerStatisticsInMatch findFirst
   */
  export type PlayerStatisticsInMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStatisticsInMatch to fetch.
     */
    where?: PlayerStatisticsInMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStatisticsInMatches to fetch.
     */
    orderBy?: PlayerStatisticsInMatchOrderByWithRelationInput | PlayerStatisticsInMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerStatisticsInMatches.
     */
    cursor?: PlayerStatisticsInMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStatisticsInMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStatisticsInMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerStatisticsInMatches.
     */
    distinct?: PlayerStatisticsInMatchScalarFieldEnum | PlayerStatisticsInMatchScalarFieldEnum[]
  }

  /**
   * PlayerStatisticsInMatch findFirstOrThrow
   */
  export type PlayerStatisticsInMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStatisticsInMatch to fetch.
     */
    where?: PlayerStatisticsInMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStatisticsInMatches to fetch.
     */
    orderBy?: PlayerStatisticsInMatchOrderByWithRelationInput | PlayerStatisticsInMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerStatisticsInMatches.
     */
    cursor?: PlayerStatisticsInMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStatisticsInMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStatisticsInMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerStatisticsInMatches.
     */
    distinct?: PlayerStatisticsInMatchScalarFieldEnum | PlayerStatisticsInMatchScalarFieldEnum[]
  }

  /**
   * PlayerStatisticsInMatch findMany
   */
  export type PlayerStatisticsInMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * Filter, which PlayerStatisticsInMatches to fetch.
     */
    where?: PlayerStatisticsInMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerStatisticsInMatches to fetch.
     */
    orderBy?: PlayerStatisticsInMatchOrderByWithRelationInput | PlayerStatisticsInMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerStatisticsInMatches.
     */
    cursor?: PlayerStatisticsInMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerStatisticsInMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerStatisticsInMatches.
     */
    skip?: number
    distinct?: PlayerStatisticsInMatchScalarFieldEnum | PlayerStatisticsInMatchScalarFieldEnum[]
  }

  /**
   * PlayerStatisticsInMatch create
   */
  export type PlayerStatisticsInMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerStatisticsInMatch.
     */
    data: XOR<PlayerStatisticsInMatchCreateInput, PlayerStatisticsInMatchUncheckedCreateInput>
  }

  /**
   * PlayerStatisticsInMatch createMany
   */
  export type PlayerStatisticsInMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerStatisticsInMatches.
     */
    data: PlayerStatisticsInMatchCreateManyInput | PlayerStatisticsInMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerStatisticsInMatch createManyAndReturn
   */
  export type PlayerStatisticsInMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerStatisticsInMatches.
     */
    data: PlayerStatisticsInMatchCreateManyInput | PlayerStatisticsInMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerStatisticsInMatch update
   */
  export type PlayerStatisticsInMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerStatisticsInMatch.
     */
    data: XOR<PlayerStatisticsInMatchUpdateInput, PlayerStatisticsInMatchUncheckedUpdateInput>
    /**
     * Choose, which PlayerStatisticsInMatch to update.
     */
    where: PlayerStatisticsInMatchWhereUniqueInput
  }

  /**
   * PlayerStatisticsInMatch updateMany
   */
  export type PlayerStatisticsInMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerStatisticsInMatches.
     */
    data: XOR<PlayerStatisticsInMatchUpdateManyMutationInput, PlayerStatisticsInMatchUncheckedUpdateManyInput>
    /**
     * Filter which PlayerStatisticsInMatches to update
     */
    where?: PlayerStatisticsInMatchWhereInput
    /**
     * Limit how many PlayerStatisticsInMatches to update.
     */
    limit?: number
  }

  /**
   * PlayerStatisticsInMatch updateManyAndReturn
   */
  export type PlayerStatisticsInMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * The data used to update PlayerStatisticsInMatches.
     */
    data: XOR<PlayerStatisticsInMatchUpdateManyMutationInput, PlayerStatisticsInMatchUncheckedUpdateManyInput>
    /**
     * Filter which PlayerStatisticsInMatches to update
     */
    where?: PlayerStatisticsInMatchWhereInput
    /**
     * Limit how many PlayerStatisticsInMatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerStatisticsInMatch upsert
   */
  export type PlayerStatisticsInMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerStatisticsInMatch to update in case it exists.
     */
    where: PlayerStatisticsInMatchWhereUniqueInput
    /**
     * In case the PlayerStatisticsInMatch found by the `where` argument doesn't exist, create a new PlayerStatisticsInMatch with this data.
     */
    create: XOR<PlayerStatisticsInMatchCreateInput, PlayerStatisticsInMatchUncheckedCreateInput>
    /**
     * In case the PlayerStatisticsInMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerStatisticsInMatchUpdateInput, PlayerStatisticsInMatchUncheckedUpdateInput>
  }

  /**
   * PlayerStatisticsInMatch delete
   */
  export type PlayerStatisticsInMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
    /**
     * Filter which PlayerStatisticsInMatch to delete.
     */
    where: PlayerStatisticsInMatchWhereUniqueInput
  }

  /**
   * PlayerStatisticsInMatch deleteMany
   */
  export type PlayerStatisticsInMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerStatisticsInMatches to delete
     */
    where?: PlayerStatisticsInMatchWhereInput
    /**
     * Limit how many PlayerStatisticsInMatches to delete.
     */
    limit?: number
  }

  /**
   * PlayerStatisticsInMatch without action
   */
  export type PlayerStatisticsInMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerStatisticsInMatch
     */
    select?: PlayerStatisticsInMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerStatisticsInMatch
     */
    omit?: PlayerStatisticsInMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerStatisticsInMatchInclude<ExtArgs> | null
  }


  /**
   * Model SteamUserBans
   */

  export type AggregateSteamUserBans = {
    _count: SteamUserBansCountAggregateOutputType | null
    _avg: SteamUserBansAvgAggregateOutputType | null
    _sum: SteamUserBansSumAggregateOutputType | null
    _min: SteamUserBansMinAggregateOutputType | null
    _max: SteamUserBansMaxAggregateOutputType | null
  }

  export type SteamUserBansAvgAggregateOutputType = {
    daysSinceLastBan: number | null
    gameBans: number | null
    vacBans: number | null
  }

  export type SteamUserBansSumAggregateOutputType = {
    daysSinceLastBan: number | null
    gameBans: number | null
    vacBans: number | null
  }

  export type SteamUserBansMinAggregateOutputType = {
    id: string | null
    communityBanned: boolean | null
    daysSinceLastBan: number | null
    economyBan: string | null
    gameBans: number | null
    vacBanned: boolean | null
    vacBans: number | null
    csBan: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SteamUserBansMaxAggregateOutputType = {
    id: string | null
    communityBanned: boolean | null
    daysSinceLastBan: number | null
    economyBan: string | null
    gameBans: number | null
    vacBanned: boolean | null
    vacBans: number | null
    csBan: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SteamUserBansCountAggregateOutputType = {
    id: number
    communityBanned: number
    daysSinceLastBan: number
    economyBan: number
    gameBans: number
    vacBanned: number
    vacBans: number
    csBan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SteamUserBansAvgAggregateInputType = {
    daysSinceLastBan?: true
    gameBans?: true
    vacBans?: true
  }

  export type SteamUserBansSumAggregateInputType = {
    daysSinceLastBan?: true
    gameBans?: true
    vacBans?: true
  }

  export type SteamUserBansMinAggregateInputType = {
    id?: true
    communityBanned?: true
    daysSinceLastBan?: true
    economyBan?: true
    gameBans?: true
    vacBanned?: true
    vacBans?: true
    csBan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SteamUserBansMaxAggregateInputType = {
    id?: true
    communityBanned?: true
    daysSinceLastBan?: true
    economyBan?: true
    gameBans?: true
    vacBanned?: true
    vacBans?: true
    csBan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SteamUserBansCountAggregateInputType = {
    id?: true
    communityBanned?: true
    daysSinceLastBan?: true
    economyBan?: true
    gameBans?: true
    vacBanned?: true
    vacBans?: true
    csBan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SteamUserBansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SteamUserBans to aggregate.
     */
    where?: SteamUserBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUserBans to fetch.
     */
    orderBy?: SteamUserBansOrderByWithRelationInput | SteamUserBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SteamUserBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUserBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SteamUserBans
    **/
    _count?: true | SteamUserBansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SteamUserBansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SteamUserBansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SteamUserBansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SteamUserBansMaxAggregateInputType
  }

  export type GetSteamUserBansAggregateType<T extends SteamUserBansAggregateArgs> = {
        [P in keyof T & keyof AggregateSteamUserBans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSteamUserBans[P]>
      : GetScalarType<T[P], AggregateSteamUserBans[P]>
  }




  export type SteamUserBansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SteamUserBansWhereInput
    orderBy?: SteamUserBansOrderByWithAggregationInput | SteamUserBansOrderByWithAggregationInput[]
    by: SteamUserBansScalarFieldEnum[] | SteamUserBansScalarFieldEnum
    having?: SteamUserBansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SteamUserBansCountAggregateInputType | true
    _avg?: SteamUserBansAvgAggregateInputType
    _sum?: SteamUserBansSumAggregateInputType
    _min?: SteamUserBansMinAggregateInputType
    _max?: SteamUserBansMaxAggregateInputType
  }

  export type SteamUserBansGroupByOutputType = {
    id: string
    communityBanned: boolean | null
    daysSinceLastBan: number | null
    economyBan: string | null
    gameBans: number | null
    vacBanned: boolean | null
    vacBans: number | null
    csBan: boolean
    createdAt: Date
    updatedAt: Date
    _count: SteamUserBansCountAggregateOutputType | null
    _avg: SteamUserBansAvgAggregateOutputType | null
    _sum: SteamUserBansSumAggregateOutputType | null
    _min: SteamUserBansMinAggregateOutputType | null
    _max: SteamUserBansMaxAggregateOutputType | null
  }

  type GetSteamUserBansGroupByPayload<T extends SteamUserBansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SteamUserBansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SteamUserBansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SteamUserBansGroupByOutputType[P]>
            : GetScalarType<T[P], SteamUserBansGroupByOutputType[P]>
        }
      >
    >


  export type SteamUserBansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityBanned?: boolean
    daysSinceLastBan?: boolean
    economyBan?: boolean
    gameBans?: boolean
    vacBanned?: boolean
    vacBans?: boolean
    csBan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["steamUserBans"]>

  export type SteamUserBansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityBanned?: boolean
    daysSinceLastBan?: boolean
    economyBan?: boolean
    gameBans?: boolean
    vacBanned?: boolean
    vacBans?: boolean
    csBan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["steamUserBans"]>

  export type SteamUserBansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityBanned?: boolean
    daysSinceLastBan?: boolean
    economyBan?: boolean
    gameBans?: boolean
    vacBanned?: boolean
    vacBans?: boolean
    csBan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["steamUserBans"]>

  export type SteamUserBansSelectScalar = {
    id?: boolean
    communityBanned?: boolean
    daysSinceLastBan?: boolean
    economyBan?: boolean
    gameBans?: boolean
    vacBanned?: boolean
    vacBans?: boolean
    csBan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SteamUserBansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "communityBanned" | "daysSinceLastBan" | "economyBan" | "gameBans" | "vacBanned" | "vacBans" | "csBan" | "createdAt" | "updatedAt", ExtArgs["result"]["steamUserBans"]>
  export type SteamUserBansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }
  export type SteamUserBansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }
  export type SteamUserBansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steam?: boolean | SteamUserDefaultArgs<ExtArgs>
  }

  export type $SteamUserBansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SteamUserBans"
    objects: {
      steam: Prisma.$SteamUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      communityBanned: boolean | null
      daysSinceLastBan: number | null
      economyBan: string | null
      gameBans: number | null
      vacBanned: boolean | null
      vacBans: number | null
      csBan: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["steamUserBans"]>
    composites: {}
  }

  type SteamUserBansGetPayload<S extends boolean | null | undefined | SteamUserBansDefaultArgs> = $Result.GetResult<Prisma.$SteamUserBansPayload, S>

  type SteamUserBansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SteamUserBansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SteamUserBansCountAggregateInputType | true
    }

  export interface SteamUserBansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SteamUserBans'], meta: { name: 'SteamUserBans' } }
    /**
     * Find zero or one SteamUserBans that matches the filter.
     * @param {SteamUserBansFindUniqueArgs} args - Arguments to find a SteamUserBans
     * @example
     * // Get one SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SteamUserBansFindUniqueArgs>(args: SelectSubset<T, SteamUserBansFindUniqueArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SteamUserBans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SteamUserBansFindUniqueOrThrowArgs} args - Arguments to find a SteamUserBans
     * @example
     * // Get one SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SteamUserBansFindUniqueOrThrowArgs>(args: SelectSubset<T, SteamUserBansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SteamUserBans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserBansFindFirstArgs} args - Arguments to find a SteamUserBans
     * @example
     * // Get one SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SteamUserBansFindFirstArgs>(args?: SelectSubset<T, SteamUserBansFindFirstArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SteamUserBans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserBansFindFirstOrThrowArgs} args - Arguments to find a SteamUserBans
     * @example
     * // Get one SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SteamUserBansFindFirstOrThrowArgs>(args?: SelectSubset<T, SteamUserBansFindFirstOrThrowArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SteamUserBans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserBansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.findMany()
     * 
     * // Get first 10 SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const steamUserBansWithIdOnly = await prisma.steamUserBans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SteamUserBansFindManyArgs>(args?: SelectSubset<T, SteamUserBansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SteamUserBans.
     * @param {SteamUserBansCreateArgs} args - Arguments to create a SteamUserBans.
     * @example
     * // Create one SteamUserBans
     * const SteamUserBans = await prisma.steamUserBans.create({
     *   data: {
     *     // ... data to create a SteamUserBans
     *   }
     * })
     * 
     */
    create<T extends SteamUserBansCreateArgs>(args: SelectSubset<T, SteamUserBansCreateArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SteamUserBans.
     * @param {SteamUserBansCreateManyArgs} args - Arguments to create many SteamUserBans.
     * @example
     * // Create many SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SteamUserBansCreateManyArgs>(args?: SelectSubset<T, SteamUserBansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SteamUserBans and returns the data saved in the database.
     * @param {SteamUserBansCreateManyAndReturnArgs} args - Arguments to create many SteamUserBans.
     * @example
     * // Create many SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SteamUserBans and only return the `id`
     * const steamUserBansWithIdOnly = await prisma.steamUserBans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SteamUserBansCreateManyAndReturnArgs>(args?: SelectSubset<T, SteamUserBansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SteamUserBans.
     * @param {SteamUserBansDeleteArgs} args - Arguments to delete one SteamUserBans.
     * @example
     * // Delete one SteamUserBans
     * const SteamUserBans = await prisma.steamUserBans.delete({
     *   where: {
     *     // ... filter to delete one SteamUserBans
     *   }
     * })
     * 
     */
    delete<T extends SteamUserBansDeleteArgs>(args: SelectSubset<T, SteamUserBansDeleteArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SteamUserBans.
     * @param {SteamUserBansUpdateArgs} args - Arguments to update one SteamUserBans.
     * @example
     * // Update one SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SteamUserBansUpdateArgs>(args: SelectSubset<T, SteamUserBansUpdateArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SteamUserBans.
     * @param {SteamUserBansDeleteManyArgs} args - Arguments to filter SteamUserBans to delete.
     * @example
     * // Delete a few SteamUserBans
     * const { count } = await prisma.steamUserBans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SteamUserBansDeleteManyArgs>(args?: SelectSubset<T, SteamUserBansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SteamUserBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserBansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SteamUserBansUpdateManyArgs>(args: SelectSubset<T, SteamUserBansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SteamUserBans and returns the data updated in the database.
     * @param {SteamUserBansUpdateManyAndReturnArgs} args - Arguments to update many SteamUserBans.
     * @example
     * // Update many SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SteamUserBans and only return the `id`
     * const steamUserBansWithIdOnly = await prisma.steamUserBans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SteamUserBansUpdateManyAndReturnArgs>(args: SelectSubset<T, SteamUserBansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SteamUserBans.
     * @param {SteamUserBansUpsertArgs} args - Arguments to update or create a SteamUserBans.
     * @example
     * // Update or create a SteamUserBans
     * const steamUserBans = await prisma.steamUserBans.upsert({
     *   create: {
     *     // ... data to create a SteamUserBans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SteamUserBans we want to update
     *   }
     * })
     */
    upsert<T extends SteamUserBansUpsertArgs>(args: SelectSubset<T, SteamUserBansUpsertArgs<ExtArgs>>): Prisma__SteamUserBansClient<$Result.GetResult<Prisma.$SteamUserBansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SteamUserBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserBansCountArgs} args - Arguments to filter SteamUserBans to count.
     * @example
     * // Count the number of SteamUserBans
     * const count = await prisma.steamUserBans.count({
     *   where: {
     *     // ... the filter for the SteamUserBans we want to count
     *   }
     * })
    **/
    count<T extends SteamUserBansCountArgs>(
      args?: Subset<T, SteamUserBansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SteamUserBansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SteamUserBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserBansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SteamUserBansAggregateArgs>(args: Subset<T, SteamUserBansAggregateArgs>): Prisma.PrismaPromise<GetSteamUserBansAggregateType<T>>

    /**
     * Group by SteamUserBans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SteamUserBansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SteamUserBansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SteamUserBansGroupByArgs['orderBy'] }
        : { orderBy?: SteamUserBansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SteamUserBansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSteamUserBansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SteamUserBans model
   */
  readonly fields: SteamUserBansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SteamUserBans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SteamUserBansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steam<T extends SteamUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SteamUserDefaultArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SteamUserBans model
   */
  interface SteamUserBansFieldRefs {
    readonly id: FieldRef<"SteamUserBans", 'String'>
    readonly communityBanned: FieldRef<"SteamUserBans", 'Boolean'>
    readonly daysSinceLastBan: FieldRef<"SteamUserBans", 'Int'>
    readonly economyBan: FieldRef<"SteamUserBans", 'String'>
    readonly gameBans: FieldRef<"SteamUserBans", 'Int'>
    readonly vacBanned: FieldRef<"SteamUserBans", 'Boolean'>
    readonly vacBans: FieldRef<"SteamUserBans", 'Int'>
    readonly csBan: FieldRef<"SteamUserBans", 'Boolean'>
    readonly createdAt: FieldRef<"SteamUserBans", 'DateTime'>
    readonly updatedAt: FieldRef<"SteamUserBans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SteamUserBans findUnique
   */
  export type SteamUserBansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * Filter, which SteamUserBans to fetch.
     */
    where: SteamUserBansWhereUniqueInput
  }

  /**
   * SteamUserBans findUniqueOrThrow
   */
  export type SteamUserBansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * Filter, which SteamUserBans to fetch.
     */
    where: SteamUserBansWhereUniqueInput
  }

  /**
   * SteamUserBans findFirst
   */
  export type SteamUserBansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * Filter, which SteamUserBans to fetch.
     */
    where?: SteamUserBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUserBans to fetch.
     */
    orderBy?: SteamUserBansOrderByWithRelationInput | SteamUserBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SteamUserBans.
     */
    cursor?: SteamUserBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUserBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SteamUserBans.
     */
    distinct?: SteamUserBansScalarFieldEnum | SteamUserBansScalarFieldEnum[]
  }

  /**
   * SteamUserBans findFirstOrThrow
   */
  export type SteamUserBansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * Filter, which SteamUserBans to fetch.
     */
    where?: SteamUserBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUserBans to fetch.
     */
    orderBy?: SteamUserBansOrderByWithRelationInput | SteamUserBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SteamUserBans.
     */
    cursor?: SteamUserBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUserBans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SteamUserBans.
     */
    distinct?: SteamUserBansScalarFieldEnum | SteamUserBansScalarFieldEnum[]
  }

  /**
   * SteamUserBans findMany
   */
  export type SteamUserBansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * Filter, which SteamUserBans to fetch.
     */
    where?: SteamUserBansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SteamUserBans to fetch.
     */
    orderBy?: SteamUserBansOrderByWithRelationInput | SteamUserBansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SteamUserBans.
     */
    cursor?: SteamUserBansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SteamUserBans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SteamUserBans.
     */
    skip?: number
    distinct?: SteamUserBansScalarFieldEnum | SteamUserBansScalarFieldEnum[]
  }

  /**
   * SteamUserBans create
   */
  export type SteamUserBansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * The data needed to create a SteamUserBans.
     */
    data: XOR<SteamUserBansCreateInput, SteamUserBansUncheckedCreateInput>
  }

  /**
   * SteamUserBans createMany
   */
  export type SteamUserBansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SteamUserBans.
     */
    data: SteamUserBansCreateManyInput | SteamUserBansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SteamUserBans createManyAndReturn
   */
  export type SteamUserBansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * The data used to create many SteamUserBans.
     */
    data: SteamUserBansCreateManyInput | SteamUserBansCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SteamUserBans update
   */
  export type SteamUserBansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * The data needed to update a SteamUserBans.
     */
    data: XOR<SteamUserBansUpdateInput, SteamUserBansUncheckedUpdateInput>
    /**
     * Choose, which SteamUserBans to update.
     */
    where: SteamUserBansWhereUniqueInput
  }

  /**
   * SteamUserBans updateMany
   */
  export type SteamUserBansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SteamUserBans.
     */
    data: XOR<SteamUserBansUpdateManyMutationInput, SteamUserBansUncheckedUpdateManyInput>
    /**
     * Filter which SteamUserBans to update
     */
    where?: SteamUserBansWhereInput
    /**
     * Limit how many SteamUserBans to update.
     */
    limit?: number
  }

  /**
   * SteamUserBans updateManyAndReturn
   */
  export type SteamUserBansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * The data used to update SteamUserBans.
     */
    data: XOR<SteamUserBansUpdateManyMutationInput, SteamUserBansUncheckedUpdateManyInput>
    /**
     * Filter which SteamUserBans to update
     */
    where?: SteamUserBansWhereInput
    /**
     * Limit how many SteamUserBans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SteamUserBans upsert
   */
  export type SteamUserBansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * The filter to search for the SteamUserBans to update in case it exists.
     */
    where: SteamUserBansWhereUniqueInput
    /**
     * In case the SteamUserBans found by the `where` argument doesn't exist, create a new SteamUserBans with this data.
     */
    create: XOR<SteamUserBansCreateInput, SteamUserBansUncheckedCreateInput>
    /**
     * In case the SteamUserBans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SteamUserBansUpdateInput, SteamUserBansUncheckedUpdateInput>
  }

  /**
   * SteamUserBans delete
   */
  export type SteamUserBansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
    /**
     * Filter which SteamUserBans to delete.
     */
    where: SteamUserBansWhereUniqueInput
  }

  /**
   * SteamUserBans deleteMany
   */
  export type SteamUserBansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SteamUserBans to delete
     */
    where?: SteamUserBansWhereInput
    /**
     * Limit how many SteamUserBans to delete.
     */
    limit?: number
  }

  /**
   * SteamUserBans without action
   */
  export type SteamUserBansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SteamUserBans
     */
    select?: SteamUserBansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SteamUserBans
     */
    omit?: SteamUserBansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SteamUserBansInclude<ExtArgs> | null
  }


  /**
   * Model LinksInProfile
   */

  export type AggregateLinksInProfile = {
    _count: LinksInProfileCountAggregateOutputType | null
    _min: LinksInProfileMinAggregateOutputType | null
    _max: LinksInProfileMaxAggregateOutputType | null
  }

  export type LinksInProfileMinAggregateOutputType = {
    id: string | null
    tradeLink: string | null
    twitch: string | null
    youtube: string | null
    telegram: string | null
    discord: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinksInProfileMaxAggregateOutputType = {
    id: string | null
    tradeLink: string | null
    twitch: string | null
    youtube: string | null
    telegram: string | null
    discord: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinksInProfileCountAggregateOutputType = {
    id: number
    tradeLink: number
    twitch: number
    youtube: number
    telegram: number
    discord: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LinksInProfileMinAggregateInputType = {
    id?: true
    tradeLink?: true
    twitch?: true
    youtube?: true
    telegram?: true
    discord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinksInProfileMaxAggregateInputType = {
    id?: true
    tradeLink?: true
    twitch?: true
    youtube?: true
    telegram?: true
    discord?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinksInProfileCountAggregateInputType = {
    id?: true
    tradeLink?: true
    twitch?: true
    youtube?: true
    telegram?: true
    discord?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LinksInProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinksInProfile to aggregate.
     */
    where?: LinksInProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinksInProfiles to fetch.
     */
    orderBy?: LinksInProfileOrderByWithRelationInput | LinksInProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinksInProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinksInProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinksInProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinksInProfiles
    **/
    _count?: true | LinksInProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinksInProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinksInProfileMaxAggregateInputType
  }

  export type GetLinksInProfileAggregateType<T extends LinksInProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLinksInProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinksInProfile[P]>
      : GetScalarType<T[P], AggregateLinksInProfile[P]>
  }




  export type LinksInProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinksInProfileWhereInput
    orderBy?: LinksInProfileOrderByWithAggregationInput | LinksInProfileOrderByWithAggregationInput[]
    by: LinksInProfileScalarFieldEnum[] | LinksInProfileScalarFieldEnum
    having?: LinksInProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinksInProfileCountAggregateInputType | true
    _min?: LinksInProfileMinAggregateInputType
    _max?: LinksInProfileMaxAggregateInputType
  }

  export type LinksInProfileGroupByOutputType = {
    id: string
    tradeLink: string | null
    twitch: string | null
    youtube: string | null
    telegram: string | null
    discord: string | null
    createdAt: Date
    updatedAt: Date
    _count: LinksInProfileCountAggregateOutputType | null
    _min: LinksInProfileMinAggregateOutputType | null
    _max: LinksInProfileMaxAggregateOutputType | null
  }

  type GetLinksInProfileGroupByPayload<T extends LinksInProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinksInProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinksInProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinksInProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LinksInProfileGroupByOutputType[P]>
        }
      >
    >


  export type LinksInProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeLink?: boolean
    twitch?: boolean
    youtube?: boolean
    telegram?: boolean
    discord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linksInProfile"]>

  export type LinksInProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeLink?: boolean
    twitch?: boolean
    youtube?: boolean
    telegram?: boolean
    discord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linksInProfile"]>

  export type LinksInProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeLink?: boolean
    twitch?: boolean
    youtube?: boolean
    telegram?: boolean
    discord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linksInProfile"]>

  export type LinksInProfileSelectScalar = {
    id?: boolean
    tradeLink?: boolean
    twitch?: boolean
    youtube?: boolean
    telegram?: boolean
    discord?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LinksInProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tradeLink" | "twitch" | "youtube" | "telegram" | "discord" | "createdAt" | "updatedAt", ExtArgs["result"]["linksInProfile"]>
  export type LinksInProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LinksInProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LinksInProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LinksInProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinksInProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tradeLink: string | null
      twitch: string | null
      youtube: string | null
      telegram: string | null
      discord: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["linksInProfile"]>
    composites: {}
  }

  type LinksInProfileGetPayload<S extends boolean | null | undefined | LinksInProfileDefaultArgs> = $Result.GetResult<Prisma.$LinksInProfilePayload, S>

  type LinksInProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinksInProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinksInProfileCountAggregateInputType | true
    }

  export interface LinksInProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinksInProfile'], meta: { name: 'LinksInProfile' } }
    /**
     * Find zero or one LinksInProfile that matches the filter.
     * @param {LinksInProfileFindUniqueArgs} args - Arguments to find a LinksInProfile
     * @example
     * // Get one LinksInProfile
     * const linksInProfile = await prisma.linksInProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinksInProfileFindUniqueArgs>(args: SelectSubset<T, LinksInProfileFindUniqueArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinksInProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinksInProfileFindUniqueOrThrowArgs} args - Arguments to find a LinksInProfile
     * @example
     * // Get one LinksInProfile
     * const linksInProfile = await prisma.linksInProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinksInProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LinksInProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinksInProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksInProfileFindFirstArgs} args - Arguments to find a LinksInProfile
     * @example
     * // Get one LinksInProfile
     * const linksInProfile = await prisma.linksInProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinksInProfileFindFirstArgs>(args?: SelectSubset<T, LinksInProfileFindFirstArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinksInProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksInProfileFindFirstOrThrowArgs} args - Arguments to find a LinksInProfile
     * @example
     * // Get one LinksInProfile
     * const linksInProfile = await prisma.linksInProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinksInProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LinksInProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinksInProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksInProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinksInProfiles
     * const linksInProfiles = await prisma.linksInProfile.findMany()
     * 
     * // Get first 10 LinksInProfiles
     * const linksInProfiles = await prisma.linksInProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linksInProfileWithIdOnly = await prisma.linksInProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinksInProfileFindManyArgs>(args?: SelectSubset<T, LinksInProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinksInProfile.
     * @param {LinksInProfileCreateArgs} args - Arguments to create a LinksInProfile.
     * @example
     * // Create one LinksInProfile
     * const LinksInProfile = await prisma.linksInProfile.create({
     *   data: {
     *     // ... data to create a LinksInProfile
     *   }
     * })
     * 
     */
    create<T extends LinksInProfileCreateArgs>(args: SelectSubset<T, LinksInProfileCreateArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinksInProfiles.
     * @param {LinksInProfileCreateManyArgs} args - Arguments to create many LinksInProfiles.
     * @example
     * // Create many LinksInProfiles
     * const linksInProfile = await prisma.linksInProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinksInProfileCreateManyArgs>(args?: SelectSubset<T, LinksInProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinksInProfiles and returns the data saved in the database.
     * @param {LinksInProfileCreateManyAndReturnArgs} args - Arguments to create many LinksInProfiles.
     * @example
     * // Create many LinksInProfiles
     * const linksInProfile = await prisma.linksInProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinksInProfiles and only return the `id`
     * const linksInProfileWithIdOnly = await prisma.linksInProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinksInProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LinksInProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinksInProfile.
     * @param {LinksInProfileDeleteArgs} args - Arguments to delete one LinksInProfile.
     * @example
     * // Delete one LinksInProfile
     * const LinksInProfile = await prisma.linksInProfile.delete({
     *   where: {
     *     // ... filter to delete one LinksInProfile
     *   }
     * })
     * 
     */
    delete<T extends LinksInProfileDeleteArgs>(args: SelectSubset<T, LinksInProfileDeleteArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinksInProfile.
     * @param {LinksInProfileUpdateArgs} args - Arguments to update one LinksInProfile.
     * @example
     * // Update one LinksInProfile
     * const linksInProfile = await prisma.linksInProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinksInProfileUpdateArgs>(args: SelectSubset<T, LinksInProfileUpdateArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinksInProfiles.
     * @param {LinksInProfileDeleteManyArgs} args - Arguments to filter LinksInProfiles to delete.
     * @example
     * // Delete a few LinksInProfiles
     * const { count } = await prisma.linksInProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinksInProfileDeleteManyArgs>(args?: SelectSubset<T, LinksInProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinksInProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksInProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinksInProfiles
     * const linksInProfile = await prisma.linksInProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinksInProfileUpdateManyArgs>(args: SelectSubset<T, LinksInProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinksInProfiles and returns the data updated in the database.
     * @param {LinksInProfileUpdateManyAndReturnArgs} args - Arguments to update many LinksInProfiles.
     * @example
     * // Update many LinksInProfiles
     * const linksInProfile = await prisma.linksInProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinksInProfiles and only return the `id`
     * const linksInProfileWithIdOnly = await prisma.linksInProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinksInProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, LinksInProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinksInProfile.
     * @param {LinksInProfileUpsertArgs} args - Arguments to update or create a LinksInProfile.
     * @example
     * // Update or create a LinksInProfile
     * const linksInProfile = await prisma.linksInProfile.upsert({
     *   create: {
     *     // ... data to create a LinksInProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinksInProfile we want to update
     *   }
     * })
     */
    upsert<T extends LinksInProfileUpsertArgs>(args: SelectSubset<T, LinksInProfileUpsertArgs<ExtArgs>>): Prisma__LinksInProfileClient<$Result.GetResult<Prisma.$LinksInProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinksInProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksInProfileCountArgs} args - Arguments to filter LinksInProfiles to count.
     * @example
     * // Count the number of LinksInProfiles
     * const count = await prisma.linksInProfile.count({
     *   where: {
     *     // ... the filter for the LinksInProfiles we want to count
     *   }
     * })
    **/
    count<T extends LinksInProfileCountArgs>(
      args?: Subset<T, LinksInProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinksInProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinksInProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksInProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinksInProfileAggregateArgs>(args: Subset<T, LinksInProfileAggregateArgs>): Prisma.PrismaPromise<GetLinksInProfileAggregateType<T>>

    /**
     * Group by LinksInProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinksInProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinksInProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinksInProfileGroupByArgs['orderBy'] }
        : { orderBy?: LinksInProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinksInProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinksInProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinksInProfile model
   */
  readonly fields: LinksInProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinksInProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinksInProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinksInProfile model
   */
  interface LinksInProfileFieldRefs {
    readonly id: FieldRef<"LinksInProfile", 'String'>
    readonly tradeLink: FieldRef<"LinksInProfile", 'String'>
    readonly twitch: FieldRef<"LinksInProfile", 'String'>
    readonly youtube: FieldRef<"LinksInProfile", 'String'>
    readonly telegram: FieldRef<"LinksInProfile", 'String'>
    readonly discord: FieldRef<"LinksInProfile", 'String'>
    readonly createdAt: FieldRef<"LinksInProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"LinksInProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinksInProfile findUnique
   */
  export type LinksInProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinksInProfile to fetch.
     */
    where: LinksInProfileWhereUniqueInput
  }

  /**
   * LinksInProfile findUniqueOrThrow
   */
  export type LinksInProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinksInProfile to fetch.
     */
    where: LinksInProfileWhereUniqueInput
  }

  /**
   * LinksInProfile findFirst
   */
  export type LinksInProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinksInProfile to fetch.
     */
    where?: LinksInProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinksInProfiles to fetch.
     */
    orderBy?: LinksInProfileOrderByWithRelationInput | LinksInProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinksInProfiles.
     */
    cursor?: LinksInProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinksInProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinksInProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinksInProfiles.
     */
    distinct?: LinksInProfileScalarFieldEnum | LinksInProfileScalarFieldEnum[]
  }

  /**
   * LinksInProfile findFirstOrThrow
   */
  export type LinksInProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinksInProfile to fetch.
     */
    where?: LinksInProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinksInProfiles to fetch.
     */
    orderBy?: LinksInProfileOrderByWithRelationInput | LinksInProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinksInProfiles.
     */
    cursor?: LinksInProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinksInProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinksInProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinksInProfiles.
     */
    distinct?: LinksInProfileScalarFieldEnum | LinksInProfileScalarFieldEnum[]
  }

  /**
   * LinksInProfile findMany
   */
  export type LinksInProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinksInProfiles to fetch.
     */
    where?: LinksInProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinksInProfiles to fetch.
     */
    orderBy?: LinksInProfileOrderByWithRelationInput | LinksInProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinksInProfiles.
     */
    cursor?: LinksInProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinksInProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinksInProfiles.
     */
    skip?: number
    distinct?: LinksInProfileScalarFieldEnum | LinksInProfileScalarFieldEnum[]
  }

  /**
   * LinksInProfile create
   */
  export type LinksInProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LinksInProfile.
     */
    data: XOR<LinksInProfileCreateInput, LinksInProfileUncheckedCreateInput>
  }

  /**
   * LinksInProfile createMany
   */
  export type LinksInProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinksInProfiles.
     */
    data: LinksInProfileCreateManyInput | LinksInProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinksInProfile createManyAndReturn
   */
  export type LinksInProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * The data used to create many LinksInProfiles.
     */
    data: LinksInProfileCreateManyInput | LinksInProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinksInProfile update
   */
  export type LinksInProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LinksInProfile.
     */
    data: XOR<LinksInProfileUpdateInput, LinksInProfileUncheckedUpdateInput>
    /**
     * Choose, which LinksInProfile to update.
     */
    where: LinksInProfileWhereUniqueInput
  }

  /**
   * LinksInProfile updateMany
   */
  export type LinksInProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinksInProfiles.
     */
    data: XOR<LinksInProfileUpdateManyMutationInput, LinksInProfileUncheckedUpdateManyInput>
    /**
     * Filter which LinksInProfiles to update
     */
    where?: LinksInProfileWhereInput
    /**
     * Limit how many LinksInProfiles to update.
     */
    limit?: number
  }

  /**
   * LinksInProfile updateManyAndReturn
   */
  export type LinksInProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * The data used to update LinksInProfiles.
     */
    data: XOR<LinksInProfileUpdateManyMutationInput, LinksInProfileUncheckedUpdateManyInput>
    /**
     * Filter which LinksInProfiles to update
     */
    where?: LinksInProfileWhereInput
    /**
     * Limit how many LinksInProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinksInProfile upsert
   */
  export type LinksInProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LinksInProfile to update in case it exists.
     */
    where: LinksInProfileWhereUniqueInput
    /**
     * In case the LinksInProfile found by the `where` argument doesn't exist, create a new LinksInProfile with this data.
     */
    create: XOR<LinksInProfileCreateInput, LinksInProfileUncheckedCreateInput>
    /**
     * In case the LinksInProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinksInProfileUpdateInput, LinksInProfileUncheckedUpdateInput>
  }

  /**
   * LinksInProfile delete
   */
  export type LinksInProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
    /**
     * Filter which LinksInProfile to delete.
     */
    where: LinksInProfileWhereUniqueInput
  }

  /**
   * LinksInProfile deleteMany
   */
  export type LinksInProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinksInProfiles to delete
     */
    where?: LinksInProfileWhereInput
    /**
     * Limit how many LinksInProfiles to delete.
     */
    limit?: number
  }

  /**
   * LinksInProfile without action
   */
  export type LinksInProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinksInProfile
     */
    select?: LinksInProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinksInProfile
     */
    omit?: LinksInProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinksInProfileInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    recipientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    authorId: string | null
    recipientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    authorId: number
    recipientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    recipientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    recipientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    authorId?: true
    recipientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    authorId: string
    recipientId: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | Comment$imagesArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "authorId" | "recipientId" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Comment$imagesArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      images: Prisma.$ImagesPayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$SteamUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      authorId: string
      recipientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Comment$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends SteamUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SteamUserDefaultArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly recipientId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.images
   */
  export type Comment$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    where?: ImagesWhereInput
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    cursor?: ImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Images
   */

  export type AggregateImages = {
    _count: ImagesCountAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  export type ImagesMinAggregateOutputType = {
    id: string | null
    url: string | null
    commentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImagesMaxAggregateOutputType = {
    id: string | null
    url: string | null
    commentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImagesCountAggregateOutputType = {
    id: number
    url: number
    commentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImagesMinAggregateInputType = {
    id?: true
    url?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImagesMaxAggregateInputType = {
    id?: true
    url?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImagesCountAggregateInputType = {
    id?: true
    url?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to aggregate.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImagesMaxAggregateInputType
  }

  export type GetImagesAggregateType<T extends ImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImages[P]>
      : GetScalarType<T[P], AggregateImages[P]>
  }




  export type ImagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImagesWhereInput
    orderBy?: ImagesOrderByWithAggregationInput | ImagesOrderByWithAggregationInput[]
    by: ImagesScalarFieldEnum[] | ImagesScalarFieldEnum
    having?: ImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImagesCountAggregateInputType | true
    _min?: ImagesMinAggregateInputType
    _max?: ImagesMaxAggregateInputType
  }

  export type ImagesGroupByOutputType = {
    id: string
    url: string
    commentId: string
    createdAt: Date
    updatedAt: Date
    _count: ImagesCountAggregateOutputType | null
    _min: ImagesMinAggregateOutputType | null
    _max: ImagesMaxAggregateOutputType | null
  }

  type GetImagesGroupByPayload<T extends ImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ImagesGroupByOutputType[P]>
        }
      >
    >


  export type ImagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type ImagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type ImagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["images"]>

  export type ImagesSelectScalar = {
    id?: boolean
    url?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "commentId" | "createdAt" | "updatedAt", ExtArgs["result"]["images"]>
  export type ImagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type ImagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type ImagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $ImagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Images"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      commentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["images"]>
    composites: {}
  }

  type ImagesGetPayload<S extends boolean | null | undefined | ImagesDefaultArgs> = $Result.GetResult<Prisma.$ImagesPayload, S>

  type ImagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImagesCountAggregateInputType | true
    }

  export interface ImagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Images'], meta: { name: 'Images' } }
    /**
     * Find zero or one Images that matches the filter.
     * @param {ImagesFindUniqueArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImagesFindUniqueArgs>(args: SelectSubset<T, ImagesFindUniqueArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImagesFindUniqueOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImagesFindUniqueOrThrowArgs>(args: SelectSubset<T, ImagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesFindFirstArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImagesFindFirstArgs>(args?: SelectSubset<T, ImagesFindFirstArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesFindFirstOrThrowArgs} args - Arguments to find a Images
     * @example
     * // Get one Images
     * const images = await prisma.images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImagesFindFirstOrThrowArgs>(args?: SelectSubset<T, ImagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.images.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagesWithIdOnly = await prisma.images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImagesFindManyArgs>(args?: SelectSubset<T, ImagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Images.
     * @param {ImagesCreateArgs} args - Arguments to create a Images.
     * @example
     * // Create one Images
     * const Images = await prisma.images.create({
     *   data: {
     *     // ... data to create a Images
     *   }
     * })
     * 
     */
    create<T extends ImagesCreateArgs>(args: SelectSubset<T, ImagesCreateArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImagesCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImagesCreateManyArgs>(args?: SelectSubset<T, ImagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImagesCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const images = await prisma.images.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imagesWithIdOnly = await prisma.images.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImagesCreateManyAndReturnArgs>(args?: SelectSubset<T, ImagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Images.
     * @param {ImagesDeleteArgs} args - Arguments to delete one Images.
     * @example
     * // Delete one Images
     * const Images = await prisma.images.delete({
     *   where: {
     *     // ... filter to delete one Images
     *   }
     * })
     * 
     */
    delete<T extends ImagesDeleteArgs>(args: SelectSubset<T, ImagesDeleteArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Images.
     * @param {ImagesUpdateArgs} args - Arguments to update one Images.
     * @example
     * // Update one Images
     * const images = await prisma.images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImagesUpdateArgs>(args: SelectSubset<T, ImagesUpdateArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImagesDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImagesDeleteManyArgs>(args?: SelectSubset<T, ImagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImagesUpdateManyArgs>(args: SelectSubset<T, ImagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImagesUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const images = await prisma.images.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `id`
     * const imagesWithIdOnly = await prisma.images.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImagesUpdateManyAndReturnArgs>(args: SelectSubset<T, ImagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Images.
     * @param {ImagesUpsertArgs} args - Arguments to update or create a Images.
     * @example
     * // Update or create a Images
     * const images = await prisma.images.upsert({
     *   create: {
     *     // ... data to create a Images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Images we want to update
     *   }
     * })
     */
    upsert<T extends ImagesUpsertArgs>(args: SelectSubset<T, ImagesUpsertArgs<ExtArgs>>): Prisma__ImagesClient<$Result.GetResult<Prisma.$ImagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.images.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImagesCountArgs>(
      args?: Subset<T, ImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImagesAggregateArgs>(args: Subset<T, ImagesAggregateArgs>): Prisma.PrismaPromise<GetImagesAggregateType<T>>

    /**
     * Group by Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImagesGroupByArgs['orderBy'] }
        : { orderBy?: ImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Images model
   */
  readonly fields: ImagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Images model
   */
  interface ImagesFieldRefs {
    readonly id: FieldRef<"Images", 'String'>
    readonly url: FieldRef<"Images", 'String'>
    readonly commentId: FieldRef<"Images", 'String'>
    readonly createdAt: FieldRef<"Images", 'DateTime'>
    readonly updatedAt: FieldRef<"Images", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Images findUnique
   */
  export type ImagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images findUniqueOrThrow
   */
  export type ImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images findFirst
   */
  export type ImagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * Images findFirstOrThrow
   */
  export type ImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * Images findMany
   */
  export type ImagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImagesOrderByWithRelationInput | ImagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImagesScalarFieldEnum | ImagesScalarFieldEnum[]
  }

  /**
   * Images create
   */
  export type ImagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Images.
     */
    data: XOR<ImagesCreateInput, ImagesUncheckedCreateInput>
  }

  /**
   * Images createMany
   */
  export type ImagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImagesCreateManyInput | ImagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Images createManyAndReturn
   */
  export type ImagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImagesCreateManyInput | ImagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Images update
   */
  export type ImagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Images.
     */
    data: XOR<ImagesUpdateInput, ImagesUncheckedUpdateInput>
    /**
     * Choose, which Images to update.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images updateMany
   */
  export type ImagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImagesUpdateManyMutationInput, ImagesUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImagesWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Images updateManyAndReturn
   */
  export type ImagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImagesUpdateManyMutationInput, ImagesUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImagesWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Images upsert
   */
  export type ImagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Images to update in case it exists.
     */
    where: ImagesWhereUniqueInput
    /**
     * In case the Images found by the `where` argument doesn't exist, create a new Images with this data.
     */
    create: XOR<ImagesCreateInput, ImagesUncheckedCreateInput>
    /**
     * In case the Images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImagesUpdateInput, ImagesUncheckedUpdateInput>
  }

  /**
   * Images delete
   */
  export type ImagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
    /**
     * Filter which Images to delete.
     */
    where: ImagesWhereUniqueInput
  }

  /**
   * Images deleteMany
   */
  export type ImagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImagesWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Images without action
   */
  export type ImagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Images
     */
    select?: ImagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Images
     */
    omit?: ImagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImagesInclude<ExtArgs> | null
  }


  /**
   * Model JwtToken
   */

  export type AggregateJwtToken = {
    _count: JwtTokenCountAggregateOutputType | null
    _min: JwtTokenMinAggregateOutputType | null
    _max: JwtTokenMaxAggregateOutputType | null
  }

  export type JwtTokenMinAggregateOutputType = {
    id: string | null
    refreshToken: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JwtTokenMaxAggregateOutputType = {
    id: string | null
    refreshToken: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JwtTokenCountAggregateOutputType = {
    id: number
    refreshToken: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JwtTokenMinAggregateInputType = {
    id?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JwtTokenMaxAggregateInputType = {
    id?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JwtTokenCountAggregateInputType = {
    id?: true
    refreshToken?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JwtTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JwtToken to aggregate.
     */
    where?: JwtTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JwtTokens to fetch.
     */
    orderBy?: JwtTokenOrderByWithRelationInput | JwtTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JwtTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JwtTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JwtTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JwtTokens
    **/
    _count?: true | JwtTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JwtTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JwtTokenMaxAggregateInputType
  }

  export type GetJwtTokenAggregateType<T extends JwtTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateJwtToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJwtToken[P]>
      : GetScalarType<T[P], AggregateJwtToken[P]>
  }




  export type JwtTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JwtTokenWhereInput
    orderBy?: JwtTokenOrderByWithAggregationInput | JwtTokenOrderByWithAggregationInput[]
    by: JwtTokenScalarFieldEnum[] | JwtTokenScalarFieldEnum
    having?: JwtTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JwtTokenCountAggregateInputType | true
    _min?: JwtTokenMinAggregateInputType
    _max?: JwtTokenMaxAggregateInputType
  }

  export type JwtTokenGroupByOutputType = {
    id: string
    refreshToken: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: JwtTokenCountAggregateOutputType | null
    _min: JwtTokenMinAggregateOutputType | null
    _max: JwtTokenMaxAggregateOutputType | null
  }

  type GetJwtTokenGroupByPayload<T extends JwtTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JwtTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JwtTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JwtTokenGroupByOutputType[P]>
            : GetScalarType<T[P], JwtTokenGroupByOutputType[P]>
        }
      >
    >


  export type JwtTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jwtToken"]>

  export type JwtTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jwtToken"]>

  export type JwtTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jwtToken"]>

  export type JwtTokenSelectScalar = {
    id?: boolean
    refreshToken?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JwtTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "refreshToken" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["jwtToken"]>
  export type JwtTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JwtTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JwtTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JwtTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JwtToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      refreshToken: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jwtToken"]>
    composites: {}
  }

  type JwtTokenGetPayload<S extends boolean | null | undefined | JwtTokenDefaultArgs> = $Result.GetResult<Prisma.$JwtTokenPayload, S>

  type JwtTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JwtTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JwtTokenCountAggregateInputType | true
    }

  export interface JwtTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JwtToken'], meta: { name: 'JwtToken' } }
    /**
     * Find zero or one JwtToken that matches the filter.
     * @param {JwtTokenFindUniqueArgs} args - Arguments to find a JwtToken
     * @example
     * // Get one JwtToken
     * const jwtToken = await prisma.jwtToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JwtTokenFindUniqueArgs>(args: SelectSubset<T, JwtTokenFindUniqueArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JwtToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JwtTokenFindUniqueOrThrowArgs} args - Arguments to find a JwtToken
     * @example
     * // Get one JwtToken
     * const jwtToken = await prisma.jwtToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JwtTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, JwtTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JwtToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwtTokenFindFirstArgs} args - Arguments to find a JwtToken
     * @example
     * // Get one JwtToken
     * const jwtToken = await prisma.jwtToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JwtTokenFindFirstArgs>(args?: SelectSubset<T, JwtTokenFindFirstArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JwtToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwtTokenFindFirstOrThrowArgs} args - Arguments to find a JwtToken
     * @example
     * // Get one JwtToken
     * const jwtToken = await prisma.jwtToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JwtTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, JwtTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JwtTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwtTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JwtTokens
     * const jwtTokens = await prisma.jwtToken.findMany()
     * 
     * // Get first 10 JwtTokens
     * const jwtTokens = await prisma.jwtToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jwtTokenWithIdOnly = await prisma.jwtToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JwtTokenFindManyArgs>(args?: SelectSubset<T, JwtTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JwtToken.
     * @param {JwtTokenCreateArgs} args - Arguments to create a JwtToken.
     * @example
     * // Create one JwtToken
     * const JwtToken = await prisma.jwtToken.create({
     *   data: {
     *     // ... data to create a JwtToken
     *   }
     * })
     * 
     */
    create<T extends JwtTokenCreateArgs>(args: SelectSubset<T, JwtTokenCreateArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JwtTokens.
     * @param {JwtTokenCreateManyArgs} args - Arguments to create many JwtTokens.
     * @example
     * // Create many JwtTokens
     * const jwtToken = await prisma.jwtToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JwtTokenCreateManyArgs>(args?: SelectSubset<T, JwtTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JwtTokens and returns the data saved in the database.
     * @param {JwtTokenCreateManyAndReturnArgs} args - Arguments to create many JwtTokens.
     * @example
     * // Create many JwtTokens
     * const jwtToken = await prisma.jwtToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JwtTokens and only return the `id`
     * const jwtTokenWithIdOnly = await prisma.jwtToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JwtTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, JwtTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JwtToken.
     * @param {JwtTokenDeleteArgs} args - Arguments to delete one JwtToken.
     * @example
     * // Delete one JwtToken
     * const JwtToken = await prisma.jwtToken.delete({
     *   where: {
     *     // ... filter to delete one JwtToken
     *   }
     * })
     * 
     */
    delete<T extends JwtTokenDeleteArgs>(args: SelectSubset<T, JwtTokenDeleteArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JwtToken.
     * @param {JwtTokenUpdateArgs} args - Arguments to update one JwtToken.
     * @example
     * // Update one JwtToken
     * const jwtToken = await prisma.jwtToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JwtTokenUpdateArgs>(args: SelectSubset<T, JwtTokenUpdateArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JwtTokens.
     * @param {JwtTokenDeleteManyArgs} args - Arguments to filter JwtTokens to delete.
     * @example
     * // Delete a few JwtTokens
     * const { count } = await prisma.jwtToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JwtTokenDeleteManyArgs>(args?: SelectSubset<T, JwtTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JwtTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwtTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JwtTokens
     * const jwtToken = await prisma.jwtToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JwtTokenUpdateManyArgs>(args: SelectSubset<T, JwtTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JwtTokens and returns the data updated in the database.
     * @param {JwtTokenUpdateManyAndReturnArgs} args - Arguments to update many JwtTokens.
     * @example
     * // Update many JwtTokens
     * const jwtToken = await prisma.jwtToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JwtTokens and only return the `id`
     * const jwtTokenWithIdOnly = await prisma.jwtToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JwtTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, JwtTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JwtToken.
     * @param {JwtTokenUpsertArgs} args - Arguments to update or create a JwtToken.
     * @example
     * // Update or create a JwtToken
     * const jwtToken = await prisma.jwtToken.upsert({
     *   create: {
     *     // ... data to create a JwtToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JwtToken we want to update
     *   }
     * })
     */
    upsert<T extends JwtTokenUpsertArgs>(args: SelectSubset<T, JwtTokenUpsertArgs<ExtArgs>>): Prisma__JwtTokenClient<$Result.GetResult<Prisma.$JwtTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JwtTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwtTokenCountArgs} args - Arguments to filter JwtTokens to count.
     * @example
     * // Count the number of JwtTokens
     * const count = await prisma.jwtToken.count({
     *   where: {
     *     // ... the filter for the JwtTokens we want to count
     *   }
     * })
    **/
    count<T extends JwtTokenCountArgs>(
      args?: Subset<T, JwtTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JwtTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JwtToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwtTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JwtTokenAggregateArgs>(args: Subset<T, JwtTokenAggregateArgs>): Prisma.PrismaPromise<GetJwtTokenAggregateType<T>>

    /**
     * Group by JwtToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JwtTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JwtTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JwtTokenGroupByArgs['orderBy'] }
        : { orderBy?: JwtTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JwtTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJwtTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JwtToken model
   */
  readonly fields: JwtTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JwtToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JwtTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JwtToken model
   */
  interface JwtTokenFieldRefs {
    readonly id: FieldRef<"JwtToken", 'String'>
    readonly refreshToken: FieldRef<"JwtToken", 'String'>
    readonly userId: FieldRef<"JwtToken", 'String'>
    readonly createdAt: FieldRef<"JwtToken", 'DateTime'>
    readonly updatedAt: FieldRef<"JwtToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JwtToken findUnique
   */
  export type JwtTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * Filter, which JwtToken to fetch.
     */
    where: JwtTokenWhereUniqueInput
  }

  /**
   * JwtToken findUniqueOrThrow
   */
  export type JwtTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * Filter, which JwtToken to fetch.
     */
    where: JwtTokenWhereUniqueInput
  }

  /**
   * JwtToken findFirst
   */
  export type JwtTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * Filter, which JwtToken to fetch.
     */
    where?: JwtTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JwtTokens to fetch.
     */
    orderBy?: JwtTokenOrderByWithRelationInput | JwtTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JwtTokens.
     */
    cursor?: JwtTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JwtTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JwtTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JwtTokens.
     */
    distinct?: JwtTokenScalarFieldEnum | JwtTokenScalarFieldEnum[]
  }

  /**
   * JwtToken findFirstOrThrow
   */
  export type JwtTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * Filter, which JwtToken to fetch.
     */
    where?: JwtTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JwtTokens to fetch.
     */
    orderBy?: JwtTokenOrderByWithRelationInput | JwtTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JwtTokens.
     */
    cursor?: JwtTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JwtTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JwtTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JwtTokens.
     */
    distinct?: JwtTokenScalarFieldEnum | JwtTokenScalarFieldEnum[]
  }

  /**
   * JwtToken findMany
   */
  export type JwtTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * Filter, which JwtTokens to fetch.
     */
    where?: JwtTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JwtTokens to fetch.
     */
    orderBy?: JwtTokenOrderByWithRelationInput | JwtTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JwtTokens.
     */
    cursor?: JwtTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JwtTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JwtTokens.
     */
    skip?: number
    distinct?: JwtTokenScalarFieldEnum | JwtTokenScalarFieldEnum[]
  }

  /**
   * JwtToken create
   */
  export type JwtTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a JwtToken.
     */
    data: XOR<JwtTokenCreateInput, JwtTokenUncheckedCreateInput>
  }

  /**
   * JwtToken createMany
   */
  export type JwtTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JwtTokens.
     */
    data: JwtTokenCreateManyInput | JwtTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JwtToken createManyAndReturn
   */
  export type JwtTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * The data used to create many JwtTokens.
     */
    data: JwtTokenCreateManyInput | JwtTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JwtToken update
   */
  export type JwtTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a JwtToken.
     */
    data: XOR<JwtTokenUpdateInput, JwtTokenUncheckedUpdateInput>
    /**
     * Choose, which JwtToken to update.
     */
    where: JwtTokenWhereUniqueInput
  }

  /**
   * JwtToken updateMany
   */
  export type JwtTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JwtTokens.
     */
    data: XOR<JwtTokenUpdateManyMutationInput, JwtTokenUncheckedUpdateManyInput>
    /**
     * Filter which JwtTokens to update
     */
    where?: JwtTokenWhereInput
    /**
     * Limit how many JwtTokens to update.
     */
    limit?: number
  }

  /**
   * JwtToken updateManyAndReturn
   */
  export type JwtTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * The data used to update JwtTokens.
     */
    data: XOR<JwtTokenUpdateManyMutationInput, JwtTokenUncheckedUpdateManyInput>
    /**
     * Filter which JwtTokens to update
     */
    where?: JwtTokenWhereInput
    /**
     * Limit how many JwtTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JwtToken upsert
   */
  export type JwtTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the JwtToken to update in case it exists.
     */
    where: JwtTokenWhereUniqueInput
    /**
     * In case the JwtToken found by the `where` argument doesn't exist, create a new JwtToken with this data.
     */
    create: XOR<JwtTokenCreateInput, JwtTokenUncheckedCreateInput>
    /**
     * In case the JwtToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JwtTokenUpdateInput, JwtTokenUncheckedUpdateInput>
  }

  /**
   * JwtToken delete
   */
  export type JwtTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
    /**
     * Filter which JwtToken to delete.
     */
    where: JwtTokenWhereUniqueInput
  }

  /**
   * JwtToken deleteMany
   */
  export type JwtTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JwtTokens to delete
     */
    where?: JwtTokenWhereInput
    /**
     * Limit how many JwtTokens to delete.
     */
    limit?: number
  }

  /**
   * JwtToken without action
   */
  export type JwtTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JwtToken
     */
    select?: JwtTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JwtToken
     */
    omit?: JwtTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JwtTokenInclude<ExtArgs> | null
  }


  /**
   * Model ReportUser
   */

  export type AggregateReportUser = {
    _count: ReportUserCountAggregateOutputType | null
    _min: ReportUserMinAggregateOutputType | null
    _max: ReportUserMaxAggregateOutputType | null
  }

  export type ReportUserMinAggregateOutputType = {
    id: string | null
    youtubeLink: string | null
    demoLink: string | null
    comment: string | null
    authorId: string | null
    recipientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportUserMaxAggregateOutputType = {
    id: string | null
    youtubeLink: string | null
    demoLink: string | null
    comment: string | null
    authorId: string | null
    recipientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportUserCountAggregateOutputType = {
    id: number
    youtubeLink: number
    demoLink: number
    comment: number
    authorId: number
    recipientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportUserMinAggregateInputType = {
    id?: true
    youtubeLink?: true
    demoLink?: true
    comment?: true
    authorId?: true
    recipientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportUserMaxAggregateInputType = {
    id?: true
    youtubeLink?: true
    demoLink?: true
    comment?: true
    authorId?: true
    recipientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportUserCountAggregateInputType = {
    id?: true
    youtubeLink?: true
    demoLink?: true
    comment?: true
    authorId?: true
    recipientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportUser to aggregate.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportUsers
    **/
    _count?: true | ReportUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportUserMaxAggregateInputType
  }

  export type GetReportUserAggregateType<T extends ReportUserAggregateArgs> = {
        [P in keyof T & keyof AggregateReportUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportUser[P]>
      : GetScalarType<T[P], AggregateReportUser[P]>
  }




  export type ReportUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUserWhereInput
    orderBy?: ReportUserOrderByWithAggregationInput | ReportUserOrderByWithAggregationInput[]
    by: ReportUserScalarFieldEnum[] | ReportUserScalarFieldEnum
    having?: ReportUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportUserCountAggregateInputType | true
    _min?: ReportUserMinAggregateInputType
    _max?: ReportUserMaxAggregateInputType
  }

  export type ReportUserGroupByOutputType = {
    id: string
    youtubeLink: string
    demoLink: string | null
    comment: string | null
    authorId: string
    recipientId: string
    createdAt: Date
    updatedAt: Date
    _count: ReportUserCountAggregateOutputType | null
    _min: ReportUserMinAggregateOutputType | null
    _max: ReportUserMaxAggregateOutputType | null
  }

  type GetReportUserGroupByPayload<T extends ReportUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportUserGroupByOutputType[P]>
            : GetScalarType<T[P], ReportUserGroupByOutputType[P]>
        }
      >
    >


  export type ReportUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    youtubeLink?: boolean
    demoLink?: boolean
    comment?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
    verdicts?: boolean | ReportUser$verdictsArgs<ExtArgs>
    _count?: boolean | ReportUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportUser"]>

  export type ReportUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    youtubeLink?: boolean
    demoLink?: boolean
    comment?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportUser"]>

  export type ReportUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    youtubeLink?: boolean
    demoLink?: boolean
    comment?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportUser"]>

  export type ReportUserSelectScalar = {
    id?: boolean
    youtubeLink?: boolean
    demoLink?: boolean
    comment?: boolean
    authorId?: boolean
    recipientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "youtubeLink" | "demoLink" | "comment" | "authorId" | "recipientId" | "createdAt" | "updatedAt", ExtArgs["result"]["reportUser"]>
  export type ReportUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
    verdicts?: boolean | ReportUser$verdictsArgs<ExtArgs>
    _count?: boolean | ReportUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }
  export type ReportUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    recipient?: boolean | SteamUserDefaultArgs<ExtArgs>
  }

  export type $ReportUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportUser"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      recipient: Prisma.$SteamUserPayload<ExtArgs>
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      youtubeLink: string
      demoLink: string | null
      comment: string | null
      authorId: string
      recipientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportUser"]>
    composites: {}
  }

  type ReportUserGetPayload<S extends boolean | null | undefined | ReportUserDefaultArgs> = $Result.GetResult<Prisma.$ReportUserPayload, S>

  type ReportUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportUserCountAggregateInputType | true
    }

  export interface ReportUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportUser'], meta: { name: 'ReportUser' } }
    /**
     * Find zero or one ReportUser that matches the filter.
     * @param {ReportUserFindUniqueArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportUserFindUniqueArgs>(args: SelectSubset<T, ReportUserFindUniqueArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportUserFindUniqueOrThrowArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserFindFirstArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportUserFindFirstArgs>(args?: SelectSubset<T, ReportUserFindFirstArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserFindFirstOrThrowArgs} args - Arguments to find a ReportUser
     * @example
     * // Get one ReportUser
     * const reportUser = await prisma.reportUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportUsers
     * const reportUsers = await prisma.reportUser.findMany()
     * 
     * // Get first 10 ReportUsers
     * const reportUsers = await prisma.reportUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportUserWithIdOnly = await prisma.reportUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportUserFindManyArgs>(args?: SelectSubset<T, ReportUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportUser.
     * @param {ReportUserCreateArgs} args - Arguments to create a ReportUser.
     * @example
     * // Create one ReportUser
     * const ReportUser = await prisma.reportUser.create({
     *   data: {
     *     // ... data to create a ReportUser
     *   }
     * })
     * 
     */
    create<T extends ReportUserCreateArgs>(args: SelectSubset<T, ReportUserCreateArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportUsers.
     * @param {ReportUserCreateManyArgs} args - Arguments to create many ReportUsers.
     * @example
     * // Create many ReportUsers
     * const reportUser = await prisma.reportUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportUserCreateManyArgs>(args?: SelectSubset<T, ReportUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportUsers and returns the data saved in the database.
     * @param {ReportUserCreateManyAndReturnArgs} args - Arguments to create many ReportUsers.
     * @example
     * // Create many ReportUsers
     * const reportUser = await prisma.reportUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportUsers and only return the `id`
     * const reportUserWithIdOnly = await prisma.reportUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportUserCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportUser.
     * @param {ReportUserDeleteArgs} args - Arguments to delete one ReportUser.
     * @example
     * // Delete one ReportUser
     * const ReportUser = await prisma.reportUser.delete({
     *   where: {
     *     // ... filter to delete one ReportUser
     *   }
     * })
     * 
     */
    delete<T extends ReportUserDeleteArgs>(args: SelectSubset<T, ReportUserDeleteArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportUser.
     * @param {ReportUserUpdateArgs} args - Arguments to update one ReportUser.
     * @example
     * // Update one ReportUser
     * const reportUser = await prisma.reportUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUserUpdateArgs>(args: SelectSubset<T, ReportUserUpdateArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportUsers.
     * @param {ReportUserDeleteManyArgs} args - Arguments to filter ReportUsers to delete.
     * @example
     * // Delete a few ReportUsers
     * const { count } = await prisma.reportUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportUserDeleteManyArgs>(args?: SelectSubset<T, ReportUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportUsers
     * const reportUser = await prisma.reportUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUserUpdateManyArgs>(args: SelectSubset<T, ReportUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportUsers and returns the data updated in the database.
     * @param {ReportUserUpdateManyAndReturnArgs} args - Arguments to update many ReportUsers.
     * @example
     * // Update many ReportUsers
     * const reportUser = await prisma.reportUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportUsers and only return the `id`
     * const reportUserWithIdOnly = await prisma.reportUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUserUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportUser.
     * @param {ReportUserUpsertArgs} args - Arguments to update or create a ReportUser.
     * @example
     * // Update or create a ReportUser
     * const reportUser = await prisma.reportUser.upsert({
     *   create: {
     *     // ... data to create a ReportUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportUser we want to update
     *   }
     * })
     */
    upsert<T extends ReportUserUpsertArgs>(args: SelectSubset<T, ReportUserUpsertArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserCountArgs} args - Arguments to filter ReportUsers to count.
     * @example
     * // Count the number of ReportUsers
     * const count = await prisma.reportUser.count({
     *   where: {
     *     // ... the filter for the ReportUsers we want to count
     *   }
     * })
    **/
    count<T extends ReportUserCountArgs>(
      args?: Subset<T, ReportUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportUserAggregateArgs>(args: Subset<T, ReportUserAggregateArgs>): Prisma.PrismaPromise<GetReportUserAggregateType<T>>

    /**
     * Group by ReportUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportUserGroupByArgs['orderBy'] }
        : { orderBy?: ReportUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportUser model
   */
  readonly fields: ReportUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipient<T extends SteamUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SteamUserDefaultArgs<ExtArgs>>): Prisma__SteamUserClient<$Result.GetResult<Prisma.$SteamUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verdicts<T extends ReportUser$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, ReportUser$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportUser model
   */
  interface ReportUserFieldRefs {
    readonly id: FieldRef<"ReportUser", 'String'>
    readonly youtubeLink: FieldRef<"ReportUser", 'String'>
    readonly demoLink: FieldRef<"ReportUser", 'String'>
    readonly comment: FieldRef<"ReportUser", 'String'>
    readonly authorId: FieldRef<"ReportUser", 'String'>
    readonly recipientId: FieldRef<"ReportUser", 'String'>
    readonly createdAt: FieldRef<"ReportUser", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportUser findUnique
   */
  export type ReportUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser findUniqueOrThrow
   */
  export type ReportUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser findFirst
   */
  export type ReportUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportUsers.
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportUsers.
     */
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * ReportUser findFirstOrThrow
   */
  export type ReportUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUser to fetch.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportUsers.
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportUsers.
     */
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * ReportUser findMany
   */
  export type ReportUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter, which ReportUsers to fetch.
     */
    where?: ReportUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUsers to fetch.
     */
    orderBy?: ReportUserOrderByWithRelationInput | ReportUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportUsers.
     */
    cursor?: ReportUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUsers.
     */
    skip?: number
    distinct?: ReportUserScalarFieldEnum | ReportUserScalarFieldEnum[]
  }

  /**
   * ReportUser create
   */
  export type ReportUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportUser.
     */
    data: XOR<ReportUserCreateInput, ReportUserUncheckedCreateInput>
  }

  /**
   * ReportUser createMany
   */
  export type ReportUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportUsers.
     */
    data: ReportUserCreateManyInput | ReportUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportUser createManyAndReturn
   */
  export type ReportUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * The data used to create many ReportUsers.
     */
    data: ReportUserCreateManyInput | ReportUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportUser update
   */
  export type ReportUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportUser.
     */
    data: XOR<ReportUserUpdateInput, ReportUserUncheckedUpdateInput>
    /**
     * Choose, which ReportUser to update.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser updateMany
   */
  export type ReportUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportUsers.
     */
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyInput>
    /**
     * Filter which ReportUsers to update
     */
    where?: ReportUserWhereInput
    /**
     * Limit how many ReportUsers to update.
     */
    limit?: number
  }

  /**
   * ReportUser updateManyAndReturn
   */
  export type ReportUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * The data used to update ReportUsers.
     */
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyInput>
    /**
     * Filter which ReportUsers to update
     */
    where?: ReportUserWhereInput
    /**
     * Limit how many ReportUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportUser upsert
   */
  export type ReportUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportUser to update in case it exists.
     */
    where: ReportUserWhereUniqueInput
    /**
     * In case the ReportUser found by the `where` argument doesn't exist, create a new ReportUser with this data.
     */
    create: XOR<ReportUserCreateInput, ReportUserUncheckedCreateInput>
    /**
     * In case the ReportUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUserUpdateInput, ReportUserUncheckedUpdateInput>
  }

  /**
   * ReportUser delete
   */
  export type ReportUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
    /**
     * Filter which ReportUser to delete.
     */
    where: ReportUserWhereUniqueInput
  }

  /**
   * ReportUser deleteMany
   */
  export type ReportUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportUsers to delete
     */
    where?: ReportUserWhereInput
    /**
     * Limit how many ReportUsers to delete.
     */
    limit?: number
  }

  /**
   * ReportUser.verdicts
   */
  export type ReportUser$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * ReportUser without action
   */
  export type ReportUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUser
     */
    select?: ReportUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUser
     */
    omit?: ReportUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUserInclude<ExtArgs> | null
  }


  /**
   * Model Verdict
   */

  export type AggregateVerdict = {
    _count: VerdictCountAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  export type VerdictMinAggregateOutputType = {
    id: string | null
    userId: string | null
    reportId: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    reportId: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictCountAggregateOutputType = {
    id: number
    userId: number
    reportId: number
    verdicts: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerdictMinAggregateInputType = {
    id?: true
    userId?: true
    reportId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictMaxAggregateInputType = {
    id?: true
    userId?: true
    reportId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictCountAggregateInputType = {
    id?: true
    userId?: true
    reportId?: true
    verdicts?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerdictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdict to aggregate.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verdicts
    **/
    _count?: true | VerdictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictMaxAggregateInputType
  }

  export type GetVerdictAggregateType<T extends VerdictAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdict[P]>
      : GetScalarType<T[P], AggregateVerdict[P]>
  }




  export type VerdictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithAggregationInput | VerdictOrderByWithAggregationInput[]
    by: VerdictScalarFieldEnum[] | VerdictScalarFieldEnum
    having?: VerdictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictCountAggregateInputType | true
    _min?: VerdictMinAggregateInputType
    _max?: VerdictMaxAggregateInputType
  }

  export type VerdictGroupByOutputType = {
    id: string
    userId: string
    reportId: string
    verdicts: string[]
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: VerdictCountAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  type GetVerdictGroupByPayload<T extends VerdictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictGroupByOutputType[P]>
        }
      >
    >


  export type VerdictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportId?: boolean
    verdicts?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | ReportUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportId?: boolean
    verdicts?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | ReportUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportId?: boolean
    verdicts?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | ReportUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectScalar = {
    id?: boolean
    userId?: boolean
    reportId?: boolean
    verdicts?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerdictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "reportId" | "verdicts" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["verdict"]>
  export type VerdictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | ReportUserDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | ReportUserDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    report?: boolean | ReportUserDefaultArgs<ExtArgs>
  }

  export type $VerdictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verdict"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      report: Prisma.$ReportUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      reportId: string
      verdicts: string[]
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verdict"]>
    composites: {}
  }

  type VerdictGetPayload<S extends boolean | null | undefined | VerdictDefaultArgs> = $Result.GetResult<Prisma.$VerdictPayload, S>

  type VerdictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictCountAggregateInputType | true
    }

  export interface VerdictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verdict'], meta: { name: 'Verdict' } }
    /**
     * Find zero or one Verdict that matches the filter.
     * @param {VerdictFindUniqueArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictFindUniqueArgs>(args: SelectSubset<T, VerdictFindUniqueArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verdict that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictFindUniqueOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictFindFirstArgs>(args?: SelectSubset<T, VerdictFindFirstArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verdicts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verdicts
     * const verdicts = await prisma.verdict.findMany()
     * 
     * // Get first 10 Verdicts
     * const verdicts = await prisma.verdict.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictWithIdOnly = await prisma.verdict.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictFindManyArgs>(args?: SelectSubset<T, VerdictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verdict.
     * @param {VerdictCreateArgs} args - Arguments to create a Verdict.
     * @example
     * // Create one Verdict
     * const Verdict = await prisma.verdict.create({
     *   data: {
     *     // ... data to create a Verdict
     *   }
     * })
     * 
     */
    create<T extends VerdictCreateArgs>(args: SelectSubset<T, VerdictCreateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verdicts.
     * @param {VerdictCreateManyArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictCreateManyArgs>(args?: SelectSubset<T, VerdictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verdicts and returns the data saved in the database.
     * @param {VerdictCreateManyAndReturnArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verdict.
     * @param {VerdictDeleteArgs} args - Arguments to delete one Verdict.
     * @example
     * // Delete one Verdict
     * const Verdict = await prisma.verdict.delete({
     *   where: {
     *     // ... filter to delete one Verdict
     *   }
     * })
     * 
     */
    delete<T extends VerdictDeleteArgs>(args: SelectSubset<T, VerdictDeleteArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verdict.
     * @param {VerdictUpdateArgs} args - Arguments to update one Verdict.
     * @example
     * // Update one Verdict
     * const verdict = await prisma.verdict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictUpdateArgs>(args: SelectSubset<T, VerdictUpdateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verdicts.
     * @param {VerdictDeleteManyArgs} args - Arguments to filter Verdicts to delete.
     * @example
     * // Delete a few Verdicts
     * const { count } = await prisma.verdict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictDeleteManyArgs>(args?: SelectSubset<T, VerdictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictUpdateManyArgs>(args: SelectSubset<T, VerdictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts and returns the data updated in the database.
     * @param {VerdictUpdateManyAndReturnArgs} args - Arguments to update many Verdicts.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verdict.
     * @param {VerdictUpsertArgs} args - Arguments to update or create a Verdict.
     * @example
     * // Update or create a Verdict
     * const verdict = await prisma.verdict.upsert({
     *   create: {
     *     // ... data to create a Verdict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verdict we want to update
     *   }
     * })
     */
    upsert<T extends VerdictUpsertArgs>(args: SelectSubset<T, VerdictUpsertArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictCountArgs} args - Arguments to filter Verdicts to count.
     * @example
     * // Count the number of Verdicts
     * const count = await prisma.verdict.count({
     *   where: {
     *     // ... the filter for the Verdicts we want to count
     *   }
     * })
    **/
    count<T extends VerdictCountArgs>(
      args?: Subset<T, VerdictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictAggregateArgs>(args: Subset<T, VerdictAggregateArgs>): Prisma.PrismaPromise<GetVerdictAggregateType<T>>

    /**
     * Group by Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictGroupByArgs['orderBy'] }
        : { orderBy?: VerdictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verdict model
   */
  readonly fields: VerdictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verdict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    report<T extends ReportUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportUserDefaultArgs<ExtArgs>>): Prisma__ReportUserClient<$Result.GetResult<Prisma.$ReportUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verdict model
   */
  interface VerdictFieldRefs {
    readonly id: FieldRef<"Verdict", 'String'>
    readonly userId: FieldRef<"Verdict", 'String'>
    readonly reportId: FieldRef<"Verdict", 'String'>
    readonly verdicts: FieldRef<"Verdict", 'String[]'>
    readonly comment: FieldRef<"Verdict", 'String'>
    readonly createdAt: FieldRef<"Verdict", 'DateTime'>
    readonly updatedAt: FieldRef<"Verdict", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verdict findUnique
   */
  export type VerdictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findUniqueOrThrow
   */
  export type VerdictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findFirst
   */
  export type VerdictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findFirstOrThrow
   */
  export type VerdictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findMany
   */
  export type VerdictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdicts to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict create
   */
  export type VerdictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to create a Verdict.
     */
    data: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
  }

  /**
   * Verdict createMany
   */
  export type VerdictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verdict createManyAndReturn
   */
  export type VerdictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict update
   */
  export type VerdictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to update a Verdict.
     */
    data: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
    /**
     * Choose, which Verdict to update.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict updateMany
   */
  export type VerdictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
  }

  /**
   * Verdict updateManyAndReturn
   */
  export type VerdictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict upsert
   */
  export type VerdictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The filter to search for the Verdict to update in case it exists.
     */
    where: VerdictWhereUniqueInput
    /**
     * In case the Verdict found by the `where` argument doesn't exist, create a new Verdict with this data.
     */
    create: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
    /**
     * In case the Verdict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
  }

  /**
   * Verdict delete
   */
  export type VerdictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter which Verdict to delete.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict deleteMany
   */
  export type VerdictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdicts to delete
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to delete.
     */
    limit?: number
  }

  /**
   * Verdict without action
   */
  export type VerdictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    avatar: 'avatar',
    role: 'role',
    additionalRole: 'additionalRole',
    isEmailVerified: 'isEmailVerified',
    isBanned: 'isBanned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TrackingUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    steamid: 'steamid',
    dateBanned: 'dateBanned',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrackingUserScalarFieldEnum = (typeof TrackingUserScalarFieldEnum)[keyof typeof TrackingUserScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    description: 'description',
    isViewed: 'isViewed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    type: 'type',
    expiresIn: 'expiresIn',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const SteamUserScalarFieldEnum: {
    id: 'id',
    personaName: 'personaName',
    profileUrl: 'profileUrl',
    avatar: 'avatar',
    realname: 'realname',
    level: 'level',
    timeCreated: 'timeCreated',
    steamId2: 'steamId2',
    steamId3: 'steamId3',
    steamIdHex: 'steamIdHex',
    countryCode: 'countryCode',
    lastUpdateSteamInformation: 'lastUpdateSteamInformation',
    viewers: 'viewers',
    userId: 'userId',
    sharedCode: 'sharedCode',
    gameAuthenticationCode: 'gameAuthenticationCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SteamUserScalarFieldEnum = (typeof SteamUserScalarFieldEnum)[keyof typeof SteamUserScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    type: 'type',
    matchId: 'matchId',
    score: 'score',
    date: 'date',
    sharedCode: 'sharedCode',
    replay: 'replay',
    result: 'result',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const GeneralPlayerStatisticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type GeneralPlayerStatisticsScalarFieldEnum = (typeof GeneralPlayerStatisticsScalarFieldEnum)[keyof typeof GeneralPlayerStatisticsScalarFieldEnum]


  export const MapRanksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    playerId: 'playerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MapRanksScalarFieldEnum = (typeof MapRanksScalarFieldEnum)[keyof typeof MapRanksScalarFieldEnum]


  export const MapStatsScalarFieldEnum: {
    id: 'id',
    total_matches: 'total_matches',
    win_matches: 'win_matches',
    ct_total_rounds: 'ct_total_rounds',
    ct_win_rounds: 'ct_win_rounds',
    t_total_rounds: 't_total_rounds',
    t_win_rounds: 't_win_rounds',
    mapId: 'mapId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MapStatsScalarFieldEnum = (typeof MapStatsScalarFieldEnum)[keyof typeof MapStatsScalarFieldEnum]


  export const WeaponStatsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fire: 'fire',
    userId: 'userId'
  };

  export type WeaponStatsScalarFieldEnum = (typeof WeaponStatsScalarFieldEnum)[keyof typeof WeaponStatsScalarFieldEnum]


  export const HitScalarFieldEnum: {
    id: 'id',
    weaponId: 'weaponId',
    hitLocation: 'hitLocation',
    hits: 'hits',
    totalDamage: 'totalDamage',
    kills: 'kills'
  };

  export type HitScalarFieldEnum = (typeof HitScalarFieldEnum)[keyof typeof HitScalarFieldEnum]


  export const PlayerStatisticsInMatchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    matchId: 'matchId',
    kills_total: 'kills_total',
    deaths_total: 'deaths_total',
    assists_total: 'assists_total',
    headshot_kills_total: 'headshot_kills_total',
    ace_rounds_total: 'ace_rounds_total',
    k4_rounds_total: 'k4_rounds_total',
    k3_rounds_total: 'k3_rounds_total',
    k2_rounds_total: 'k2_rounds_total',
    damage_total: 'damage_total',
    objective_total: 'objective_total',
    utility_damage_total: 'utility_damage_total',
    mvps: 'mvps',
    crosshair_code: 'crosshair_code',
    player_color: 'player_color',
    rank_if_win: 'rank_if_win',
    rank: 'rank',
    rank_if_loss: 'rank_if_loss',
    rank_if_tie: 'rank_if_tie',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerStatisticsInMatchScalarFieldEnum = (typeof PlayerStatisticsInMatchScalarFieldEnum)[keyof typeof PlayerStatisticsInMatchScalarFieldEnum]


  export const SteamUserBansScalarFieldEnum: {
    id: 'id',
    communityBanned: 'communityBanned',
    daysSinceLastBan: 'daysSinceLastBan',
    economyBan: 'economyBan',
    gameBans: 'gameBans',
    vacBanned: 'vacBanned',
    vacBans: 'vacBans',
    csBan: 'csBan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SteamUserBansScalarFieldEnum = (typeof SteamUserBansScalarFieldEnum)[keyof typeof SteamUserBansScalarFieldEnum]


  export const LinksInProfileScalarFieldEnum: {
    id: 'id',
    tradeLink: 'tradeLink',
    twitch: 'twitch',
    youtube: 'youtube',
    telegram: 'telegram',
    discord: 'discord',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LinksInProfileScalarFieldEnum = (typeof LinksInProfileScalarFieldEnum)[keyof typeof LinksInProfileScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    authorId: 'authorId',
    recipientId: 'recipientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ImagesScalarFieldEnum: {
    id: 'id',
    url: 'url',
    commentId: 'commentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImagesScalarFieldEnum = (typeof ImagesScalarFieldEnum)[keyof typeof ImagesScalarFieldEnum]


  export const JwtTokenScalarFieldEnum: {
    id: 'id',
    refreshToken: 'refreshToken',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JwtTokenScalarFieldEnum = (typeof JwtTokenScalarFieldEnum)[keyof typeof JwtTokenScalarFieldEnum]


  export const ReportUserScalarFieldEnum: {
    id: 'id',
    youtubeLink: 'youtubeLink',
    demoLink: 'demoLink',
    comment: 'comment',
    authorId: 'authorId',
    recipientId: 'recipientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportUserScalarFieldEnum = (typeof ReportUserScalarFieldEnum)[keyof typeof ReportUserScalarFieldEnum]


  export const VerdictScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    reportId: 'reportId',
    verdicts: 'verdicts',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerdictScalarFieldEnum = (typeof VerdictScalarFieldEnum)[keyof typeof VerdictScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'AdditionalRole'
   */
  export type EnumAdditionalRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdditionalRole'>
    


  /**
   * Reference to a field of type 'AdditionalRole[]'
   */
  export type ListEnumAdditionalRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdditionalRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'TokenType'
   */
  export type EnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType'>
    


  /**
   * Reference to a field of type 'TokenType[]'
   */
  export type ListEnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MatchType'
   */
  export type EnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType'>
    


  /**
   * Reference to a field of type 'MatchType[]'
   */
  export type ListEnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFilter<"User"> | $Enums.AdditionalRole
    isEmailVerified?: BoolFilter<"User"> | boolean
    isBanned?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tokens?: TokenListRelationFilter
    notifications?: NotificationsListRelationFilter
    trackingUsers?: TrackingUserListRelationFilter
    links?: XOR<LinksInProfileNullableScalarRelationFilter, LinksInProfileWhereInput> | null
    steamUser?: XOR<SteamUserNullableScalarRelationFilter, SteamUserWhereInput> | null
    commentsAsAuthor?: CommentListRelationFilter
    jwtTokens?: JwtTokenListRelationFilter
    reportUsers?: ReportUserListRelationFilter
    verdicts?: VerdictListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    additionalRole?: SortOrder
    isEmailVerified?: SortOrder
    isBanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokens?: TokenOrderByRelationAggregateInput
    notifications?: NotificationsOrderByRelationAggregateInput
    trackingUsers?: TrackingUserOrderByRelationAggregateInput
    links?: LinksInProfileOrderByWithRelationInput
    steamUser?: SteamUserOrderByWithRelationInput
    commentsAsAuthor?: CommentOrderByRelationAggregateInput
    jwtTokens?: JwtTokenOrderByRelationAggregateInput
    reportUsers?: ReportUserOrderByRelationAggregateInput
    verdicts?: VerdictOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFilter<"User"> | $Enums.AdditionalRole
    isEmailVerified?: BoolFilter<"User"> | boolean
    isBanned?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tokens?: TokenListRelationFilter
    notifications?: NotificationsListRelationFilter
    trackingUsers?: TrackingUserListRelationFilter
    links?: XOR<LinksInProfileNullableScalarRelationFilter, LinksInProfileWhereInput> | null
    steamUser?: XOR<SteamUserNullableScalarRelationFilter, SteamUserWhereInput> | null
    commentsAsAuthor?: CommentListRelationFilter
    jwtTokens?: JwtTokenListRelationFilter
    reportUsers?: ReportUserListRelationFilter
    verdicts?: VerdictListRelationFilter
  }, "id" | "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    additionalRole?: SortOrder
    isEmailVerified?: SortOrder
    isBanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleWithAggregatesFilter<"User"> | $Enums.AdditionalRole
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type TrackingUserWhereInput = {
    AND?: TrackingUserWhereInput | TrackingUserWhereInput[]
    OR?: TrackingUserWhereInput[]
    NOT?: TrackingUserWhereInput | TrackingUserWhereInput[]
    id?: StringFilter<"TrackingUser"> | string
    userId?: StringFilter<"TrackingUser"> | string
    name?: StringFilter<"TrackingUser"> | string
    steamid?: StringFilter<"TrackingUser"> | string
    dateBanned?: DateTimeNullableFilter<"TrackingUser"> | Date | string | null
    avatar?: StringFilter<"TrackingUser"> | string
    createdAt?: DateTimeFilter<"TrackingUser"> | Date | string
    updatedAt?: DateTimeFilter<"TrackingUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TrackingUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    steamid?: SortOrder
    dateBanned?: SortOrderInput | SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TrackingUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrackingUserWhereInput | TrackingUserWhereInput[]
    OR?: TrackingUserWhereInput[]
    NOT?: TrackingUserWhereInput | TrackingUserWhereInput[]
    userId?: StringFilter<"TrackingUser"> | string
    name?: StringFilter<"TrackingUser"> | string
    steamid?: StringFilter<"TrackingUser"> | string
    dateBanned?: DateTimeNullableFilter<"TrackingUser"> | Date | string | null
    avatar?: StringFilter<"TrackingUser"> | string
    createdAt?: DateTimeFilter<"TrackingUser"> | Date | string
    updatedAt?: DateTimeFilter<"TrackingUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type TrackingUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    steamid?: SortOrder
    dateBanned?: SortOrderInput | SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrackingUserCountOrderByAggregateInput
    _max?: TrackingUserMaxOrderByAggregateInput
    _min?: TrackingUserMinOrderByAggregateInput
  }

  export type TrackingUserScalarWhereWithAggregatesInput = {
    AND?: TrackingUserScalarWhereWithAggregatesInput | TrackingUserScalarWhereWithAggregatesInput[]
    OR?: TrackingUserScalarWhereWithAggregatesInput[]
    NOT?: TrackingUserScalarWhereWithAggregatesInput | TrackingUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrackingUser"> | string
    userId?: StringWithAggregatesFilter<"TrackingUser"> | string
    name?: StringWithAggregatesFilter<"TrackingUser"> | string
    steamid?: StringWithAggregatesFilter<"TrackingUser"> | string
    dateBanned?: DateTimeNullableWithAggregatesFilter<"TrackingUser"> | Date | string | null
    avatar?: StringWithAggregatesFilter<"TrackingUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrackingUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrackingUser"> | Date | string
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: StringFilter<"Notifications"> | string
    userId?: StringFilter<"Notifications"> | string
    type?: EnumNotificationTypeFilter<"Notifications"> | $Enums.NotificationType
    title?: StringFilter<"Notifications"> | string
    description?: StringNullableFilter<"Notifications"> | string | null
    isViewed?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    userId?: StringFilter<"Notifications"> | string
    type?: EnumNotificationTypeFilter<"Notifications"> | $Enums.NotificationType
    title?: StringFilter<"Notifications"> | string
    description?: StringNullableFilter<"Notifications"> | string | null
    isViewed?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notifications"> | string
    userId?: StringWithAggregatesFilter<"Notifications"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notifications"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notifications"> | string
    description?: StringNullableWithAggregatesFilter<"Notifications"> | string | null
    isViewed?: BoolWithAggregatesFilter<"Notifications"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    token?: StringFilter<"Token"> | string
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    expiresIn?: DateTimeFilter<"Token"> | Date | string
    userId?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    expiresIn?: DateTimeFilter<"Token"> | Date | string
    userId?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    token?: StringWithAggregatesFilter<"Token"> | string
    type?: EnumTokenTypeWithAggregatesFilter<"Token"> | $Enums.TokenType
    expiresIn?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    userId?: StringWithAggregatesFilter<"Token"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
  }

  export type SteamUserWhereInput = {
    AND?: SteamUserWhereInput | SteamUserWhereInput[]
    OR?: SteamUserWhereInput[]
    NOT?: SteamUserWhereInput | SteamUserWhereInput[]
    id?: StringFilter<"SteamUser"> | string
    personaName?: StringFilter<"SteamUser"> | string
    profileUrl?: StringFilter<"SteamUser"> | string
    avatar?: StringFilter<"SteamUser"> | string
    realname?: StringNullableFilter<"SteamUser"> | string | null
    level?: StringNullableFilter<"SteamUser"> | string | null
    timeCreated?: StringFilter<"SteamUser"> | string
    steamId2?: StringNullableFilter<"SteamUser"> | string | null
    steamId3?: StringNullableFilter<"SteamUser"> | string | null
    steamIdHex?: StringNullableFilter<"SteamUser"> | string | null
    countryCode?: StringNullableFilter<"SteamUser"> | string | null
    lastUpdateSteamInformation?: DateTimeFilter<"SteamUser"> | Date | string
    viewers?: IntFilter<"SteamUser"> | number
    userId?: StringNullableFilter<"SteamUser"> | string | null
    sharedCode?: StringNullableFilter<"SteamUser"> | string | null
    gameAuthenticationCode?: StringNullableFilter<"SteamUser"> | string | null
    createdAt?: DateTimeFilter<"SteamUser"> | Date | string
    updatedAt?: DateTimeFilter<"SteamUser"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    steamUserBans?: XOR<SteamUserBansNullableScalarRelationFilter, SteamUserBansWhereInput> | null
    commentsAsRecipient?: CommentListRelationFilter
    reportsAsRecipient?: ReportUserListRelationFilter
    matches?: MatchListRelationFilter
    playerStatisticsInMatch?: PlayerStatisticsInMatchListRelationFilter
    generalPlayerStatistics?: XOR<GeneralPlayerStatisticsNullableScalarRelationFilter, GeneralPlayerStatisticsWhereInput> | null
  }

  export type SteamUserOrderByWithRelationInput = {
    id?: SortOrder
    personaName?: SortOrder
    profileUrl?: SortOrder
    avatar?: SortOrder
    realname?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timeCreated?: SortOrder
    steamId2?: SortOrderInput | SortOrder
    steamId3?: SortOrderInput | SortOrder
    steamIdHex?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    lastUpdateSteamInformation?: SortOrder
    viewers?: SortOrder
    userId?: SortOrderInput | SortOrder
    sharedCode?: SortOrderInput | SortOrder
    gameAuthenticationCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    steamUserBans?: SteamUserBansOrderByWithRelationInput
    commentsAsRecipient?: CommentOrderByRelationAggregateInput
    reportsAsRecipient?: ReportUserOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchOrderByRelationAggregateInput
    generalPlayerStatistics?: GeneralPlayerStatisticsOrderByWithRelationInput
  }

  export type SteamUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SteamUserWhereInput | SteamUserWhereInput[]
    OR?: SteamUserWhereInput[]
    NOT?: SteamUserWhereInput | SteamUserWhereInput[]
    personaName?: StringFilter<"SteamUser"> | string
    profileUrl?: StringFilter<"SteamUser"> | string
    avatar?: StringFilter<"SteamUser"> | string
    realname?: StringNullableFilter<"SteamUser"> | string | null
    level?: StringNullableFilter<"SteamUser"> | string | null
    timeCreated?: StringFilter<"SteamUser"> | string
    steamId2?: StringNullableFilter<"SteamUser"> | string | null
    steamId3?: StringNullableFilter<"SteamUser"> | string | null
    steamIdHex?: StringNullableFilter<"SteamUser"> | string | null
    countryCode?: StringNullableFilter<"SteamUser"> | string | null
    lastUpdateSteamInformation?: DateTimeFilter<"SteamUser"> | Date | string
    viewers?: IntFilter<"SteamUser"> | number
    sharedCode?: StringNullableFilter<"SteamUser"> | string | null
    gameAuthenticationCode?: StringNullableFilter<"SteamUser"> | string | null
    createdAt?: DateTimeFilter<"SteamUser"> | Date | string
    updatedAt?: DateTimeFilter<"SteamUser"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    steamUserBans?: XOR<SteamUserBansNullableScalarRelationFilter, SteamUserBansWhereInput> | null
    commentsAsRecipient?: CommentListRelationFilter
    reportsAsRecipient?: ReportUserListRelationFilter
    matches?: MatchListRelationFilter
    playerStatisticsInMatch?: PlayerStatisticsInMatchListRelationFilter
    generalPlayerStatistics?: XOR<GeneralPlayerStatisticsNullableScalarRelationFilter, GeneralPlayerStatisticsWhereInput> | null
  }, "id" | "id" | "userId">

  export type SteamUserOrderByWithAggregationInput = {
    id?: SortOrder
    personaName?: SortOrder
    profileUrl?: SortOrder
    avatar?: SortOrder
    realname?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    timeCreated?: SortOrder
    steamId2?: SortOrderInput | SortOrder
    steamId3?: SortOrderInput | SortOrder
    steamIdHex?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    lastUpdateSteamInformation?: SortOrder
    viewers?: SortOrder
    userId?: SortOrderInput | SortOrder
    sharedCode?: SortOrderInput | SortOrder
    gameAuthenticationCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SteamUserCountOrderByAggregateInput
    _avg?: SteamUserAvgOrderByAggregateInput
    _max?: SteamUserMaxOrderByAggregateInput
    _min?: SteamUserMinOrderByAggregateInput
    _sum?: SteamUserSumOrderByAggregateInput
  }

  export type SteamUserScalarWhereWithAggregatesInput = {
    AND?: SteamUserScalarWhereWithAggregatesInput | SteamUserScalarWhereWithAggregatesInput[]
    OR?: SteamUserScalarWhereWithAggregatesInput[]
    NOT?: SteamUserScalarWhereWithAggregatesInput | SteamUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SteamUser"> | string
    personaName?: StringWithAggregatesFilter<"SteamUser"> | string
    profileUrl?: StringWithAggregatesFilter<"SteamUser"> | string
    avatar?: StringWithAggregatesFilter<"SteamUser"> | string
    realname?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    level?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    timeCreated?: StringWithAggregatesFilter<"SteamUser"> | string
    steamId2?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    steamId3?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    steamIdHex?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    lastUpdateSteamInformation?: DateTimeWithAggregatesFilter<"SteamUser"> | Date | string
    viewers?: IntWithAggregatesFilter<"SteamUser"> | number
    userId?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    sharedCode?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    gameAuthenticationCode?: StringNullableWithAggregatesFilter<"SteamUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SteamUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SteamUser"> | Date | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: StringFilter<"Match"> | string
    type?: EnumMatchTypeFilter<"Match"> | $Enums.MatchType
    matchId?: StringFilter<"Match"> | string
    score?: StringFilter<"Match"> | string
    date?: DateTimeFilter<"Match"> | Date | string
    sharedCode?: StringFilter<"Match"> | string
    replay?: StringFilter<"Match"> | string
    result?: BoolFilter<"Match"> | boolean
    duration?: StringFilter<"Match"> | string
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    participants?: SteamUserListRelationFilter
    playersStatistic?: PlayerStatisticsInMatchListRelationFilter
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    matchId?: SortOrder
    score?: SortOrder
    date?: SortOrder
    sharedCode?: SortOrder
    replay?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: SteamUserOrderByRelationAggregateInput
    playersStatistic?: PlayerStatisticsInMatchOrderByRelationAggregateInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    matchId?: string
    sharedCode?: string
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    type?: EnumMatchTypeFilter<"Match"> | $Enums.MatchType
    score?: StringFilter<"Match"> | string
    date?: DateTimeFilter<"Match"> | Date | string
    replay?: StringFilter<"Match"> | string
    result?: BoolFilter<"Match"> | boolean
    duration?: StringFilter<"Match"> | string
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
    participants?: SteamUserListRelationFilter
    playersStatistic?: PlayerStatisticsInMatchListRelationFilter
  }, "id" | "id" | "matchId" | "sharedCode">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    matchId?: SortOrder
    score?: SortOrder
    date?: SortOrder
    sharedCode?: SortOrder
    replay?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Match"> | string
    type?: EnumMatchTypeWithAggregatesFilter<"Match"> | $Enums.MatchType
    matchId?: StringWithAggregatesFilter<"Match"> | string
    score?: StringWithAggregatesFilter<"Match"> | string
    date?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    sharedCode?: StringWithAggregatesFilter<"Match"> | string
    replay?: StringWithAggregatesFilter<"Match"> | string
    result?: BoolWithAggregatesFilter<"Match"> | boolean
    duration?: StringWithAggregatesFilter<"Match"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type GeneralPlayerStatisticsWhereInput = {
    AND?: GeneralPlayerStatisticsWhereInput | GeneralPlayerStatisticsWhereInput[]
    OR?: GeneralPlayerStatisticsWhereInput[]
    NOT?: GeneralPlayerStatisticsWhereInput | GeneralPlayerStatisticsWhereInput[]
    id?: StringFilter<"GeneralPlayerStatistics"> | string
    userId?: StringFilter<"GeneralPlayerStatistics"> | string
    steam?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
    MapRanks?: MapRanksListRelationFilter
    WeaponStats?: WeaponStatsListRelationFilter
  }

  export type GeneralPlayerStatisticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    steam?: SteamUserOrderByWithRelationInput
    MapRanks?: MapRanksOrderByRelationAggregateInput
    WeaponStats?: WeaponStatsOrderByRelationAggregateInput
  }

  export type GeneralPlayerStatisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GeneralPlayerStatisticsWhereInput | GeneralPlayerStatisticsWhereInput[]
    OR?: GeneralPlayerStatisticsWhereInput[]
    NOT?: GeneralPlayerStatisticsWhereInput | GeneralPlayerStatisticsWhereInput[]
    steam?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
    MapRanks?: MapRanksListRelationFilter
    WeaponStats?: WeaponStatsListRelationFilter
  }, "id" | "id" | "userId">

  export type GeneralPlayerStatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: GeneralPlayerStatisticsCountOrderByAggregateInput
    _max?: GeneralPlayerStatisticsMaxOrderByAggregateInput
    _min?: GeneralPlayerStatisticsMinOrderByAggregateInput
  }

  export type GeneralPlayerStatisticsScalarWhereWithAggregatesInput = {
    AND?: GeneralPlayerStatisticsScalarWhereWithAggregatesInput | GeneralPlayerStatisticsScalarWhereWithAggregatesInput[]
    OR?: GeneralPlayerStatisticsScalarWhereWithAggregatesInput[]
    NOT?: GeneralPlayerStatisticsScalarWhereWithAggregatesInput | GeneralPlayerStatisticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeneralPlayerStatistics"> | string
    userId?: StringWithAggregatesFilter<"GeneralPlayerStatistics"> | string
  }

  export type MapRanksWhereInput = {
    AND?: MapRanksWhereInput | MapRanksWhereInput[]
    OR?: MapRanksWhereInput[]
    NOT?: MapRanksWhereInput | MapRanksWhereInput[]
    id?: StringFilter<"MapRanks"> | string
    name?: StringFilter<"MapRanks"> | string
    playerId?: StringFilter<"MapRanks"> | string
    createdAt?: DateTimeFilter<"MapRanks"> | Date | string
    updatedAt?: DateTimeFilter<"MapRanks"> | Date | string
    mapStat?: MapStatsListRelationFilter
    generalPlayerStatistics?: XOR<GeneralPlayerStatisticsScalarRelationFilter, GeneralPlayerStatisticsWhereInput>
  }

  export type MapRanksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mapStat?: MapStatsOrderByRelationAggregateInput
    generalPlayerStatistics?: GeneralPlayerStatisticsOrderByWithRelationInput
  }

  export type MapRanksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MapRanksWhereInput | MapRanksWhereInput[]
    OR?: MapRanksWhereInput[]
    NOT?: MapRanksWhereInput | MapRanksWhereInput[]
    name?: StringFilter<"MapRanks"> | string
    playerId?: StringFilter<"MapRanks"> | string
    createdAt?: DateTimeFilter<"MapRanks"> | Date | string
    updatedAt?: DateTimeFilter<"MapRanks"> | Date | string
    mapStat?: MapStatsListRelationFilter
    generalPlayerStatistics?: XOR<GeneralPlayerStatisticsScalarRelationFilter, GeneralPlayerStatisticsWhereInput>
  }, "id" | "id">

  export type MapRanksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MapRanksCountOrderByAggregateInput
    _max?: MapRanksMaxOrderByAggregateInput
    _min?: MapRanksMinOrderByAggregateInput
  }

  export type MapRanksScalarWhereWithAggregatesInput = {
    AND?: MapRanksScalarWhereWithAggregatesInput | MapRanksScalarWhereWithAggregatesInput[]
    OR?: MapRanksScalarWhereWithAggregatesInput[]
    NOT?: MapRanksScalarWhereWithAggregatesInput | MapRanksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MapRanks"> | string
    name?: StringWithAggregatesFilter<"MapRanks"> | string
    playerId?: StringWithAggregatesFilter<"MapRanks"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MapRanks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MapRanks"> | Date | string
  }

  export type MapStatsWhereInput = {
    AND?: MapStatsWhereInput | MapStatsWhereInput[]
    OR?: MapStatsWhereInput[]
    NOT?: MapStatsWhereInput | MapStatsWhereInput[]
    id?: StringFilter<"MapStats"> | string
    total_matches?: IntFilter<"MapStats"> | number
    win_matches?: IntFilter<"MapStats"> | number
    ct_total_rounds?: IntFilter<"MapStats"> | number
    ct_win_rounds?: IntFilter<"MapStats"> | number
    t_total_rounds?: IntFilter<"MapStats"> | number
    t_win_rounds?: IntFilter<"MapStats"> | number
    mapId?: StringFilter<"MapStats"> | string
    createdAt?: DateTimeFilter<"MapStats"> | Date | string
    updatedAt?: DateTimeFilter<"MapStats"> | Date | string
    MapRanks?: XOR<MapRanksScalarRelationFilter, MapRanksWhereInput>
  }

  export type MapStatsOrderByWithRelationInput = {
    id?: SortOrder
    total_matches?: SortOrder
    win_matches?: SortOrder
    ct_total_rounds?: SortOrder
    ct_win_rounds?: SortOrder
    t_total_rounds?: SortOrder
    t_win_rounds?: SortOrder
    mapId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    MapRanks?: MapRanksOrderByWithRelationInput
  }

  export type MapStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MapStatsWhereInput | MapStatsWhereInput[]
    OR?: MapStatsWhereInput[]
    NOT?: MapStatsWhereInput | MapStatsWhereInput[]
    total_matches?: IntFilter<"MapStats"> | number
    win_matches?: IntFilter<"MapStats"> | number
    ct_total_rounds?: IntFilter<"MapStats"> | number
    ct_win_rounds?: IntFilter<"MapStats"> | number
    t_total_rounds?: IntFilter<"MapStats"> | number
    t_win_rounds?: IntFilter<"MapStats"> | number
    mapId?: StringFilter<"MapStats"> | string
    createdAt?: DateTimeFilter<"MapStats"> | Date | string
    updatedAt?: DateTimeFilter<"MapStats"> | Date | string
    MapRanks?: XOR<MapRanksScalarRelationFilter, MapRanksWhereInput>
  }, "id" | "id">

  export type MapStatsOrderByWithAggregationInput = {
    id?: SortOrder
    total_matches?: SortOrder
    win_matches?: SortOrder
    ct_total_rounds?: SortOrder
    ct_win_rounds?: SortOrder
    t_total_rounds?: SortOrder
    t_win_rounds?: SortOrder
    mapId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MapStatsCountOrderByAggregateInput
    _avg?: MapStatsAvgOrderByAggregateInput
    _max?: MapStatsMaxOrderByAggregateInput
    _min?: MapStatsMinOrderByAggregateInput
    _sum?: MapStatsSumOrderByAggregateInput
  }

  export type MapStatsScalarWhereWithAggregatesInput = {
    AND?: MapStatsScalarWhereWithAggregatesInput | MapStatsScalarWhereWithAggregatesInput[]
    OR?: MapStatsScalarWhereWithAggregatesInput[]
    NOT?: MapStatsScalarWhereWithAggregatesInput | MapStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MapStats"> | string
    total_matches?: IntWithAggregatesFilter<"MapStats"> | number
    win_matches?: IntWithAggregatesFilter<"MapStats"> | number
    ct_total_rounds?: IntWithAggregatesFilter<"MapStats"> | number
    ct_win_rounds?: IntWithAggregatesFilter<"MapStats"> | number
    t_total_rounds?: IntWithAggregatesFilter<"MapStats"> | number
    t_win_rounds?: IntWithAggregatesFilter<"MapStats"> | number
    mapId?: StringWithAggregatesFilter<"MapStats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MapStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MapStats"> | Date | string
  }

  export type WeaponStatsWhereInput = {
    AND?: WeaponStatsWhereInput | WeaponStatsWhereInput[]
    OR?: WeaponStatsWhereInput[]
    NOT?: WeaponStatsWhereInput | WeaponStatsWhereInput[]
    id?: StringFilter<"WeaponStats"> | string
    name?: StringFilter<"WeaponStats"> | string
    fire?: IntFilter<"WeaponStats"> | number
    userId?: StringFilter<"WeaponStats"> | string
    generalPlayerStatistics?: XOR<GeneralPlayerStatisticsScalarRelationFilter, GeneralPlayerStatisticsWhereInput>
    hits?: HitListRelationFilter
  }

  export type WeaponStatsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fire?: SortOrder
    userId?: SortOrder
    generalPlayerStatistics?: GeneralPlayerStatisticsOrderByWithRelationInput
    hits?: HitOrderByRelationAggregateInput
  }

  export type WeaponStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeaponStatsWhereInput | WeaponStatsWhereInput[]
    OR?: WeaponStatsWhereInput[]
    NOT?: WeaponStatsWhereInput | WeaponStatsWhereInput[]
    name?: StringFilter<"WeaponStats"> | string
    fire?: IntFilter<"WeaponStats"> | number
    userId?: StringFilter<"WeaponStats"> | string
    generalPlayerStatistics?: XOR<GeneralPlayerStatisticsScalarRelationFilter, GeneralPlayerStatisticsWhereInput>
    hits?: HitListRelationFilter
  }, "id">

  export type WeaponStatsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fire?: SortOrder
    userId?: SortOrder
    _count?: WeaponStatsCountOrderByAggregateInput
    _avg?: WeaponStatsAvgOrderByAggregateInput
    _max?: WeaponStatsMaxOrderByAggregateInput
    _min?: WeaponStatsMinOrderByAggregateInput
    _sum?: WeaponStatsSumOrderByAggregateInput
  }

  export type WeaponStatsScalarWhereWithAggregatesInput = {
    AND?: WeaponStatsScalarWhereWithAggregatesInput | WeaponStatsScalarWhereWithAggregatesInput[]
    OR?: WeaponStatsScalarWhereWithAggregatesInput[]
    NOT?: WeaponStatsScalarWhereWithAggregatesInput | WeaponStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeaponStats"> | string
    name?: StringWithAggregatesFilter<"WeaponStats"> | string
    fire?: IntWithAggregatesFilter<"WeaponStats"> | number
    userId?: StringWithAggregatesFilter<"WeaponStats"> | string
  }

  export type HitWhereInput = {
    AND?: HitWhereInput | HitWhereInput[]
    OR?: HitWhereInput[]
    NOT?: HitWhereInput | HitWhereInput[]
    id?: StringFilter<"Hit"> | string
    weaponId?: StringFilter<"Hit"> | string
    hitLocation?: StringFilter<"Hit"> | string
    hits?: IntFilter<"Hit"> | number
    totalDamage?: IntFilter<"Hit"> | number
    kills?: IntFilter<"Hit"> | number
    weapon?: XOR<WeaponStatsScalarRelationFilter, WeaponStatsWhereInput>
  }

  export type HitOrderByWithRelationInput = {
    id?: SortOrder
    weaponId?: SortOrder
    hitLocation?: SortOrder
    hits?: SortOrder
    totalDamage?: SortOrder
    kills?: SortOrder
    weapon?: WeaponStatsOrderByWithRelationInput
  }

  export type HitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HitWhereInput | HitWhereInput[]
    OR?: HitWhereInput[]
    NOT?: HitWhereInput | HitWhereInput[]
    weaponId?: StringFilter<"Hit"> | string
    hitLocation?: StringFilter<"Hit"> | string
    hits?: IntFilter<"Hit"> | number
    totalDamage?: IntFilter<"Hit"> | number
    kills?: IntFilter<"Hit"> | number
    weapon?: XOR<WeaponStatsScalarRelationFilter, WeaponStatsWhereInput>
  }, "id">

  export type HitOrderByWithAggregationInput = {
    id?: SortOrder
    weaponId?: SortOrder
    hitLocation?: SortOrder
    hits?: SortOrder
    totalDamage?: SortOrder
    kills?: SortOrder
    _count?: HitCountOrderByAggregateInput
    _avg?: HitAvgOrderByAggregateInput
    _max?: HitMaxOrderByAggregateInput
    _min?: HitMinOrderByAggregateInput
    _sum?: HitSumOrderByAggregateInput
  }

  export type HitScalarWhereWithAggregatesInput = {
    AND?: HitScalarWhereWithAggregatesInput | HitScalarWhereWithAggregatesInput[]
    OR?: HitScalarWhereWithAggregatesInput[]
    NOT?: HitScalarWhereWithAggregatesInput | HitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hit"> | string
    weaponId?: StringWithAggregatesFilter<"Hit"> | string
    hitLocation?: StringWithAggregatesFilter<"Hit"> | string
    hits?: IntWithAggregatesFilter<"Hit"> | number
    totalDamage?: IntWithAggregatesFilter<"Hit"> | number
    kills?: IntWithAggregatesFilter<"Hit"> | number
  }

  export type PlayerStatisticsInMatchWhereInput = {
    AND?: PlayerStatisticsInMatchWhereInput | PlayerStatisticsInMatchWhereInput[]
    OR?: PlayerStatisticsInMatchWhereInput[]
    NOT?: PlayerStatisticsInMatchWhereInput | PlayerStatisticsInMatchWhereInput[]
    id?: StringFilter<"PlayerStatisticsInMatch"> | string
    userId?: StringFilter<"PlayerStatisticsInMatch"> | string
    matchId?: StringFilter<"PlayerStatisticsInMatch"> | string
    kills_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    deaths_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    assists_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    headshot_kills_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    ace_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k4_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k3_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k2_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    damage_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    objective_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    utility_damage_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    mvps?: IntFilter<"PlayerStatisticsInMatch"> | number
    crosshair_code?: StringFilter<"PlayerStatisticsInMatch"> | string
    player_color?: StringFilter<"PlayerStatisticsInMatch"> | string
    rank_if_win?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank_if_loss?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank_if_tie?: IntFilter<"PlayerStatisticsInMatch"> | number
    createdAt?: DateTimeFilter<"PlayerStatisticsInMatch"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerStatisticsInMatch"> | Date | string
    steamUser?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
  }

  export type PlayerStatisticsInMatchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchId?: SortOrder
    kills_total?: SortOrder
    deaths_total?: SortOrder
    assists_total?: SortOrder
    headshot_kills_total?: SortOrder
    ace_rounds_total?: SortOrder
    k4_rounds_total?: SortOrder
    k3_rounds_total?: SortOrder
    k2_rounds_total?: SortOrder
    damage_total?: SortOrder
    objective_total?: SortOrder
    utility_damage_total?: SortOrder
    mvps?: SortOrder
    crosshair_code?: SortOrder
    player_color?: SortOrder
    rank_if_win?: SortOrder
    rank?: SortOrder
    rank_if_loss?: SortOrder
    rank_if_tie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    steamUser?: SteamUserOrderByWithRelationInput
    match?: MatchOrderByWithRelationInput
  }

  export type PlayerStatisticsInMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_matchId?: PlayerStatisticsInMatchUserIdMatchIdCompoundUniqueInput
    AND?: PlayerStatisticsInMatchWhereInput | PlayerStatisticsInMatchWhereInput[]
    OR?: PlayerStatisticsInMatchWhereInput[]
    NOT?: PlayerStatisticsInMatchWhereInput | PlayerStatisticsInMatchWhereInput[]
    userId?: StringFilter<"PlayerStatisticsInMatch"> | string
    matchId?: StringFilter<"PlayerStatisticsInMatch"> | string
    kills_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    deaths_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    assists_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    headshot_kills_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    ace_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k4_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k3_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k2_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    damage_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    objective_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    utility_damage_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    mvps?: IntFilter<"PlayerStatisticsInMatch"> | number
    crosshair_code?: StringFilter<"PlayerStatisticsInMatch"> | string
    player_color?: StringFilter<"PlayerStatisticsInMatch"> | string
    rank_if_win?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank_if_loss?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank_if_tie?: IntFilter<"PlayerStatisticsInMatch"> | number
    createdAt?: DateTimeFilter<"PlayerStatisticsInMatch"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerStatisticsInMatch"> | Date | string
    steamUser?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
  }, "id" | "userId_matchId">

  export type PlayerStatisticsInMatchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchId?: SortOrder
    kills_total?: SortOrder
    deaths_total?: SortOrder
    assists_total?: SortOrder
    headshot_kills_total?: SortOrder
    ace_rounds_total?: SortOrder
    k4_rounds_total?: SortOrder
    k3_rounds_total?: SortOrder
    k2_rounds_total?: SortOrder
    damage_total?: SortOrder
    objective_total?: SortOrder
    utility_damage_total?: SortOrder
    mvps?: SortOrder
    crosshair_code?: SortOrder
    player_color?: SortOrder
    rank_if_win?: SortOrder
    rank?: SortOrder
    rank_if_loss?: SortOrder
    rank_if_tie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerStatisticsInMatchCountOrderByAggregateInput
    _avg?: PlayerStatisticsInMatchAvgOrderByAggregateInput
    _max?: PlayerStatisticsInMatchMaxOrderByAggregateInput
    _min?: PlayerStatisticsInMatchMinOrderByAggregateInput
    _sum?: PlayerStatisticsInMatchSumOrderByAggregateInput
  }

  export type PlayerStatisticsInMatchScalarWhereWithAggregatesInput = {
    AND?: PlayerStatisticsInMatchScalarWhereWithAggregatesInput | PlayerStatisticsInMatchScalarWhereWithAggregatesInput[]
    OR?: PlayerStatisticsInMatchScalarWhereWithAggregatesInput[]
    NOT?: PlayerStatisticsInMatchScalarWhereWithAggregatesInput | PlayerStatisticsInMatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerStatisticsInMatch"> | string
    userId?: StringWithAggregatesFilter<"PlayerStatisticsInMatch"> | string
    matchId?: StringWithAggregatesFilter<"PlayerStatisticsInMatch"> | string
    kills_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    deaths_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    assists_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    headshot_kills_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    ace_rounds_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    k4_rounds_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    k3_rounds_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    k2_rounds_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    damage_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    objective_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    utility_damage_total?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    mvps?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    crosshair_code?: StringWithAggregatesFilter<"PlayerStatisticsInMatch"> | string
    player_color?: StringWithAggregatesFilter<"PlayerStatisticsInMatch"> | string
    rank_if_win?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    rank?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    rank_if_loss?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    rank_if_tie?: IntWithAggregatesFilter<"PlayerStatisticsInMatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlayerStatisticsInMatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerStatisticsInMatch"> | Date | string
  }

  export type SteamUserBansWhereInput = {
    AND?: SteamUserBansWhereInput | SteamUserBansWhereInput[]
    OR?: SteamUserBansWhereInput[]
    NOT?: SteamUserBansWhereInput | SteamUserBansWhereInput[]
    id?: StringFilter<"SteamUserBans"> | string
    communityBanned?: BoolNullableFilter<"SteamUserBans"> | boolean | null
    daysSinceLastBan?: IntNullableFilter<"SteamUserBans"> | number | null
    economyBan?: StringNullableFilter<"SteamUserBans"> | string | null
    gameBans?: IntNullableFilter<"SteamUserBans"> | number | null
    vacBanned?: BoolNullableFilter<"SteamUserBans"> | boolean | null
    vacBans?: IntNullableFilter<"SteamUserBans"> | number | null
    csBan?: BoolFilter<"SteamUserBans"> | boolean
    createdAt?: DateTimeFilter<"SteamUserBans"> | Date | string
    updatedAt?: DateTimeFilter<"SteamUserBans"> | Date | string
    steam?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
  }

  export type SteamUserBansOrderByWithRelationInput = {
    id?: SortOrder
    communityBanned?: SortOrderInput | SortOrder
    daysSinceLastBan?: SortOrderInput | SortOrder
    economyBan?: SortOrderInput | SortOrder
    gameBans?: SortOrderInput | SortOrder
    vacBanned?: SortOrderInput | SortOrder
    vacBans?: SortOrderInput | SortOrder
    csBan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    steam?: SteamUserOrderByWithRelationInput
  }

  export type SteamUserBansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SteamUserBansWhereInput | SteamUserBansWhereInput[]
    OR?: SteamUserBansWhereInput[]
    NOT?: SteamUserBansWhereInput | SteamUserBansWhereInput[]
    communityBanned?: BoolNullableFilter<"SteamUserBans"> | boolean | null
    daysSinceLastBan?: IntNullableFilter<"SteamUserBans"> | number | null
    economyBan?: StringNullableFilter<"SteamUserBans"> | string | null
    gameBans?: IntNullableFilter<"SteamUserBans"> | number | null
    vacBanned?: BoolNullableFilter<"SteamUserBans"> | boolean | null
    vacBans?: IntNullableFilter<"SteamUserBans"> | number | null
    csBan?: BoolFilter<"SteamUserBans"> | boolean
    createdAt?: DateTimeFilter<"SteamUserBans"> | Date | string
    updatedAt?: DateTimeFilter<"SteamUserBans"> | Date | string
    steam?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
  }, "id" | "id">

  export type SteamUserBansOrderByWithAggregationInput = {
    id?: SortOrder
    communityBanned?: SortOrderInput | SortOrder
    daysSinceLastBan?: SortOrderInput | SortOrder
    economyBan?: SortOrderInput | SortOrder
    gameBans?: SortOrderInput | SortOrder
    vacBanned?: SortOrderInput | SortOrder
    vacBans?: SortOrderInput | SortOrder
    csBan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SteamUserBansCountOrderByAggregateInput
    _avg?: SteamUserBansAvgOrderByAggregateInput
    _max?: SteamUserBansMaxOrderByAggregateInput
    _min?: SteamUserBansMinOrderByAggregateInput
    _sum?: SteamUserBansSumOrderByAggregateInput
  }

  export type SteamUserBansScalarWhereWithAggregatesInput = {
    AND?: SteamUserBansScalarWhereWithAggregatesInput | SteamUserBansScalarWhereWithAggregatesInput[]
    OR?: SteamUserBansScalarWhereWithAggregatesInput[]
    NOT?: SteamUserBansScalarWhereWithAggregatesInput | SteamUserBansScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SteamUserBans"> | string
    communityBanned?: BoolNullableWithAggregatesFilter<"SteamUserBans"> | boolean | null
    daysSinceLastBan?: IntNullableWithAggregatesFilter<"SteamUserBans"> | number | null
    economyBan?: StringNullableWithAggregatesFilter<"SteamUserBans"> | string | null
    gameBans?: IntNullableWithAggregatesFilter<"SteamUserBans"> | number | null
    vacBanned?: BoolNullableWithAggregatesFilter<"SteamUserBans"> | boolean | null
    vacBans?: IntNullableWithAggregatesFilter<"SteamUserBans"> | number | null
    csBan?: BoolWithAggregatesFilter<"SteamUserBans"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SteamUserBans"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SteamUserBans"> | Date | string
  }

  export type LinksInProfileWhereInput = {
    AND?: LinksInProfileWhereInput | LinksInProfileWhereInput[]
    OR?: LinksInProfileWhereInput[]
    NOT?: LinksInProfileWhereInput | LinksInProfileWhereInput[]
    id?: StringFilter<"LinksInProfile"> | string
    tradeLink?: StringNullableFilter<"LinksInProfile"> | string | null
    twitch?: StringNullableFilter<"LinksInProfile"> | string | null
    youtube?: StringNullableFilter<"LinksInProfile"> | string | null
    telegram?: StringNullableFilter<"LinksInProfile"> | string | null
    discord?: StringNullableFilter<"LinksInProfile"> | string | null
    createdAt?: DateTimeFilter<"LinksInProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LinksInProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LinksInProfileOrderByWithRelationInput = {
    id?: SortOrder
    tradeLink?: SortOrderInput | SortOrder
    twitch?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LinksInProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LinksInProfileWhereInput | LinksInProfileWhereInput[]
    OR?: LinksInProfileWhereInput[]
    NOT?: LinksInProfileWhereInput | LinksInProfileWhereInput[]
    tradeLink?: StringNullableFilter<"LinksInProfile"> | string | null
    twitch?: StringNullableFilter<"LinksInProfile"> | string | null
    youtube?: StringNullableFilter<"LinksInProfile"> | string | null
    telegram?: StringNullableFilter<"LinksInProfile"> | string | null
    discord?: StringNullableFilter<"LinksInProfile"> | string | null
    createdAt?: DateTimeFilter<"LinksInProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LinksInProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type LinksInProfileOrderByWithAggregationInput = {
    id?: SortOrder
    tradeLink?: SortOrderInput | SortOrder
    twitch?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LinksInProfileCountOrderByAggregateInput
    _max?: LinksInProfileMaxOrderByAggregateInput
    _min?: LinksInProfileMinOrderByAggregateInput
  }

  export type LinksInProfileScalarWhereWithAggregatesInput = {
    AND?: LinksInProfileScalarWhereWithAggregatesInput | LinksInProfileScalarWhereWithAggregatesInput[]
    OR?: LinksInProfileScalarWhereWithAggregatesInput[]
    NOT?: LinksInProfileScalarWhereWithAggregatesInput | LinksInProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinksInProfile"> | string
    tradeLink?: StringNullableWithAggregatesFilter<"LinksInProfile"> | string | null
    twitch?: StringNullableWithAggregatesFilter<"LinksInProfile"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"LinksInProfile"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"LinksInProfile"> | string | null
    discord?: StringNullableWithAggregatesFilter<"LinksInProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LinksInProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LinksInProfile"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    recipientId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    images?: ImagesListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: ImagesOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
    recipient?: SteamUserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    recipientId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    images?: ImagesListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
  }, "id" | "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    recipientId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type ImagesWhereInput = {
    AND?: ImagesWhereInput | ImagesWhereInput[]
    OR?: ImagesWhereInput[]
    NOT?: ImagesWhereInput | ImagesWhereInput[]
    id?: StringFilter<"Images"> | string
    url?: StringFilter<"Images"> | string
    commentId?: StringFilter<"Images"> | string
    createdAt?: DateTimeFilter<"Images"> | Date | string
    updatedAt?: DateTimeFilter<"Images"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
  }

  export type ImagesOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
  }

  export type ImagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImagesWhereInput | ImagesWhereInput[]
    OR?: ImagesWhereInput[]
    NOT?: ImagesWhereInput | ImagesWhereInput[]
    url?: StringFilter<"Images"> | string
    commentId?: StringFilter<"Images"> | string
    createdAt?: DateTimeFilter<"Images"> | Date | string
    updatedAt?: DateTimeFilter<"Images"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
  }, "id" | "id">

  export type ImagesOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImagesCountOrderByAggregateInput
    _max?: ImagesMaxOrderByAggregateInput
    _min?: ImagesMinOrderByAggregateInput
  }

  export type ImagesScalarWhereWithAggregatesInput = {
    AND?: ImagesScalarWhereWithAggregatesInput | ImagesScalarWhereWithAggregatesInput[]
    OR?: ImagesScalarWhereWithAggregatesInput[]
    NOT?: ImagesScalarWhereWithAggregatesInput | ImagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Images"> | string
    url?: StringWithAggregatesFilter<"Images"> | string
    commentId?: StringWithAggregatesFilter<"Images"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Images"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Images"> | Date | string
  }

  export type JwtTokenWhereInput = {
    AND?: JwtTokenWhereInput | JwtTokenWhereInput[]
    OR?: JwtTokenWhereInput[]
    NOT?: JwtTokenWhereInput | JwtTokenWhereInput[]
    id?: StringFilter<"JwtToken"> | string
    refreshToken?: StringFilter<"JwtToken"> | string
    userId?: StringFilter<"JwtToken"> | string
    createdAt?: DateTimeFilter<"JwtToken"> | Date | string
    updatedAt?: DateTimeFilter<"JwtToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JwtTokenOrderByWithRelationInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type JwtTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JwtTokenWhereInput | JwtTokenWhereInput[]
    OR?: JwtTokenWhereInput[]
    NOT?: JwtTokenWhereInput | JwtTokenWhereInput[]
    refreshToken?: StringFilter<"JwtToken"> | string
    userId?: StringFilter<"JwtToken"> | string
    createdAt?: DateTimeFilter<"JwtToken"> | Date | string
    updatedAt?: DateTimeFilter<"JwtToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id">

  export type JwtTokenOrderByWithAggregationInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JwtTokenCountOrderByAggregateInput
    _max?: JwtTokenMaxOrderByAggregateInput
    _min?: JwtTokenMinOrderByAggregateInput
  }

  export type JwtTokenScalarWhereWithAggregatesInput = {
    AND?: JwtTokenScalarWhereWithAggregatesInput | JwtTokenScalarWhereWithAggregatesInput[]
    OR?: JwtTokenScalarWhereWithAggregatesInput[]
    NOT?: JwtTokenScalarWhereWithAggregatesInput | JwtTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JwtToken"> | string
    refreshToken?: StringWithAggregatesFilter<"JwtToken"> | string
    userId?: StringWithAggregatesFilter<"JwtToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JwtToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JwtToken"> | Date | string
  }

  export type ReportUserWhereInput = {
    AND?: ReportUserWhereInput | ReportUserWhereInput[]
    OR?: ReportUserWhereInput[]
    NOT?: ReportUserWhereInput | ReportUserWhereInput[]
    id?: StringFilter<"ReportUser"> | string
    youtubeLink?: StringFilter<"ReportUser"> | string
    demoLink?: StringNullableFilter<"ReportUser"> | string | null
    comment?: StringNullableFilter<"ReportUser"> | string | null
    authorId?: StringFilter<"ReportUser"> | string
    recipientId?: StringFilter<"ReportUser"> | string
    createdAt?: DateTimeFilter<"ReportUser"> | Date | string
    updatedAt?: DateTimeFilter<"ReportUser"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
    verdicts?: VerdictListRelationFilter
  }

  export type ReportUserOrderByWithRelationInput = {
    id?: SortOrder
    youtubeLink?: SortOrder
    demoLink?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    recipient?: SteamUserOrderByWithRelationInput
    verdicts?: VerdictOrderByRelationAggregateInput
  }

  export type ReportUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    youtubeLink?: string
    authorId_recipientId?: ReportUserAuthorIdRecipientIdCompoundUniqueInput
    AND?: ReportUserWhereInput | ReportUserWhereInput[]
    OR?: ReportUserWhereInput[]
    NOT?: ReportUserWhereInput | ReportUserWhereInput[]
    demoLink?: StringNullableFilter<"ReportUser"> | string | null
    comment?: StringNullableFilter<"ReportUser"> | string | null
    authorId?: StringFilter<"ReportUser"> | string
    recipientId?: StringFilter<"ReportUser"> | string
    createdAt?: DateTimeFilter<"ReportUser"> | Date | string
    updatedAt?: DateTimeFilter<"ReportUser"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipient?: XOR<SteamUserScalarRelationFilter, SteamUserWhereInput>
    verdicts?: VerdictListRelationFilter
  }, "id" | "id" | "youtubeLink" | "authorId_recipientId">

  export type ReportUserOrderByWithAggregationInput = {
    id?: SortOrder
    youtubeLink?: SortOrder
    demoLink?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportUserCountOrderByAggregateInput
    _max?: ReportUserMaxOrderByAggregateInput
    _min?: ReportUserMinOrderByAggregateInput
  }

  export type ReportUserScalarWhereWithAggregatesInput = {
    AND?: ReportUserScalarWhereWithAggregatesInput | ReportUserScalarWhereWithAggregatesInput[]
    OR?: ReportUserScalarWhereWithAggregatesInput[]
    NOT?: ReportUserScalarWhereWithAggregatesInput | ReportUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportUser"> | string
    youtubeLink?: StringWithAggregatesFilter<"ReportUser"> | string
    demoLink?: StringNullableWithAggregatesFilter<"ReportUser"> | string | null
    comment?: StringNullableWithAggregatesFilter<"ReportUser"> | string | null
    authorId?: StringWithAggregatesFilter<"ReportUser"> | string
    recipientId?: StringWithAggregatesFilter<"ReportUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReportUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportUser"> | Date | string
  }

  export type VerdictWhereInput = {
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    id?: StringFilter<"Verdict"> | string
    userId?: StringFilter<"Verdict"> | string
    reportId?: StringFilter<"Verdict"> | string
    verdicts?: StringNullableListFilter<"Verdict">
    comment?: StringNullableFilter<"Verdict"> | string | null
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    report?: XOR<ReportUserScalarRelationFilter, ReportUserWhereInput>
  }

  export type VerdictOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    verdicts?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    report?: ReportUserOrderByWithRelationInput
  }

  export type VerdictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    userId?: StringFilter<"Verdict"> | string
    reportId?: StringFilter<"Verdict"> | string
    verdicts?: StringNullableListFilter<"Verdict">
    comment?: StringNullableFilter<"Verdict"> | string | null
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    report?: XOR<ReportUserScalarRelationFilter, ReportUserWhereInput>
  }, "id" | "id">

  export type VerdictOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    verdicts?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerdictCountOrderByAggregateInput
    _max?: VerdictMaxOrderByAggregateInput
    _min?: VerdictMinOrderByAggregateInput
  }

  export type VerdictScalarWhereWithAggregatesInput = {
    AND?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    OR?: VerdictScalarWhereWithAggregatesInput[]
    NOT?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verdict"> | string
    userId?: StringWithAggregatesFilter<"Verdict"> | string
    reportId?: StringWithAggregatesFilter<"Verdict"> | string
    verdicts?: StringNullableListFilter<"Verdict">
    comment?: StringNullableWithAggregatesFilter<"Verdict"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingUserCreateInput = {
    id?: string
    name: string
    steamid: string
    dateBanned?: Date | string | null
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTrackingUsersInput
  }

  export type TrackingUserUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    steamid: string
    dateBanned?: Date | string | null
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrackingUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steamid?: StringFieldUpdateOperationsInput | string
    dateBanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTrackingUsersNestedInput
  }

  export type TrackingUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steamid?: StringFieldUpdateOperationsInput | string
    dateBanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingUserCreateManyInput = {
    id?: string
    userId: string
    name: string
    steamid: string
    dateBanned?: Date | string | null
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrackingUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steamid?: StringFieldUpdateOperationsInput | string
    dateBanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steamid?: StringFieldUpdateOperationsInput | string
    dateBanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    isViewed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    isViewed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    isViewed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expiresIn: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expiresIn: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTokensNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expiresIn: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SteamUserCreateInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSteamUserInput
    steamUserBans?: SteamUserBansCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserCreateNestedManyWithoutRecipientInput
    matches?: MatchCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUncheckedCreateInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansUncheckedCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentUncheckedCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserUncheckedCreateNestedManyWithoutRecipientInput
    matches?: MatchUncheckedCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSteamUserNestedInput
    steamUserBans?: SteamUserBansUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUpdateManyWithoutRecipientNestedInput
    matches?: MatchUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUncheckedUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUncheckedUpdateManyWithoutRecipientNestedInput
    matches?: MatchUncheckedUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserCreateManyInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SteamUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SteamUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateInput = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date | string
    sharedCode: string
    replay: string
    result?: boolean
    duration: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: SteamUserCreateNestedManyWithoutMatchesInput
    playersStatistic?: PlayerStatisticsInMatchCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date | string
    sharedCode: string
    replay: string
    result?: boolean
    duration: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: SteamUserUncheckedCreateNestedManyWithoutMatchesInput
    playersStatistic?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: SteamUserUpdateManyWithoutMatchesNestedInput
    playersStatistic?: PlayerStatisticsInMatchUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: SteamUserUncheckedUpdateManyWithoutMatchesNestedInput
    playersStatistic?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchCreateManyInput = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date | string
    sharedCode: string
    replay: string
    result?: boolean
    duration: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneralPlayerStatisticsCreateInput = {
    id?: string
    steam: SteamUserCreateNestedOneWithoutGeneralPlayerStatisticsInput
    MapRanks?: MapRanksCreateNestedManyWithoutGeneralPlayerStatisticsInput
    WeaponStats?: WeaponStatsCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsUncheckedCreateInput = {
    id?: string
    userId: string
    MapRanks?: MapRanksUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput
    WeaponStats?: WeaponStatsUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    steam?: SteamUserUpdateOneRequiredWithoutGeneralPlayerStatisticsNestedInput
    MapRanks?: MapRanksUpdateManyWithoutGeneralPlayerStatisticsNestedInput
    WeaponStats?: WeaponStatsUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type GeneralPlayerStatisticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    MapRanks?: MapRanksUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput
    WeaponStats?: WeaponStatsUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type GeneralPlayerStatisticsCreateManyInput = {
    id?: string
    userId: string
  }

  export type GeneralPlayerStatisticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type GeneralPlayerStatisticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MapRanksCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mapStat?: MapStatsCreateNestedManyWithoutMapRanksInput
    generalPlayerStatistics: GeneralPlayerStatisticsCreateNestedOneWithoutMapRanksInput
  }

  export type MapRanksUncheckedCreateInput = {
    id?: string
    name: string
    playerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mapStat?: MapStatsUncheckedCreateNestedManyWithoutMapRanksInput
  }

  export type MapRanksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapStat?: MapStatsUpdateManyWithoutMapRanksNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneRequiredWithoutMapRanksNestedInput
  }

  export type MapRanksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapStat?: MapStatsUncheckedUpdateManyWithoutMapRanksNestedInput
  }

  export type MapRanksCreateManyInput = {
    id?: string
    name: string
    playerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapRanksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapRanksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapStatsCreateInput = {
    id?: string
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MapRanks: MapRanksCreateNestedOneWithoutMapStatInput
  }

  export type MapStatsUncheckedCreateInput = {
    id?: string
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    mapId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_matches?: IntFieldUpdateOperationsInput | number
    win_matches?: IntFieldUpdateOperationsInput | number
    ct_total_rounds?: IntFieldUpdateOperationsInput | number
    ct_win_rounds?: IntFieldUpdateOperationsInput | number
    t_total_rounds?: IntFieldUpdateOperationsInput | number
    t_win_rounds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MapRanks?: MapRanksUpdateOneRequiredWithoutMapStatNestedInput
  }

  export type MapStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_matches?: IntFieldUpdateOperationsInput | number
    win_matches?: IntFieldUpdateOperationsInput | number
    ct_total_rounds?: IntFieldUpdateOperationsInput | number
    ct_win_rounds?: IntFieldUpdateOperationsInput | number
    t_total_rounds?: IntFieldUpdateOperationsInput | number
    t_win_rounds?: IntFieldUpdateOperationsInput | number
    mapId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapStatsCreateManyInput = {
    id?: string
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    mapId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_matches?: IntFieldUpdateOperationsInput | number
    win_matches?: IntFieldUpdateOperationsInput | number
    ct_total_rounds?: IntFieldUpdateOperationsInput | number
    ct_win_rounds?: IntFieldUpdateOperationsInput | number
    t_total_rounds?: IntFieldUpdateOperationsInput | number
    t_win_rounds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_matches?: IntFieldUpdateOperationsInput | number
    win_matches?: IntFieldUpdateOperationsInput | number
    ct_total_rounds?: IntFieldUpdateOperationsInput | number
    ct_win_rounds?: IntFieldUpdateOperationsInput | number
    t_total_rounds?: IntFieldUpdateOperationsInput | number
    t_win_rounds?: IntFieldUpdateOperationsInput | number
    mapId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeaponStatsCreateInput = {
    id?: string
    name: string
    fire: number
    generalPlayerStatistics: GeneralPlayerStatisticsCreateNestedOneWithoutWeaponStatsInput
    hits?: HitCreateNestedManyWithoutWeaponInput
  }

  export type WeaponStatsUncheckedCreateInput = {
    id?: string
    name: string
    fire: number
    userId: string
    hits?: HitUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneRequiredWithoutWeaponStatsNestedInput
    hits?: HitUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    hits?: HitUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponStatsCreateManyInput = {
    id?: string
    name: string
    fire: number
    userId: string
  }

  export type WeaponStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
  }

  export type WeaponStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type HitCreateInput = {
    id?: string
    hitLocation: string
    hits: number
    totalDamage: number
    kills: number
    weapon: WeaponStatsCreateNestedOneWithoutHitsInput
  }

  export type HitUncheckedCreateInput = {
    id?: string
    weaponId: string
    hitLocation: string
    hits: number
    totalDamage: number
    kills: number
  }

  export type HitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hitLocation?: StringFieldUpdateOperationsInput | string
    hits?: IntFieldUpdateOperationsInput | number
    totalDamage?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
    weapon?: WeaponStatsUpdateOneRequiredWithoutHitsNestedInput
  }

  export type HitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weaponId?: StringFieldUpdateOperationsInput | string
    hitLocation?: StringFieldUpdateOperationsInput | string
    hits?: IntFieldUpdateOperationsInput | number
    totalDamage?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
  }

  export type HitCreateManyInput = {
    id?: string
    weaponId: string
    hitLocation: string
    hits: number
    totalDamage: number
    kills: number
  }

  export type HitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hitLocation?: StringFieldUpdateOperationsInput | string
    hits?: IntFieldUpdateOperationsInput | number
    totalDamage?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
  }

  export type HitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    weaponId?: StringFieldUpdateOperationsInput | string
    hitLocation?: StringFieldUpdateOperationsInput | string
    hits?: IntFieldUpdateOperationsInput | number
    totalDamage?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerStatisticsInMatchCreateInput = {
    id?: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUser: SteamUserCreateNestedOneWithoutPlayerStatisticsInMatchInput
    match: MatchCreateNestedOneWithoutPlayersStatisticInput
  }

  export type PlayerStatisticsInMatchUncheckedCreateInput = {
    id?: string
    userId: string
    matchId: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatisticsInMatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUser?: SteamUserUpdateOneRequiredWithoutPlayerStatisticsInMatchNestedInput
    match?: MatchUpdateOneRequiredWithoutPlayersStatisticNestedInput
  }

  export type PlayerStatisticsInMatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatisticsInMatchCreateManyInput = {
    id?: string
    userId: string
    matchId: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatisticsInMatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatisticsInMatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SteamUserBansCreateInput = {
    communityBanned?: boolean | null
    daysSinceLastBan?: number | null
    economyBan?: string | null
    gameBans?: number | null
    vacBanned?: boolean | null
    vacBans?: number | null
    csBan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steam: SteamUserCreateNestedOneWithoutSteamUserBansInput
  }

  export type SteamUserBansUncheckedCreateInput = {
    id: string
    communityBanned?: boolean | null
    daysSinceLastBan?: number | null
    economyBan?: string | null
    gameBans?: number | null
    vacBanned?: boolean | null
    vacBans?: number | null
    csBan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SteamUserBansUpdateInput = {
    communityBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysSinceLastBan?: NullableIntFieldUpdateOperationsInput | number | null
    economyBan?: NullableStringFieldUpdateOperationsInput | string | null
    gameBans?: NullableIntFieldUpdateOperationsInput | number | null
    vacBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vacBans?: NullableIntFieldUpdateOperationsInput | number | null
    csBan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steam?: SteamUserUpdateOneRequiredWithoutSteamUserBansNestedInput
  }

  export type SteamUserBansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysSinceLastBan?: NullableIntFieldUpdateOperationsInput | number | null
    economyBan?: NullableStringFieldUpdateOperationsInput | string | null
    gameBans?: NullableIntFieldUpdateOperationsInput | number | null
    vacBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vacBans?: NullableIntFieldUpdateOperationsInput | number | null
    csBan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SteamUserBansCreateManyInput = {
    id: string
    communityBanned?: boolean | null
    daysSinceLastBan?: number | null
    economyBan?: string | null
    gameBans?: number | null
    vacBanned?: boolean | null
    vacBans?: number | null
    csBan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SteamUserBansUpdateManyMutationInput = {
    communityBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysSinceLastBan?: NullableIntFieldUpdateOperationsInput | number | null
    economyBan?: NullableStringFieldUpdateOperationsInput | string | null
    gameBans?: NullableIntFieldUpdateOperationsInput | number | null
    vacBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vacBans?: NullableIntFieldUpdateOperationsInput | number | null
    csBan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SteamUserBansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysSinceLastBan?: NullableIntFieldUpdateOperationsInput | number | null
    economyBan?: NullableStringFieldUpdateOperationsInput | string | null
    gameBans?: NullableIntFieldUpdateOperationsInput | number | null
    vacBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vacBans?: NullableIntFieldUpdateOperationsInput | number | null
    csBan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinksInProfileCreateInput = {
    tradeLink?: string | null
    twitch?: string | null
    youtube?: string | null
    telegram?: string | null
    discord?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutLinksInput
  }

  export type LinksInProfileUncheckedCreateInput = {
    id?: string
    tradeLink?: string | null
    twitch?: string | null
    youtube?: string | null
    telegram?: string | null
    discord?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinksInProfileUpdateInput = {
    tradeLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinksNestedInput
  }

  export type LinksInProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinksInProfileCreateManyInput = {
    id?: string
    tradeLink?: string | null
    twitch?: string | null
    youtube?: string | null
    telegram?: string | null
    discord?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinksInProfileUpdateManyMutationInput = {
    tradeLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinksInProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImagesCreateNestedManyWithoutCommentInput
    author: UserCreateNestedOneWithoutCommentsAsAuthorInput
    recipient: SteamUserCreateNestedOneWithoutCommentsAsRecipientInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    authorId: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImagesUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImagesUpdateManyWithoutCommentNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsAsAuthorNestedInput
    recipient?: SteamUserUpdateOneRequiredWithoutCommentsAsRecipientNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImagesUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    authorId: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagesCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: CommentCreateNestedOneWithoutImagesInput
  }

  export type ImagesUncheckedCreateInput = {
    id?: string
    url: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagesCreateManyInput = {
    id?: string
    url: string
    commentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwtTokenCreateInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutJwtTokensInput
  }

  export type JwtTokenUncheckedCreateInput = {
    id?: string
    refreshToken: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JwtTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJwtTokensNestedInput
  }

  export type JwtTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwtTokenCreateManyInput = {
    id?: string
    refreshToken: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JwtTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwtTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserCreateInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutReportUsersInput
    recipient: SteamUserCreateNestedOneWithoutReportsAsRecipientInput
    verdicts?: VerdictCreateNestedManyWithoutReportInput
  }

  export type ReportUserUncheckedCreateInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    authorId: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    verdicts?: VerdictUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReportUsersNestedInput
    recipient?: SteamUserUpdateOneRequiredWithoutReportsAsRecipientNestedInput
    verdicts?: VerdictUpdateManyWithoutReportNestedInput
  }

  export type ReportUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdicts?: VerdictUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUserCreateManyInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    authorId: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictCreateInput = {
    id?: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVerdictsInput
    report: ReportUserCreateNestedOneWithoutVerdictsInput
  }

  export type VerdictUncheckedCreateInput = {
    id?: string
    userId: string
    reportId: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVerdictsNestedInput
    report?: ReportUserUpdateOneRequiredWithoutVerdictsNestedInput
  }

  export type VerdictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictCreateManyInput = {
    id?: string
    userId: string
    reportId: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumAdditionalRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdditionalRole | EnumAdditionalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdditionalRoleFilter<$PrismaModel> | $Enums.AdditionalRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type TrackingUserListRelationFilter = {
    every?: TrackingUserWhereInput
    some?: TrackingUserWhereInput
    none?: TrackingUserWhereInput
  }

  export type LinksInProfileNullableScalarRelationFilter = {
    is?: LinksInProfileWhereInput | null
    isNot?: LinksInProfileWhereInput | null
  }

  export type SteamUserNullableScalarRelationFilter = {
    is?: SteamUserWhereInput | null
    isNot?: SteamUserWhereInput | null
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type JwtTokenListRelationFilter = {
    every?: JwtTokenWhereInput
    some?: JwtTokenWhereInput
    none?: JwtTokenWhereInput
  }

  export type ReportUserListRelationFilter = {
    every?: ReportUserWhereInput
    some?: ReportUserWhereInput
    none?: ReportUserWhereInput
  }

  export type VerdictListRelationFilter = {
    every?: VerdictWhereInput
    some?: VerdictWhereInput
    none?: VerdictWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrackingUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JwtTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    additionalRole?: SortOrder
    isEmailVerified?: SortOrder
    isBanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    additionalRole?: SortOrder
    isEmailVerified?: SortOrder
    isBanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    additionalRole?: SortOrder
    isEmailVerified?: SortOrder
    isBanned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumAdditionalRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdditionalRole | EnumAdditionalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdditionalRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdditionalRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdditionalRoleFilter<$PrismaModel>
    _max?: NestedEnumAdditionalRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TrackingUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    steamid?: SortOrder
    dateBanned?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrackingUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    steamid?: SortOrder
    dateBanned?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrackingUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    steamid?: SortOrder
    dateBanned?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresIn?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SteamUserBansNullableScalarRelationFilter = {
    is?: SteamUserBansWhereInput | null
    isNot?: SteamUserBansWhereInput | null
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type PlayerStatisticsInMatchListRelationFilter = {
    every?: PlayerStatisticsInMatchWhereInput
    some?: PlayerStatisticsInMatchWhereInput
    none?: PlayerStatisticsInMatchWhereInput
  }

  export type GeneralPlayerStatisticsNullableScalarRelationFilter = {
    is?: GeneralPlayerStatisticsWhereInput | null
    isNot?: GeneralPlayerStatisticsWhereInput | null
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerStatisticsInMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SteamUserCountOrderByAggregateInput = {
    id?: SortOrder
    personaName?: SortOrder
    profileUrl?: SortOrder
    avatar?: SortOrder
    realname?: SortOrder
    level?: SortOrder
    timeCreated?: SortOrder
    steamId2?: SortOrder
    steamId3?: SortOrder
    steamIdHex?: SortOrder
    countryCode?: SortOrder
    lastUpdateSteamInformation?: SortOrder
    viewers?: SortOrder
    userId?: SortOrder
    sharedCode?: SortOrder
    gameAuthenticationCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SteamUserAvgOrderByAggregateInput = {
    viewers?: SortOrder
  }

  export type SteamUserMaxOrderByAggregateInput = {
    id?: SortOrder
    personaName?: SortOrder
    profileUrl?: SortOrder
    avatar?: SortOrder
    realname?: SortOrder
    level?: SortOrder
    timeCreated?: SortOrder
    steamId2?: SortOrder
    steamId3?: SortOrder
    steamIdHex?: SortOrder
    countryCode?: SortOrder
    lastUpdateSteamInformation?: SortOrder
    viewers?: SortOrder
    userId?: SortOrder
    sharedCode?: SortOrder
    gameAuthenticationCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SteamUserMinOrderByAggregateInput = {
    id?: SortOrder
    personaName?: SortOrder
    profileUrl?: SortOrder
    avatar?: SortOrder
    realname?: SortOrder
    level?: SortOrder
    timeCreated?: SortOrder
    steamId2?: SortOrder
    steamId3?: SortOrder
    steamIdHex?: SortOrder
    countryCode?: SortOrder
    lastUpdateSteamInformation?: SortOrder
    viewers?: SortOrder
    userId?: SortOrder
    sharedCode?: SortOrder
    gameAuthenticationCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SteamUserSumOrderByAggregateInput = {
    viewers?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeFilter<$PrismaModel> | $Enums.MatchType
  }

  export type SteamUserListRelationFilter = {
    every?: SteamUserWhereInput
    some?: SteamUserWhereInput
    none?: SteamUserWhereInput
  }

  export type SteamUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    matchId?: SortOrder
    score?: SortOrder
    date?: SortOrder
    sharedCode?: SortOrder
    replay?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    matchId?: SortOrder
    score?: SortOrder
    date?: SortOrder
    sharedCode?: SortOrder
    replay?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    matchId?: SortOrder
    score?: SortOrder
    date?: SortOrder
    sharedCode?: SortOrder
    replay?: SortOrder
    result?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchTypeFilter<$PrismaModel>
  }

  export type SteamUserScalarRelationFilter = {
    is?: SteamUserWhereInput
    isNot?: SteamUserWhereInput
  }

  export type MapRanksListRelationFilter = {
    every?: MapRanksWhereInput
    some?: MapRanksWhereInput
    none?: MapRanksWhereInput
  }

  export type WeaponStatsListRelationFilter = {
    every?: WeaponStatsWhereInput
    some?: WeaponStatsWhereInput
    none?: WeaponStatsWhereInput
  }

  export type MapRanksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeaponStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneralPlayerStatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type GeneralPlayerStatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type GeneralPlayerStatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MapStatsListRelationFilter = {
    every?: MapStatsWhereInput
    some?: MapStatsWhereInput
    none?: MapStatsWhereInput
  }

  export type GeneralPlayerStatisticsScalarRelationFilter = {
    is?: GeneralPlayerStatisticsWhereInput
    isNot?: GeneralPlayerStatisticsWhereInput
  }

  export type MapStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapRanksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapRanksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapRanksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    playerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapRanksScalarRelationFilter = {
    is?: MapRanksWhereInput
    isNot?: MapRanksWhereInput
  }

  export type MapStatsCountOrderByAggregateInput = {
    id?: SortOrder
    total_matches?: SortOrder
    win_matches?: SortOrder
    ct_total_rounds?: SortOrder
    ct_win_rounds?: SortOrder
    t_total_rounds?: SortOrder
    t_win_rounds?: SortOrder
    mapId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapStatsAvgOrderByAggregateInput = {
    total_matches?: SortOrder
    win_matches?: SortOrder
    ct_total_rounds?: SortOrder
    ct_win_rounds?: SortOrder
    t_total_rounds?: SortOrder
    t_win_rounds?: SortOrder
  }

  export type MapStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    total_matches?: SortOrder
    win_matches?: SortOrder
    ct_total_rounds?: SortOrder
    ct_win_rounds?: SortOrder
    t_total_rounds?: SortOrder
    t_win_rounds?: SortOrder
    mapId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapStatsMinOrderByAggregateInput = {
    id?: SortOrder
    total_matches?: SortOrder
    win_matches?: SortOrder
    ct_total_rounds?: SortOrder
    ct_win_rounds?: SortOrder
    t_total_rounds?: SortOrder
    t_win_rounds?: SortOrder
    mapId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapStatsSumOrderByAggregateInput = {
    total_matches?: SortOrder
    win_matches?: SortOrder
    ct_total_rounds?: SortOrder
    ct_win_rounds?: SortOrder
    t_total_rounds?: SortOrder
    t_win_rounds?: SortOrder
  }

  export type HitListRelationFilter = {
    every?: HitWhereInput
    some?: HitWhereInput
    none?: HitWhereInput
  }

  export type HitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeaponStatsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fire?: SortOrder
    userId?: SortOrder
  }

  export type WeaponStatsAvgOrderByAggregateInput = {
    fire?: SortOrder
  }

  export type WeaponStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fire?: SortOrder
    userId?: SortOrder
  }

  export type WeaponStatsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fire?: SortOrder
    userId?: SortOrder
  }

  export type WeaponStatsSumOrderByAggregateInput = {
    fire?: SortOrder
  }

  export type WeaponStatsScalarRelationFilter = {
    is?: WeaponStatsWhereInput
    isNot?: WeaponStatsWhereInput
  }

  export type HitCountOrderByAggregateInput = {
    id?: SortOrder
    weaponId?: SortOrder
    hitLocation?: SortOrder
    hits?: SortOrder
    totalDamage?: SortOrder
    kills?: SortOrder
  }

  export type HitAvgOrderByAggregateInput = {
    hits?: SortOrder
    totalDamage?: SortOrder
    kills?: SortOrder
  }

  export type HitMaxOrderByAggregateInput = {
    id?: SortOrder
    weaponId?: SortOrder
    hitLocation?: SortOrder
    hits?: SortOrder
    totalDamage?: SortOrder
    kills?: SortOrder
  }

  export type HitMinOrderByAggregateInput = {
    id?: SortOrder
    weaponId?: SortOrder
    hitLocation?: SortOrder
    hits?: SortOrder
    totalDamage?: SortOrder
    kills?: SortOrder
  }

  export type HitSumOrderByAggregateInput = {
    hits?: SortOrder
    totalDamage?: SortOrder
    kills?: SortOrder
  }

  export type MatchScalarRelationFilter = {
    is?: MatchWhereInput
    isNot?: MatchWhereInput
  }

  export type PlayerStatisticsInMatchUserIdMatchIdCompoundUniqueInput = {
    userId: string
    matchId: string
  }

  export type PlayerStatisticsInMatchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchId?: SortOrder
    kills_total?: SortOrder
    deaths_total?: SortOrder
    assists_total?: SortOrder
    headshot_kills_total?: SortOrder
    ace_rounds_total?: SortOrder
    k4_rounds_total?: SortOrder
    k3_rounds_total?: SortOrder
    k2_rounds_total?: SortOrder
    damage_total?: SortOrder
    objective_total?: SortOrder
    utility_damage_total?: SortOrder
    mvps?: SortOrder
    crosshair_code?: SortOrder
    player_color?: SortOrder
    rank_if_win?: SortOrder
    rank?: SortOrder
    rank_if_loss?: SortOrder
    rank_if_tie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatisticsInMatchAvgOrderByAggregateInput = {
    kills_total?: SortOrder
    deaths_total?: SortOrder
    assists_total?: SortOrder
    headshot_kills_total?: SortOrder
    ace_rounds_total?: SortOrder
    k4_rounds_total?: SortOrder
    k3_rounds_total?: SortOrder
    k2_rounds_total?: SortOrder
    damage_total?: SortOrder
    objective_total?: SortOrder
    utility_damage_total?: SortOrder
    mvps?: SortOrder
    rank_if_win?: SortOrder
    rank?: SortOrder
    rank_if_loss?: SortOrder
    rank_if_tie?: SortOrder
  }

  export type PlayerStatisticsInMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchId?: SortOrder
    kills_total?: SortOrder
    deaths_total?: SortOrder
    assists_total?: SortOrder
    headshot_kills_total?: SortOrder
    ace_rounds_total?: SortOrder
    k4_rounds_total?: SortOrder
    k3_rounds_total?: SortOrder
    k2_rounds_total?: SortOrder
    damage_total?: SortOrder
    objective_total?: SortOrder
    utility_damage_total?: SortOrder
    mvps?: SortOrder
    crosshair_code?: SortOrder
    player_color?: SortOrder
    rank_if_win?: SortOrder
    rank?: SortOrder
    rank_if_loss?: SortOrder
    rank_if_tie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatisticsInMatchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchId?: SortOrder
    kills_total?: SortOrder
    deaths_total?: SortOrder
    assists_total?: SortOrder
    headshot_kills_total?: SortOrder
    ace_rounds_total?: SortOrder
    k4_rounds_total?: SortOrder
    k3_rounds_total?: SortOrder
    k2_rounds_total?: SortOrder
    damage_total?: SortOrder
    objective_total?: SortOrder
    utility_damage_total?: SortOrder
    mvps?: SortOrder
    crosshair_code?: SortOrder
    player_color?: SortOrder
    rank_if_win?: SortOrder
    rank?: SortOrder
    rank_if_loss?: SortOrder
    rank_if_tie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerStatisticsInMatchSumOrderByAggregateInput = {
    kills_total?: SortOrder
    deaths_total?: SortOrder
    assists_total?: SortOrder
    headshot_kills_total?: SortOrder
    ace_rounds_total?: SortOrder
    k4_rounds_total?: SortOrder
    k3_rounds_total?: SortOrder
    k2_rounds_total?: SortOrder
    damage_total?: SortOrder
    objective_total?: SortOrder
    utility_damage_total?: SortOrder
    mvps?: SortOrder
    rank_if_win?: SortOrder
    rank?: SortOrder
    rank_if_loss?: SortOrder
    rank_if_tie?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SteamUserBansCountOrderByAggregateInput = {
    id?: SortOrder
    communityBanned?: SortOrder
    daysSinceLastBan?: SortOrder
    economyBan?: SortOrder
    gameBans?: SortOrder
    vacBanned?: SortOrder
    vacBans?: SortOrder
    csBan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SteamUserBansAvgOrderByAggregateInput = {
    daysSinceLastBan?: SortOrder
    gameBans?: SortOrder
    vacBans?: SortOrder
  }

  export type SteamUserBansMaxOrderByAggregateInput = {
    id?: SortOrder
    communityBanned?: SortOrder
    daysSinceLastBan?: SortOrder
    economyBan?: SortOrder
    gameBans?: SortOrder
    vacBanned?: SortOrder
    vacBans?: SortOrder
    csBan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SteamUserBansMinOrderByAggregateInput = {
    id?: SortOrder
    communityBanned?: SortOrder
    daysSinceLastBan?: SortOrder
    economyBan?: SortOrder
    gameBans?: SortOrder
    vacBanned?: SortOrder
    vacBans?: SortOrder
    csBan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SteamUserBansSumOrderByAggregateInput = {
    daysSinceLastBan?: SortOrder
    gameBans?: SortOrder
    vacBans?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LinksInProfileCountOrderByAggregateInput = {
    id?: SortOrder
    tradeLink?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    telegram?: SortOrder
    discord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinksInProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    tradeLink?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    telegram?: SortOrder
    discord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinksInProfileMinOrderByAggregateInput = {
    id?: SortOrder
    tradeLink?: SortOrder
    twitch?: SortOrder
    youtube?: SortOrder
    telegram?: SortOrder
    discord?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagesListRelationFilter = {
    every?: ImagesWhereInput
    some?: ImagesWhereInput
    none?: ImagesWhereInput
  }

  export type ImagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type ImagesCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagesMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImagesMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JwtTokenCountOrderByAggregateInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JwtTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JwtTokenMinOrderByAggregateInput = {
    id?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportUserAuthorIdRecipientIdCompoundUniqueInput = {
    authorId: string
    recipientId: string
  }

  export type ReportUserCountOrderByAggregateInput = {
    id?: SortOrder
    youtubeLink?: SortOrder
    demoLink?: SortOrder
    comment?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportUserMaxOrderByAggregateInput = {
    id?: SortOrder
    youtubeLink?: SortOrder
    demoLink?: SortOrder
    comment?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportUserMinOrderByAggregateInput = {
    id?: SortOrder
    youtubeLink?: SortOrder
    demoLink?: SortOrder
    comment?: SortOrder
    authorId?: SortOrder
    recipientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ReportUserScalarRelationFilter = {
    is?: ReportUserWhereInput
    isNot?: ReportUserWhereInput
  }

  export type VerdictCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    verdicts?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type TrackingUserCreateNestedManyWithoutUserInput = {
    create?: XOR<TrackingUserCreateWithoutUserInput, TrackingUserUncheckedCreateWithoutUserInput> | TrackingUserCreateWithoutUserInput[] | TrackingUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackingUserCreateOrConnectWithoutUserInput | TrackingUserCreateOrConnectWithoutUserInput[]
    createMany?: TrackingUserCreateManyUserInputEnvelope
    connect?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
  }

  export type LinksInProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<LinksInProfileCreateWithoutUserInput, LinksInProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LinksInProfileCreateOrConnectWithoutUserInput
    connect?: LinksInProfileWhereUniqueInput
  }

  export type SteamUserCreateNestedOneWithoutUserInput = {
    create?: XOR<SteamUserCreateWithoutUserInput, SteamUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutUserInput
    connect?: SteamUserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type JwtTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<JwtTokenCreateWithoutUserInput, JwtTokenUncheckedCreateWithoutUserInput> | JwtTokenCreateWithoutUserInput[] | JwtTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JwtTokenCreateOrConnectWithoutUserInput | JwtTokenCreateOrConnectWithoutUserInput[]
    createMany?: JwtTokenCreateManyUserInputEnvelope
    connect?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
  }

  export type ReportUserCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReportUserCreateWithoutAuthorInput, ReportUserUncheckedCreateWithoutAuthorInput> | ReportUserCreateWithoutAuthorInput[] | ReportUserUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutAuthorInput | ReportUserCreateOrConnectWithoutAuthorInput[]
    createMany?: ReportUserCreateManyAuthorInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutUserInput = {
    create?: XOR<VerdictCreateWithoutUserInput, VerdictUncheckedCreateWithoutUserInput> | VerdictCreateWithoutUserInput[] | VerdictUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutUserInput | VerdictCreateOrConnectWithoutUserInput[]
    createMany?: VerdictCreateManyUserInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type TrackingUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrackingUserCreateWithoutUserInput, TrackingUserUncheckedCreateWithoutUserInput> | TrackingUserCreateWithoutUserInput[] | TrackingUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackingUserCreateOrConnectWithoutUserInput | TrackingUserCreateOrConnectWithoutUserInput[]
    createMany?: TrackingUserCreateManyUserInputEnvelope
    connect?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
  }

  export type LinksInProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LinksInProfileCreateWithoutUserInput, LinksInProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LinksInProfileCreateOrConnectWithoutUserInput
    connect?: LinksInProfileWhereUniqueInput
  }

  export type SteamUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SteamUserCreateWithoutUserInput, SteamUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutUserInput
    connect?: SteamUserWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type JwtTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JwtTokenCreateWithoutUserInput, JwtTokenUncheckedCreateWithoutUserInput> | JwtTokenCreateWithoutUserInput[] | JwtTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JwtTokenCreateOrConnectWithoutUserInput | JwtTokenCreateOrConnectWithoutUserInput[]
    createMany?: JwtTokenCreateManyUserInputEnvelope
    connect?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
  }

  export type ReportUserUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReportUserCreateWithoutAuthorInput, ReportUserUncheckedCreateWithoutAuthorInput> | ReportUserCreateWithoutAuthorInput[] | ReportUserUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutAuthorInput | ReportUserCreateOrConnectWithoutAuthorInput[]
    createMany?: ReportUserCreateManyAuthorInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerdictCreateWithoutUserInput, VerdictUncheckedCreateWithoutUserInput> | VerdictCreateWithoutUserInput[] | VerdictUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutUserInput | VerdictCreateOrConnectWithoutUserInput[]
    createMany?: VerdictCreateManyUserInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumAdditionalRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdditionalRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type TrackingUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrackingUserCreateWithoutUserInput, TrackingUserUncheckedCreateWithoutUserInput> | TrackingUserCreateWithoutUserInput[] | TrackingUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackingUserCreateOrConnectWithoutUserInput | TrackingUserCreateOrConnectWithoutUserInput[]
    upsert?: TrackingUserUpsertWithWhereUniqueWithoutUserInput | TrackingUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrackingUserCreateManyUserInputEnvelope
    set?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    disconnect?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    delete?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    connect?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    update?: TrackingUserUpdateWithWhereUniqueWithoutUserInput | TrackingUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrackingUserUpdateManyWithWhereWithoutUserInput | TrackingUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrackingUserScalarWhereInput | TrackingUserScalarWhereInput[]
  }

  export type LinksInProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<LinksInProfileCreateWithoutUserInput, LinksInProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LinksInProfileCreateOrConnectWithoutUserInput
    upsert?: LinksInProfileUpsertWithoutUserInput
    disconnect?: LinksInProfileWhereInput | boolean
    delete?: LinksInProfileWhereInput | boolean
    connect?: LinksInProfileWhereUniqueInput
    update?: XOR<XOR<LinksInProfileUpdateToOneWithWhereWithoutUserInput, LinksInProfileUpdateWithoutUserInput>, LinksInProfileUncheckedUpdateWithoutUserInput>
  }

  export type SteamUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<SteamUserCreateWithoutUserInput, SteamUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutUserInput
    upsert?: SteamUserUpsertWithoutUserInput
    disconnect?: SteamUserWhereInput | boolean
    delete?: SteamUserWhereInput | boolean
    connect?: SteamUserWhereUniqueInput
    update?: XOR<XOR<SteamUserUpdateToOneWithWhereWithoutUserInput, SteamUserUpdateWithoutUserInput>, SteamUserUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type JwtTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<JwtTokenCreateWithoutUserInput, JwtTokenUncheckedCreateWithoutUserInput> | JwtTokenCreateWithoutUserInput[] | JwtTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JwtTokenCreateOrConnectWithoutUserInput | JwtTokenCreateOrConnectWithoutUserInput[]
    upsert?: JwtTokenUpsertWithWhereUniqueWithoutUserInput | JwtTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JwtTokenCreateManyUserInputEnvelope
    set?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    disconnect?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    delete?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    connect?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    update?: JwtTokenUpdateWithWhereUniqueWithoutUserInput | JwtTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JwtTokenUpdateManyWithWhereWithoutUserInput | JwtTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JwtTokenScalarWhereInput | JwtTokenScalarWhereInput[]
  }

  export type ReportUserUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReportUserCreateWithoutAuthorInput, ReportUserUncheckedCreateWithoutAuthorInput> | ReportUserCreateWithoutAuthorInput[] | ReportUserUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutAuthorInput | ReportUserCreateOrConnectWithoutAuthorInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutAuthorInput | ReportUserUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReportUserCreateManyAuthorInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutAuthorInput | ReportUserUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutAuthorInput | ReportUserUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerdictCreateWithoutUserInput, VerdictUncheckedCreateWithoutUserInput> | VerdictCreateWithoutUserInput[] | VerdictUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutUserInput | VerdictCreateOrConnectWithoutUserInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutUserInput | VerdictUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerdictCreateManyUserInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutUserInput | VerdictUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutUserInput | VerdictUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput> | NotificationsCreateWithoutUserInput[] | NotificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUserInput | NotificationsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUserInput | NotificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationsCreateManyUserInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUserInput | NotificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUserInput | NotificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type TrackingUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrackingUserCreateWithoutUserInput, TrackingUserUncheckedCreateWithoutUserInput> | TrackingUserCreateWithoutUserInput[] | TrackingUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrackingUserCreateOrConnectWithoutUserInput | TrackingUserCreateOrConnectWithoutUserInput[]
    upsert?: TrackingUserUpsertWithWhereUniqueWithoutUserInput | TrackingUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrackingUserCreateManyUserInputEnvelope
    set?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    disconnect?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    delete?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    connect?: TrackingUserWhereUniqueInput | TrackingUserWhereUniqueInput[]
    update?: TrackingUserUpdateWithWhereUniqueWithoutUserInput | TrackingUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrackingUserUpdateManyWithWhereWithoutUserInput | TrackingUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrackingUserScalarWhereInput | TrackingUserScalarWhereInput[]
  }

  export type LinksInProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LinksInProfileCreateWithoutUserInput, LinksInProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: LinksInProfileCreateOrConnectWithoutUserInput
    upsert?: LinksInProfileUpsertWithoutUserInput
    disconnect?: LinksInProfileWhereInput | boolean
    delete?: LinksInProfileWhereInput | boolean
    connect?: LinksInProfileWhereUniqueInput
    update?: XOR<XOR<LinksInProfileUpdateToOneWithWhereWithoutUserInput, LinksInProfileUpdateWithoutUserInput>, LinksInProfileUncheckedUpdateWithoutUserInput>
  }

  export type SteamUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SteamUserCreateWithoutUserInput, SteamUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutUserInput
    upsert?: SteamUserUpsertWithoutUserInput
    disconnect?: SteamUserWhereInput | boolean
    delete?: SteamUserWhereInput | boolean
    connect?: SteamUserWhereUniqueInput
    update?: XOR<XOR<SteamUserUpdateToOneWithWhereWithoutUserInput, SteamUserUpdateWithoutUserInput>, SteamUserUncheckedUpdateWithoutUserInput>
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type JwtTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JwtTokenCreateWithoutUserInput, JwtTokenUncheckedCreateWithoutUserInput> | JwtTokenCreateWithoutUserInput[] | JwtTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JwtTokenCreateOrConnectWithoutUserInput | JwtTokenCreateOrConnectWithoutUserInput[]
    upsert?: JwtTokenUpsertWithWhereUniqueWithoutUserInput | JwtTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JwtTokenCreateManyUserInputEnvelope
    set?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    disconnect?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    delete?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    connect?: JwtTokenWhereUniqueInput | JwtTokenWhereUniqueInput[]
    update?: JwtTokenUpdateWithWhereUniqueWithoutUserInput | JwtTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JwtTokenUpdateManyWithWhereWithoutUserInput | JwtTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JwtTokenScalarWhereInput | JwtTokenScalarWhereInput[]
  }

  export type ReportUserUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReportUserCreateWithoutAuthorInput, ReportUserUncheckedCreateWithoutAuthorInput> | ReportUserCreateWithoutAuthorInput[] | ReportUserUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutAuthorInput | ReportUserCreateOrConnectWithoutAuthorInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutAuthorInput | ReportUserUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReportUserCreateManyAuthorInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutAuthorInput | ReportUserUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutAuthorInput | ReportUserUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerdictCreateWithoutUserInput, VerdictUncheckedCreateWithoutUserInput> | VerdictCreateWithoutUserInput[] | VerdictUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutUserInput | VerdictCreateOrConnectWithoutUserInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutUserInput | VerdictUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerdictCreateManyUserInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutUserInput | VerdictUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutUserInput | VerdictUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTrackingUsersInput = {
    create?: XOR<UserCreateWithoutTrackingUsersInput, UserUncheckedCreateWithoutTrackingUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackingUsersInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutTrackingUsersNestedInput = {
    create?: XOR<UserCreateWithoutTrackingUsersInput, UserUncheckedCreateWithoutTrackingUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackingUsersInput
    upsert?: UserUpsertWithoutTrackingUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrackingUsersInput, UserUpdateWithoutTrackingUsersInput>, UserUncheckedUpdateWithoutTrackingUsersInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.TokenType
  }

  export type UserUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    upsert?: UserUpsertWithoutTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokensInput, UserUpdateWithoutTokensInput>, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserCreateNestedOneWithoutSteamUserInput = {
    create?: XOR<UserCreateWithoutSteamUserInput, UserUncheckedCreateWithoutSteamUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutSteamUserInput
    connect?: UserWhereUniqueInput
  }

  export type SteamUserBansCreateNestedOneWithoutSteamInput = {
    create?: XOR<SteamUserBansCreateWithoutSteamInput, SteamUserBansUncheckedCreateWithoutSteamInput>
    connectOrCreate?: SteamUserBansCreateOrConnectWithoutSteamInput
    connect?: SteamUserBansWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutRecipientInput = {
    create?: XOR<CommentCreateWithoutRecipientInput, CommentUncheckedCreateWithoutRecipientInput> | CommentCreateWithoutRecipientInput[] | CommentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutRecipientInput | CommentCreateOrConnectWithoutRecipientInput[]
    createMany?: CommentCreateManyRecipientInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReportUserCreateNestedManyWithoutRecipientInput = {
    create?: XOR<ReportUserCreateWithoutRecipientInput, ReportUserUncheckedCreateWithoutRecipientInput> | ReportUserCreateWithoutRecipientInput[] | ReportUserUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutRecipientInput | ReportUserCreateOrConnectWithoutRecipientInput[]
    createMany?: ReportUserCreateManyRecipientInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput> | MatchCreateWithoutParticipantsInput[] | MatchUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutParticipantsInput | MatchCreateOrConnectWithoutParticipantsInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput> | PlayerStatisticsInMatchCreateWithoutSteamUserInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput | PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput[]
    createMany?: PlayerStatisticsInMatchCreateManySteamUserInputEnvelope
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
  }

  export type GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutSteamInput, GeneralPlayerStatisticsUncheckedCreateWithoutSteamInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutSteamInput
    connect?: GeneralPlayerStatisticsWhereUniqueInput
  }

  export type SteamUserBansUncheckedCreateNestedOneWithoutSteamInput = {
    create?: XOR<SteamUserBansCreateWithoutSteamInput, SteamUserBansUncheckedCreateWithoutSteamInput>
    connectOrCreate?: SteamUserBansCreateOrConnectWithoutSteamInput
    connect?: SteamUserBansWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<CommentCreateWithoutRecipientInput, CommentUncheckedCreateWithoutRecipientInput> | CommentCreateWithoutRecipientInput[] | CommentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutRecipientInput | CommentCreateOrConnectWithoutRecipientInput[]
    createMany?: CommentCreateManyRecipientInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReportUserUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<ReportUserCreateWithoutRecipientInput, ReportUserUncheckedCreateWithoutRecipientInput> | ReportUserCreateWithoutRecipientInput[] | ReportUserUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutRecipientInput | ReportUserCreateOrConnectWithoutRecipientInput[]
    createMany?: ReportUserCreateManyRecipientInputEnvelope
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput> | MatchCreateWithoutParticipantsInput[] | MatchUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutParticipantsInput | MatchCreateOrConnectWithoutParticipantsInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput> | PlayerStatisticsInMatchCreateWithoutSteamUserInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput | PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput[]
    createMany?: PlayerStatisticsInMatchCreateManySteamUserInputEnvelope
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
  }

  export type GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutSteamInput, GeneralPlayerStatisticsUncheckedCreateWithoutSteamInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutSteamInput
    connect?: GeneralPlayerStatisticsWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutSteamUserNestedInput = {
    create?: XOR<UserCreateWithoutSteamUserInput, UserUncheckedCreateWithoutSteamUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutSteamUserInput
    upsert?: UserUpsertWithoutSteamUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSteamUserInput, UserUpdateWithoutSteamUserInput>, UserUncheckedUpdateWithoutSteamUserInput>
  }

  export type SteamUserBansUpdateOneWithoutSteamNestedInput = {
    create?: XOR<SteamUserBansCreateWithoutSteamInput, SteamUserBansUncheckedCreateWithoutSteamInput>
    connectOrCreate?: SteamUserBansCreateOrConnectWithoutSteamInput
    upsert?: SteamUserBansUpsertWithoutSteamInput
    disconnect?: SteamUserBansWhereInput | boolean
    delete?: SteamUserBansWhereInput | boolean
    connect?: SteamUserBansWhereUniqueInput
    update?: XOR<XOR<SteamUserBansUpdateToOneWithWhereWithoutSteamInput, SteamUserBansUpdateWithoutSteamInput>, SteamUserBansUncheckedUpdateWithoutSteamInput>
  }

  export type CommentUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<CommentCreateWithoutRecipientInput, CommentUncheckedCreateWithoutRecipientInput> | CommentCreateWithoutRecipientInput[] | CommentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutRecipientInput | CommentCreateOrConnectWithoutRecipientInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutRecipientInput | CommentUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: CommentCreateManyRecipientInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutRecipientInput | CommentUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutRecipientInput | CommentUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReportUserUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<ReportUserCreateWithoutRecipientInput, ReportUserUncheckedCreateWithoutRecipientInput> | ReportUserCreateWithoutRecipientInput[] | ReportUserUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutRecipientInput | ReportUserCreateOrConnectWithoutRecipientInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutRecipientInput | ReportUserUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: ReportUserCreateManyRecipientInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutRecipientInput | ReportUserUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutRecipientInput | ReportUserUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput> | MatchCreateWithoutParticipantsInput[] | MatchUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutParticipantsInput | MatchCreateOrConnectWithoutParticipantsInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutParticipantsInput | MatchUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutParticipantsInput | MatchUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutParticipantsInput | MatchUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput> | PlayerStatisticsInMatchCreateWithoutSteamUserInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput | PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput[]
    upsert?: PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutSteamUserInput | PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutSteamUserInput[]
    createMany?: PlayerStatisticsInMatchCreateManySteamUserInputEnvelope
    set?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    disconnect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    delete?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    update?: PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutSteamUserInput | PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutSteamUserInput[]
    updateMany?: PlayerStatisticsInMatchUpdateManyWithWhereWithoutSteamUserInput | PlayerStatisticsInMatchUpdateManyWithWhereWithoutSteamUserInput[]
    deleteMany?: PlayerStatisticsInMatchScalarWhereInput | PlayerStatisticsInMatchScalarWhereInput[]
  }

  export type GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutSteamInput, GeneralPlayerStatisticsUncheckedCreateWithoutSteamInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutSteamInput
    upsert?: GeneralPlayerStatisticsUpsertWithoutSteamInput
    disconnect?: GeneralPlayerStatisticsWhereInput | boolean
    delete?: GeneralPlayerStatisticsWhereInput | boolean
    connect?: GeneralPlayerStatisticsWhereUniqueInput
    update?: XOR<XOR<GeneralPlayerStatisticsUpdateToOneWithWhereWithoutSteamInput, GeneralPlayerStatisticsUpdateWithoutSteamInput>, GeneralPlayerStatisticsUncheckedUpdateWithoutSteamInput>
  }

  export type SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput = {
    create?: XOR<SteamUserBansCreateWithoutSteamInput, SteamUserBansUncheckedCreateWithoutSteamInput>
    connectOrCreate?: SteamUserBansCreateOrConnectWithoutSteamInput
    upsert?: SteamUserBansUpsertWithoutSteamInput
    disconnect?: SteamUserBansWhereInput | boolean
    delete?: SteamUserBansWhereInput | boolean
    connect?: SteamUserBansWhereUniqueInput
    update?: XOR<XOR<SteamUserBansUpdateToOneWithWhereWithoutSteamInput, SteamUserBansUpdateWithoutSteamInput>, SteamUserBansUncheckedUpdateWithoutSteamInput>
  }

  export type CommentUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<CommentCreateWithoutRecipientInput, CommentUncheckedCreateWithoutRecipientInput> | CommentCreateWithoutRecipientInput[] | CommentUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutRecipientInput | CommentCreateOrConnectWithoutRecipientInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutRecipientInput | CommentUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: CommentCreateManyRecipientInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutRecipientInput | CommentUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutRecipientInput | CommentUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReportUserUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<ReportUserCreateWithoutRecipientInput, ReportUserUncheckedCreateWithoutRecipientInput> | ReportUserCreateWithoutRecipientInput[] | ReportUserUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: ReportUserCreateOrConnectWithoutRecipientInput | ReportUserCreateOrConnectWithoutRecipientInput[]
    upsert?: ReportUserUpsertWithWhereUniqueWithoutRecipientInput | ReportUserUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: ReportUserCreateManyRecipientInputEnvelope
    set?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    disconnect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    delete?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    connect?: ReportUserWhereUniqueInput | ReportUserWhereUniqueInput[]
    update?: ReportUserUpdateWithWhereUniqueWithoutRecipientInput | ReportUserUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: ReportUserUpdateManyWithWhereWithoutRecipientInput | ReportUserUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput> | MatchCreateWithoutParticipantsInput[] | MatchUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutParticipantsInput | MatchCreateOrConnectWithoutParticipantsInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutParticipantsInput | MatchUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutParticipantsInput | MatchUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutParticipantsInput | MatchUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput> | PlayerStatisticsInMatchCreateWithoutSteamUserInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput | PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput[]
    upsert?: PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutSteamUserInput | PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutSteamUserInput[]
    createMany?: PlayerStatisticsInMatchCreateManySteamUserInputEnvelope
    set?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    disconnect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    delete?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    update?: PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutSteamUserInput | PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutSteamUserInput[]
    updateMany?: PlayerStatisticsInMatchUpdateManyWithWhereWithoutSteamUserInput | PlayerStatisticsInMatchUpdateManyWithWhereWithoutSteamUserInput[]
    deleteMany?: PlayerStatisticsInMatchScalarWhereInput | PlayerStatisticsInMatchScalarWhereInput[]
  }

  export type GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutSteamInput, GeneralPlayerStatisticsUncheckedCreateWithoutSteamInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutSteamInput
    upsert?: GeneralPlayerStatisticsUpsertWithoutSteamInput
    disconnect?: GeneralPlayerStatisticsWhereInput | boolean
    delete?: GeneralPlayerStatisticsWhereInput | boolean
    connect?: GeneralPlayerStatisticsWhereUniqueInput
    update?: XOR<XOR<GeneralPlayerStatisticsUpdateToOneWithWhereWithoutSteamInput, GeneralPlayerStatisticsUpdateWithoutSteamInput>, GeneralPlayerStatisticsUncheckedUpdateWithoutSteamInput>
  }

  export type SteamUserCreateNestedManyWithoutMatchesInput = {
    create?: XOR<SteamUserCreateWithoutMatchesInput, SteamUserUncheckedCreateWithoutMatchesInput> | SteamUserCreateWithoutMatchesInput[] | SteamUserUncheckedCreateWithoutMatchesInput[]
    connectOrCreate?: SteamUserCreateOrConnectWithoutMatchesInput | SteamUserCreateOrConnectWithoutMatchesInput[]
    connect?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
  }

  export type PlayerStatisticsInMatchCreateNestedManyWithoutMatchInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutMatchInput, PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput> | PlayerStatisticsInMatchCreateWithoutMatchInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput | PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput[]
    createMany?: PlayerStatisticsInMatchCreateManyMatchInputEnvelope
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
  }

  export type SteamUserUncheckedCreateNestedManyWithoutMatchesInput = {
    create?: XOR<SteamUserCreateWithoutMatchesInput, SteamUserUncheckedCreateWithoutMatchesInput> | SteamUserCreateWithoutMatchesInput[] | SteamUserUncheckedCreateWithoutMatchesInput[]
    connectOrCreate?: SteamUserCreateOrConnectWithoutMatchesInput | SteamUserCreateOrConnectWithoutMatchesInput[]
    connect?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
  }

  export type PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutMatchInput, PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput> | PlayerStatisticsInMatchCreateWithoutMatchInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput | PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput[]
    createMany?: PlayerStatisticsInMatchCreateManyMatchInputEnvelope
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
  }

  export type EnumMatchTypeFieldUpdateOperationsInput = {
    set?: $Enums.MatchType
  }

  export type SteamUserUpdateManyWithoutMatchesNestedInput = {
    create?: XOR<SteamUserCreateWithoutMatchesInput, SteamUserUncheckedCreateWithoutMatchesInput> | SteamUserCreateWithoutMatchesInput[] | SteamUserUncheckedCreateWithoutMatchesInput[]
    connectOrCreate?: SteamUserCreateOrConnectWithoutMatchesInput | SteamUserCreateOrConnectWithoutMatchesInput[]
    upsert?: SteamUserUpsertWithWhereUniqueWithoutMatchesInput | SteamUserUpsertWithWhereUniqueWithoutMatchesInput[]
    set?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    disconnect?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    delete?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    connect?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    update?: SteamUserUpdateWithWhereUniqueWithoutMatchesInput | SteamUserUpdateWithWhereUniqueWithoutMatchesInput[]
    updateMany?: SteamUserUpdateManyWithWhereWithoutMatchesInput | SteamUserUpdateManyWithWhereWithoutMatchesInput[]
    deleteMany?: SteamUserScalarWhereInput | SteamUserScalarWhereInput[]
  }

  export type PlayerStatisticsInMatchUpdateManyWithoutMatchNestedInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutMatchInput, PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput> | PlayerStatisticsInMatchCreateWithoutMatchInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput | PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput[]
    upsert?: PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutMatchInput | PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: PlayerStatisticsInMatchCreateManyMatchInputEnvelope
    set?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    disconnect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    delete?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    update?: PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutMatchInput | PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: PlayerStatisticsInMatchUpdateManyWithWhereWithoutMatchInput | PlayerStatisticsInMatchUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: PlayerStatisticsInMatchScalarWhereInput | PlayerStatisticsInMatchScalarWhereInput[]
  }

  export type SteamUserUncheckedUpdateManyWithoutMatchesNestedInput = {
    create?: XOR<SteamUserCreateWithoutMatchesInput, SteamUserUncheckedCreateWithoutMatchesInput> | SteamUserCreateWithoutMatchesInput[] | SteamUserUncheckedCreateWithoutMatchesInput[]
    connectOrCreate?: SteamUserCreateOrConnectWithoutMatchesInput | SteamUserCreateOrConnectWithoutMatchesInput[]
    upsert?: SteamUserUpsertWithWhereUniqueWithoutMatchesInput | SteamUserUpsertWithWhereUniqueWithoutMatchesInput[]
    set?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    disconnect?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    delete?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    connect?: SteamUserWhereUniqueInput | SteamUserWhereUniqueInput[]
    update?: SteamUserUpdateWithWhereUniqueWithoutMatchesInput | SteamUserUpdateWithWhereUniqueWithoutMatchesInput[]
    updateMany?: SteamUserUpdateManyWithWhereWithoutMatchesInput | SteamUserUpdateManyWithWhereWithoutMatchesInput[]
    deleteMany?: SteamUserScalarWhereInput | SteamUserScalarWhereInput[]
  }

  export type PlayerStatisticsInMatchUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<PlayerStatisticsInMatchCreateWithoutMatchInput, PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput> | PlayerStatisticsInMatchCreateWithoutMatchInput[] | PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput | PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput[]
    upsert?: PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutMatchInput | PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: PlayerStatisticsInMatchCreateManyMatchInputEnvelope
    set?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    disconnect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    delete?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    connect?: PlayerStatisticsInMatchWhereUniqueInput | PlayerStatisticsInMatchWhereUniqueInput[]
    update?: PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutMatchInput | PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: PlayerStatisticsInMatchUpdateManyWithWhereWithoutMatchInput | PlayerStatisticsInMatchUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: PlayerStatisticsInMatchScalarWhereInput | PlayerStatisticsInMatchScalarWhereInput[]
  }

  export type SteamUserCreateNestedOneWithoutGeneralPlayerStatisticsInput = {
    create?: XOR<SteamUserCreateWithoutGeneralPlayerStatisticsInput, SteamUserUncheckedCreateWithoutGeneralPlayerStatisticsInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutGeneralPlayerStatisticsInput
    connect?: SteamUserWhereUniqueInput
  }

  export type MapRanksCreateNestedManyWithoutGeneralPlayerStatisticsInput = {
    create?: XOR<MapRanksCreateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput> | MapRanksCreateWithoutGeneralPlayerStatisticsInput[] | MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput | MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    createMany?: MapRanksCreateManyGeneralPlayerStatisticsInputEnvelope
    connect?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
  }

  export type WeaponStatsCreateNestedManyWithoutGeneralPlayerStatisticsInput = {
    create?: XOR<WeaponStatsCreateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput> | WeaponStatsCreateWithoutGeneralPlayerStatisticsInput[] | WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput | WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    createMany?: WeaponStatsCreateManyGeneralPlayerStatisticsInputEnvelope
    connect?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
  }

  export type MapRanksUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput = {
    create?: XOR<MapRanksCreateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput> | MapRanksCreateWithoutGeneralPlayerStatisticsInput[] | MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput | MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    createMany?: MapRanksCreateManyGeneralPlayerStatisticsInputEnvelope
    connect?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
  }

  export type WeaponStatsUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput = {
    create?: XOR<WeaponStatsCreateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput> | WeaponStatsCreateWithoutGeneralPlayerStatisticsInput[] | WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput | WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    createMany?: WeaponStatsCreateManyGeneralPlayerStatisticsInputEnvelope
    connect?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
  }

  export type SteamUserUpdateOneRequiredWithoutGeneralPlayerStatisticsNestedInput = {
    create?: XOR<SteamUserCreateWithoutGeneralPlayerStatisticsInput, SteamUserUncheckedCreateWithoutGeneralPlayerStatisticsInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutGeneralPlayerStatisticsInput
    upsert?: SteamUserUpsertWithoutGeneralPlayerStatisticsInput
    connect?: SteamUserWhereUniqueInput
    update?: XOR<XOR<SteamUserUpdateToOneWithWhereWithoutGeneralPlayerStatisticsInput, SteamUserUpdateWithoutGeneralPlayerStatisticsInput>, SteamUserUncheckedUpdateWithoutGeneralPlayerStatisticsInput>
  }

  export type MapRanksUpdateManyWithoutGeneralPlayerStatisticsNestedInput = {
    create?: XOR<MapRanksCreateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput> | MapRanksCreateWithoutGeneralPlayerStatisticsInput[] | MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput | MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    upsert?: MapRanksUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput | MapRanksUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    createMany?: MapRanksCreateManyGeneralPlayerStatisticsInputEnvelope
    set?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    disconnect?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    delete?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    connect?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    update?: MapRanksUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput | MapRanksUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    updateMany?: MapRanksUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput | MapRanksUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput[]
    deleteMany?: MapRanksScalarWhereInput | MapRanksScalarWhereInput[]
  }

  export type WeaponStatsUpdateManyWithoutGeneralPlayerStatisticsNestedInput = {
    create?: XOR<WeaponStatsCreateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput> | WeaponStatsCreateWithoutGeneralPlayerStatisticsInput[] | WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput | WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    upsert?: WeaponStatsUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput | WeaponStatsUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    createMany?: WeaponStatsCreateManyGeneralPlayerStatisticsInputEnvelope
    set?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    disconnect?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    delete?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    connect?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    update?: WeaponStatsUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput | WeaponStatsUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    updateMany?: WeaponStatsUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput | WeaponStatsUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput[]
    deleteMany?: WeaponStatsScalarWhereInput | WeaponStatsScalarWhereInput[]
  }

  export type MapRanksUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput = {
    create?: XOR<MapRanksCreateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput> | MapRanksCreateWithoutGeneralPlayerStatisticsInput[] | MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput | MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    upsert?: MapRanksUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput | MapRanksUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    createMany?: MapRanksCreateManyGeneralPlayerStatisticsInputEnvelope
    set?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    disconnect?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    delete?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    connect?: MapRanksWhereUniqueInput | MapRanksWhereUniqueInput[]
    update?: MapRanksUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput | MapRanksUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    updateMany?: MapRanksUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput | MapRanksUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput[]
    deleteMany?: MapRanksScalarWhereInput | MapRanksScalarWhereInput[]
  }

  export type WeaponStatsUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput = {
    create?: XOR<WeaponStatsCreateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput> | WeaponStatsCreateWithoutGeneralPlayerStatisticsInput[] | WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput[]
    connectOrCreate?: WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput | WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput[]
    upsert?: WeaponStatsUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput | WeaponStatsUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    createMany?: WeaponStatsCreateManyGeneralPlayerStatisticsInputEnvelope
    set?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    disconnect?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    delete?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    connect?: WeaponStatsWhereUniqueInput | WeaponStatsWhereUniqueInput[]
    update?: WeaponStatsUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput | WeaponStatsUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput[]
    updateMany?: WeaponStatsUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput | WeaponStatsUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput[]
    deleteMany?: WeaponStatsScalarWhereInput | WeaponStatsScalarWhereInput[]
  }

  export type MapStatsCreateNestedManyWithoutMapRanksInput = {
    create?: XOR<MapStatsCreateWithoutMapRanksInput, MapStatsUncheckedCreateWithoutMapRanksInput> | MapStatsCreateWithoutMapRanksInput[] | MapStatsUncheckedCreateWithoutMapRanksInput[]
    connectOrCreate?: MapStatsCreateOrConnectWithoutMapRanksInput | MapStatsCreateOrConnectWithoutMapRanksInput[]
    createMany?: MapStatsCreateManyMapRanksInputEnvelope
    connect?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
  }

  export type GeneralPlayerStatisticsCreateNestedOneWithoutMapRanksInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutMapRanksInput, GeneralPlayerStatisticsUncheckedCreateWithoutMapRanksInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutMapRanksInput
    connect?: GeneralPlayerStatisticsWhereUniqueInput
  }

  export type MapStatsUncheckedCreateNestedManyWithoutMapRanksInput = {
    create?: XOR<MapStatsCreateWithoutMapRanksInput, MapStatsUncheckedCreateWithoutMapRanksInput> | MapStatsCreateWithoutMapRanksInput[] | MapStatsUncheckedCreateWithoutMapRanksInput[]
    connectOrCreate?: MapStatsCreateOrConnectWithoutMapRanksInput | MapStatsCreateOrConnectWithoutMapRanksInput[]
    createMany?: MapStatsCreateManyMapRanksInputEnvelope
    connect?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
  }

  export type MapStatsUpdateManyWithoutMapRanksNestedInput = {
    create?: XOR<MapStatsCreateWithoutMapRanksInput, MapStatsUncheckedCreateWithoutMapRanksInput> | MapStatsCreateWithoutMapRanksInput[] | MapStatsUncheckedCreateWithoutMapRanksInput[]
    connectOrCreate?: MapStatsCreateOrConnectWithoutMapRanksInput | MapStatsCreateOrConnectWithoutMapRanksInput[]
    upsert?: MapStatsUpsertWithWhereUniqueWithoutMapRanksInput | MapStatsUpsertWithWhereUniqueWithoutMapRanksInput[]
    createMany?: MapStatsCreateManyMapRanksInputEnvelope
    set?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    disconnect?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    delete?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    connect?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    update?: MapStatsUpdateWithWhereUniqueWithoutMapRanksInput | MapStatsUpdateWithWhereUniqueWithoutMapRanksInput[]
    updateMany?: MapStatsUpdateManyWithWhereWithoutMapRanksInput | MapStatsUpdateManyWithWhereWithoutMapRanksInput[]
    deleteMany?: MapStatsScalarWhereInput | MapStatsScalarWhereInput[]
  }

  export type GeneralPlayerStatisticsUpdateOneRequiredWithoutMapRanksNestedInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutMapRanksInput, GeneralPlayerStatisticsUncheckedCreateWithoutMapRanksInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutMapRanksInput
    upsert?: GeneralPlayerStatisticsUpsertWithoutMapRanksInput
    connect?: GeneralPlayerStatisticsWhereUniqueInput
    update?: XOR<XOR<GeneralPlayerStatisticsUpdateToOneWithWhereWithoutMapRanksInput, GeneralPlayerStatisticsUpdateWithoutMapRanksInput>, GeneralPlayerStatisticsUncheckedUpdateWithoutMapRanksInput>
  }

  export type MapStatsUncheckedUpdateManyWithoutMapRanksNestedInput = {
    create?: XOR<MapStatsCreateWithoutMapRanksInput, MapStatsUncheckedCreateWithoutMapRanksInput> | MapStatsCreateWithoutMapRanksInput[] | MapStatsUncheckedCreateWithoutMapRanksInput[]
    connectOrCreate?: MapStatsCreateOrConnectWithoutMapRanksInput | MapStatsCreateOrConnectWithoutMapRanksInput[]
    upsert?: MapStatsUpsertWithWhereUniqueWithoutMapRanksInput | MapStatsUpsertWithWhereUniqueWithoutMapRanksInput[]
    createMany?: MapStatsCreateManyMapRanksInputEnvelope
    set?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    disconnect?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    delete?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    connect?: MapStatsWhereUniqueInput | MapStatsWhereUniqueInput[]
    update?: MapStatsUpdateWithWhereUniqueWithoutMapRanksInput | MapStatsUpdateWithWhereUniqueWithoutMapRanksInput[]
    updateMany?: MapStatsUpdateManyWithWhereWithoutMapRanksInput | MapStatsUpdateManyWithWhereWithoutMapRanksInput[]
    deleteMany?: MapStatsScalarWhereInput | MapStatsScalarWhereInput[]
  }

  export type MapRanksCreateNestedOneWithoutMapStatInput = {
    create?: XOR<MapRanksCreateWithoutMapStatInput, MapRanksUncheckedCreateWithoutMapStatInput>
    connectOrCreate?: MapRanksCreateOrConnectWithoutMapStatInput
    connect?: MapRanksWhereUniqueInput
  }

  export type MapRanksUpdateOneRequiredWithoutMapStatNestedInput = {
    create?: XOR<MapRanksCreateWithoutMapStatInput, MapRanksUncheckedCreateWithoutMapStatInput>
    connectOrCreate?: MapRanksCreateOrConnectWithoutMapStatInput
    upsert?: MapRanksUpsertWithoutMapStatInput
    connect?: MapRanksWhereUniqueInput
    update?: XOR<XOR<MapRanksUpdateToOneWithWhereWithoutMapStatInput, MapRanksUpdateWithoutMapStatInput>, MapRanksUncheckedUpdateWithoutMapStatInput>
  }

  export type GeneralPlayerStatisticsCreateNestedOneWithoutWeaponStatsInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutWeaponStatsInput, GeneralPlayerStatisticsUncheckedCreateWithoutWeaponStatsInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutWeaponStatsInput
    connect?: GeneralPlayerStatisticsWhereUniqueInput
  }

  export type HitCreateNestedManyWithoutWeaponInput = {
    create?: XOR<HitCreateWithoutWeaponInput, HitUncheckedCreateWithoutWeaponInput> | HitCreateWithoutWeaponInput[] | HitUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: HitCreateOrConnectWithoutWeaponInput | HitCreateOrConnectWithoutWeaponInput[]
    createMany?: HitCreateManyWeaponInputEnvelope
    connect?: HitWhereUniqueInput | HitWhereUniqueInput[]
  }

  export type HitUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<HitCreateWithoutWeaponInput, HitUncheckedCreateWithoutWeaponInput> | HitCreateWithoutWeaponInput[] | HitUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: HitCreateOrConnectWithoutWeaponInput | HitCreateOrConnectWithoutWeaponInput[]
    createMany?: HitCreateManyWeaponInputEnvelope
    connect?: HitWhereUniqueInput | HitWhereUniqueInput[]
  }

  export type GeneralPlayerStatisticsUpdateOneRequiredWithoutWeaponStatsNestedInput = {
    create?: XOR<GeneralPlayerStatisticsCreateWithoutWeaponStatsInput, GeneralPlayerStatisticsUncheckedCreateWithoutWeaponStatsInput>
    connectOrCreate?: GeneralPlayerStatisticsCreateOrConnectWithoutWeaponStatsInput
    upsert?: GeneralPlayerStatisticsUpsertWithoutWeaponStatsInput
    connect?: GeneralPlayerStatisticsWhereUniqueInput
    update?: XOR<XOR<GeneralPlayerStatisticsUpdateToOneWithWhereWithoutWeaponStatsInput, GeneralPlayerStatisticsUpdateWithoutWeaponStatsInput>, GeneralPlayerStatisticsUncheckedUpdateWithoutWeaponStatsInput>
  }

  export type HitUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<HitCreateWithoutWeaponInput, HitUncheckedCreateWithoutWeaponInput> | HitCreateWithoutWeaponInput[] | HitUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: HitCreateOrConnectWithoutWeaponInput | HitCreateOrConnectWithoutWeaponInput[]
    upsert?: HitUpsertWithWhereUniqueWithoutWeaponInput | HitUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: HitCreateManyWeaponInputEnvelope
    set?: HitWhereUniqueInput | HitWhereUniqueInput[]
    disconnect?: HitWhereUniqueInput | HitWhereUniqueInput[]
    delete?: HitWhereUniqueInput | HitWhereUniqueInput[]
    connect?: HitWhereUniqueInput | HitWhereUniqueInput[]
    update?: HitUpdateWithWhereUniqueWithoutWeaponInput | HitUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: HitUpdateManyWithWhereWithoutWeaponInput | HitUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: HitScalarWhereInput | HitScalarWhereInput[]
  }

  export type HitUncheckedUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<HitCreateWithoutWeaponInput, HitUncheckedCreateWithoutWeaponInput> | HitCreateWithoutWeaponInput[] | HitUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: HitCreateOrConnectWithoutWeaponInput | HitCreateOrConnectWithoutWeaponInput[]
    upsert?: HitUpsertWithWhereUniqueWithoutWeaponInput | HitUpsertWithWhereUniqueWithoutWeaponInput[]
    createMany?: HitCreateManyWeaponInputEnvelope
    set?: HitWhereUniqueInput | HitWhereUniqueInput[]
    disconnect?: HitWhereUniqueInput | HitWhereUniqueInput[]
    delete?: HitWhereUniqueInput | HitWhereUniqueInput[]
    connect?: HitWhereUniqueInput | HitWhereUniqueInput[]
    update?: HitUpdateWithWhereUniqueWithoutWeaponInput | HitUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: HitUpdateManyWithWhereWithoutWeaponInput | HitUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: HitScalarWhereInput | HitScalarWhereInput[]
  }

  export type WeaponStatsCreateNestedOneWithoutHitsInput = {
    create?: XOR<WeaponStatsCreateWithoutHitsInput, WeaponStatsUncheckedCreateWithoutHitsInput>
    connectOrCreate?: WeaponStatsCreateOrConnectWithoutHitsInput
    connect?: WeaponStatsWhereUniqueInput
  }

  export type WeaponStatsUpdateOneRequiredWithoutHitsNestedInput = {
    create?: XOR<WeaponStatsCreateWithoutHitsInput, WeaponStatsUncheckedCreateWithoutHitsInput>
    connectOrCreate?: WeaponStatsCreateOrConnectWithoutHitsInput
    upsert?: WeaponStatsUpsertWithoutHitsInput
    connect?: WeaponStatsWhereUniqueInput
    update?: XOR<XOR<WeaponStatsUpdateToOneWithWhereWithoutHitsInput, WeaponStatsUpdateWithoutHitsInput>, WeaponStatsUncheckedUpdateWithoutHitsInput>
  }

  export type SteamUserCreateNestedOneWithoutPlayerStatisticsInMatchInput = {
    create?: XOR<SteamUserCreateWithoutPlayerStatisticsInMatchInput, SteamUserUncheckedCreateWithoutPlayerStatisticsInMatchInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutPlayerStatisticsInMatchInput
    connect?: SteamUserWhereUniqueInput
  }

  export type MatchCreateNestedOneWithoutPlayersStatisticInput = {
    create?: XOR<MatchCreateWithoutPlayersStatisticInput, MatchUncheckedCreateWithoutPlayersStatisticInput>
    connectOrCreate?: MatchCreateOrConnectWithoutPlayersStatisticInput
    connect?: MatchWhereUniqueInput
  }

  export type SteamUserUpdateOneRequiredWithoutPlayerStatisticsInMatchNestedInput = {
    create?: XOR<SteamUserCreateWithoutPlayerStatisticsInMatchInput, SteamUserUncheckedCreateWithoutPlayerStatisticsInMatchInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutPlayerStatisticsInMatchInput
    upsert?: SteamUserUpsertWithoutPlayerStatisticsInMatchInput
    connect?: SteamUserWhereUniqueInput
    update?: XOR<XOR<SteamUserUpdateToOneWithWhereWithoutPlayerStatisticsInMatchInput, SteamUserUpdateWithoutPlayerStatisticsInMatchInput>, SteamUserUncheckedUpdateWithoutPlayerStatisticsInMatchInput>
  }

  export type MatchUpdateOneRequiredWithoutPlayersStatisticNestedInput = {
    create?: XOR<MatchCreateWithoutPlayersStatisticInput, MatchUncheckedCreateWithoutPlayersStatisticInput>
    connectOrCreate?: MatchCreateOrConnectWithoutPlayersStatisticInput
    upsert?: MatchUpsertWithoutPlayersStatisticInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutPlayersStatisticInput, MatchUpdateWithoutPlayersStatisticInput>, MatchUncheckedUpdateWithoutPlayersStatisticInput>
  }

  export type SteamUserCreateNestedOneWithoutSteamUserBansInput = {
    create?: XOR<SteamUserCreateWithoutSteamUserBansInput, SteamUserUncheckedCreateWithoutSteamUserBansInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutSteamUserBansInput
    connect?: SteamUserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SteamUserUpdateOneRequiredWithoutSteamUserBansNestedInput = {
    create?: XOR<SteamUserCreateWithoutSteamUserBansInput, SteamUserUncheckedCreateWithoutSteamUserBansInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutSteamUserBansInput
    upsert?: SteamUserUpsertWithoutSteamUserBansInput
    connect?: SteamUserWhereUniqueInput
    update?: XOR<XOR<SteamUserUpdateToOneWithWhereWithoutSteamUserBansInput, SteamUserUpdateWithoutSteamUserBansInput>, SteamUserUncheckedUpdateWithoutSteamUserBansInput>
  }

  export type UserCreateNestedOneWithoutLinksInput = {
    create?: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput
    upsert?: UserUpsertWithoutLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLinksInput, UserUpdateWithoutLinksInput>, UserUncheckedUpdateWithoutLinksInput>
  }

  export type ImagesCreateNestedManyWithoutCommentInput = {
    create?: XOR<ImagesCreateWithoutCommentInput, ImagesUncheckedCreateWithoutCommentInput> | ImagesCreateWithoutCommentInput[] | ImagesUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ImagesCreateOrConnectWithoutCommentInput | ImagesCreateOrConnectWithoutCommentInput[]
    createMany?: ImagesCreateManyCommentInputEnvelope
    connect?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCommentsAsAuthorInput = {
    create?: XOR<UserCreateWithoutCommentsAsAuthorInput, UserUncheckedCreateWithoutCommentsAsAuthorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsAsAuthorInput
    connect?: UserWhereUniqueInput
  }

  export type SteamUserCreateNestedOneWithoutCommentsAsRecipientInput = {
    create?: XOR<SteamUserCreateWithoutCommentsAsRecipientInput, SteamUserUncheckedCreateWithoutCommentsAsRecipientInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutCommentsAsRecipientInput
    connect?: SteamUserWhereUniqueInput
  }

  export type ImagesUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<ImagesCreateWithoutCommentInput, ImagesUncheckedCreateWithoutCommentInput> | ImagesCreateWithoutCommentInput[] | ImagesUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ImagesCreateOrConnectWithoutCommentInput | ImagesCreateOrConnectWithoutCommentInput[]
    createMany?: ImagesCreateManyCommentInputEnvelope
    connect?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
  }

  export type ImagesUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ImagesCreateWithoutCommentInput, ImagesUncheckedCreateWithoutCommentInput> | ImagesCreateWithoutCommentInput[] | ImagesUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ImagesCreateOrConnectWithoutCommentInput | ImagesCreateOrConnectWithoutCommentInput[]
    upsert?: ImagesUpsertWithWhereUniqueWithoutCommentInput | ImagesUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ImagesCreateManyCommentInputEnvelope
    set?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    disconnect?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    delete?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    connect?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    update?: ImagesUpdateWithWhereUniqueWithoutCommentInput | ImagesUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ImagesUpdateManyWithWhereWithoutCommentInput | ImagesUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ImagesScalarWhereInput | ImagesScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsAsAuthorNestedInput = {
    create?: XOR<UserCreateWithoutCommentsAsAuthorInput, UserUncheckedCreateWithoutCommentsAsAuthorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsAsAuthorInput
    upsert?: UserUpsertWithoutCommentsAsAuthorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsAsAuthorInput, UserUpdateWithoutCommentsAsAuthorInput>, UserUncheckedUpdateWithoutCommentsAsAuthorInput>
  }

  export type SteamUserUpdateOneRequiredWithoutCommentsAsRecipientNestedInput = {
    create?: XOR<SteamUserCreateWithoutCommentsAsRecipientInput, SteamUserUncheckedCreateWithoutCommentsAsRecipientInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutCommentsAsRecipientInput
    upsert?: SteamUserUpsertWithoutCommentsAsRecipientInput
    connect?: SteamUserWhereUniqueInput
    update?: XOR<XOR<SteamUserUpdateToOneWithWhereWithoutCommentsAsRecipientInput, SteamUserUpdateWithoutCommentsAsRecipientInput>, SteamUserUncheckedUpdateWithoutCommentsAsRecipientInput>
  }

  export type ImagesUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ImagesCreateWithoutCommentInput, ImagesUncheckedCreateWithoutCommentInput> | ImagesCreateWithoutCommentInput[] | ImagesUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ImagesCreateOrConnectWithoutCommentInput | ImagesCreateOrConnectWithoutCommentInput[]
    upsert?: ImagesUpsertWithWhereUniqueWithoutCommentInput | ImagesUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ImagesCreateManyCommentInputEnvelope
    set?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    disconnect?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    delete?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    connect?: ImagesWhereUniqueInput | ImagesWhereUniqueInput[]
    update?: ImagesUpdateWithWhereUniqueWithoutCommentInput | ImagesUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ImagesUpdateManyWithWhereWithoutCommentInput | ImagesUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ImagesScalarWhereInput | ImagesScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutImagesInput = {
    create?: XOR<CommentCreateWithoutImagesInput, CommentUncheckedCreateWithoutImagesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutImagesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<CommentCreateWithoutImagesInput, CommentUncheckedCreateWithoutImagesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutImagesInput
    upsert?: CommentUpsertWithoutImagesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutImagesInput, CommentUpdateWithoutImagesInput>, CommentUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutJwtTokensInput = {
    create?: XOR<UserCreateWithoutJwtTokensInput, UserUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutJwtTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutJwtTokensNestedInput = {
    create?: XOR<UserCreateWithoutJwtTokensInput, UserUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutJwtTokensInput
    upsert?: UserUpsertWithoutJwtTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJwtTokensInput, UserUpdateWithoutJwtTokensInput>, UserUncheckedUpdateWithoutJwtTokensInput>
  }

  export type UserCreateNestedOneWithoutReportUsersInput = {
    create?: XOR<UserCreateWithoutReportUsersInput, UserUncheckedCreateWithoutReportUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportUsersInput
    connect?: UserWhereUniqueInput
  }

  export type SteamUserCreateNestedOneWithoutReportsAsRecipientInput = {
    create?: XOR<SteamUserCreateWithoutReportsAsRecipientInput, SteamUserUncheckedCreateWithoutReportsAsRecipientInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutReportsAsRecipientInput
    connect?: SteamUserWhereUniqueInput
  }

  export type VerdictCreateNestedManyWithoutReportInput = {
    create?: XOR<VerdictCreateWithoutReportInput, VerdictUncheckedCreateWithoutReportInput> | VerdictCreateWithoutReportInput[] | VerdictUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutReportInput | VerdictCreateOrConnectWithoutReportInput[]
    createMany?: VerdictCreateManyReportInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<VerdictCreateWithoutReportInput, VerdictUncheckedCreateWithoutReportInput> | VerdictCreateWithoutReportInput[] | VerdictUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutReportInput | VerdictCreateOrConnectWithoutReportInput[]
    createMany?: VerdictCreateManyReportInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReportUsersNestedInput = {
    create?: XOR<UserCreateWithoutReportUsersInput, UserUncheckedCreateWithoutReportUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportUsersInput
    upsert?: UserUpsertWithoutReportUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportUsersInput, UserUpdateWithoutReportUsersInput>, UserUncheckedUpdateWithoutReportUsersInput>
  }

  export type SteamUserUpdateOneRequiredWithoutReportsAsRecipientNestedInput = {
    create?: XOR<SteamUserCreateWithoutReportsAsRecipientInput, SteamUserUncheckedCreateWithoutReportsAsRecipientInput>
    connectOrCreate?: SteamUserCreateOrConnectWithoutReportsAsRecipientInput
    upsert?: SteamUserUpsertWithoutReportsAsRecipientInput
    connect?: SteamUserWhereUniqueInput
    update?: XOR<XOR<SteamUserUpdateToOneWithWhereWithoutReportsAsRecipientInput, SteamUserUpdateWithoutReportsAsRecipientInput>, SteamUserUncheckedUpdateWithoutReportsAsRecipientInput>
  }

  export type VerdictUpdateManyWithoutReportNestedInput = {
    create?: XOR<VerdictCreateWithoutReportInput, VerdictUncheckedCreateWithoutReportInput> | VerdictCreateWithoutReportInput[] | VerdictUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutReportInput | VerdictCreateOrConnectWithoutReportInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutReportInput | VerdictUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: VerdictCreateManyReportInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutReportInput | VerdictUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutReportInput | VerdictUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<VerdictCreateWithoutReportInput, VerdictUncheckedCreateWithoutReportInput> | VerdictCreateWithoutReportInput[] | VerdictUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutReportInput | VerdictCreateOrConnectWithoutReportInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutReportInput | VerdictUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: VerdictCreateManyReportInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutReportInput | VerdictUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutReportInput | VerdictUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type VerdictCreateverdictsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<UserCreateWithoutVerdictsInput, UserUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdictsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportUserCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<ReportUserCreateWithoutVerdictsInput, ReportUserUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: ReportUserCreateOrConnectWithoutVerdictsInput
    connect?: ReportUserWhereUniqueInput
  }

  export type VerdictUpdateverdictsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<UserCreateWithoutVerdictsInput, UserUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdictsInput
    upsert?: UserUpsertWithoutVerdictsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerdictsInput, UserUpdateWithoutVerdictsInput>, UserUncheckedUpdateWithoutVerdictsInput>
  }

  export type ReportUserUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<ReportUserCreateWithoutVerdictsInput, ReportUserUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: ReportUserCreateOrConnectWithoutVerdictsInput
    upsert?: ReportUserUpsertWithoutVerdictsInput
    connect?: ReportUserWhereUniqueInput
    update?: XOR<XOR<ReportUserUpdateToOneWithWhereWithoutVerdictsInput, ReportUserUpdateWithoutVerdictsInput>, ReportUserUncheckedUpdateWithoutVerdictsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumAdditionalRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdditionalRole | EnumAdditionalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdditionalRoleFilter<$PrismaModel> | $Enums.AdditionalRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumAdditionalRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdditionalRole | EnumAdditionalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdditionalRole[] | ListEnumAdditionalRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdditionalRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdditionalRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdditionalRoleFilter<$PrismaModel>
    _max?: NestedEnumAdditionalRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeFilter<$PrismaModel> | $Enums.MatchType
  }

  export type NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TokenCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expiresIn: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expiresIn: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    isViewed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    isViewed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsCreateOrConnectWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsCreateManyUserInputEnvelope = {
    data: NotificationsCreateManyUserInput | NotificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrackingUserCreateWithoutUserInput = {
    id?: string
    name: string
    steamid: string
    dateBanned?: Date | string | null
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrackingUserUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    steamid: string
    dateBanned?: Date | string | null
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrackingUserCreateOrConnectWithoutUserInput = {
    where: TrackingUserWhereUniqueInput
    create: XOR<TrackingUserCreateWithoutUserInput, TrackingUserUncheckedCreateWithoutUserInput>
  }

  export type TrackingUserCreateManyUserInputEnvelope = {
    data: TrackingUserCreateManyUserInput | TrackingUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LinksInProfileCreateWithoutUserInput = {
    tradeLink?: string | null
    twitch?: string | null
    youtube?: string | null
    telegram?: string | null
    discord?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinksInProfileUncheckedCreateWithoutUserInput = {
    tradeLink?: string | null
    twitch?: string | null
    youtube?: string | null
    telegram?: string | null
    discord?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinksInProfileCreateOrConnectWithoutUserInput = {
    where: LinksInProfileWhereUniqueInput
    create: XOR<LinksInProfileCreateWithoutUserInput, LinksInProfileUncheckedCreateWithoutUserInput>
  }

  export type SteamUserCreateWithoutUserInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserCreateNestedManyWithoutRecipientInput
    matches?: MatchCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUncheckedCreateWithoutUserInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansUncheckedCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentUncheckedCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserUncheckedCreateNestedManyWithoutRecipientInput
    matches?: MatchUncheckedCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput
  }

  export type SteamUserCreateOrConnectWithoutUserInput = {
    where: SteamUserWhereUniqueInput
    create: XOR<SteamUserCreateWithoutUserInput, SteamUserUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImagesCreateNestedManyWithoutCommentInput
    recipient: SteamUserCreateNestedOneWithoutCommentsAsRecipientInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImagesUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type JwtTokenCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JwtTokenUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JwtTokenCreateOrConnectWithoutUserInput = {
    where: JwtTokenWhereUniqueInput
    create: XOR<JwtTokenCreateWithoutUserInput, JwtTokenUncheckedCreateWithoutUserInput>
  }

  export type JwtTokenCreateManyUserInputEnvelope = {
    data: JwtTokenCreateManyUserInput | JwtTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportUserCreateWithoutAuthorInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: SteamUserCreateNestedOneWithoutReportsAsRecipientInput
    verdicts?: VerdictCreateNestedManyWithoutReportInput
  }

  export type ReportUserUncheckedCreateWithoutAuthorInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    verdicts?: VerdictUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUserCreateOrConnectWithoutAuthorInput = {
    where: ReportUserWhereUniqueInput
    create: XOR<ReportUserCreateWithoutAuthorInput, ReportUserUncheckedCreateWithoutAuthorInput>
  }

  export type ReportUserCreateManyAuthorInputEnvelope = {
    data: ReportUserCreateManyAuthorInput | ReportUserCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutUserInput = {
    id?: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    report: ReportUserCreateNestedOneWithoutVerdictsInput
  }

  export type VerdictUncheckedCreateWithoutUserInput = {
    id?: string
    reportId: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictCreateOrConnectWithoutUserInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutUserInput, VerdictUncheckedCreateWithoutUserInput>
  }

  export type VerdictCreateManyUserInputEnvelope = {
    data: VerdictCreateManyUserInput | VerdictCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: StringFilter<"Token"> | string
    token?: StringFilter<"Token"> | string
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    expiresIn?: DateTimeFilter<"Token"> | Date | string
    userId?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
  }

  export type NotificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationsCreateWithoutUserInput, NotificationsUncheckedCreateWithoutUserInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutUserInput, NotificationsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutUserInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: StringFilter<"Notifications"> | string
    userId?: StringFilter<"Notifications"> | string
    type?: EnumNotificationTypeFilter<"Notifications"> | $Enums.NotificationType
    title?: StringFilter<"Notifications"> | string
    description?: StringNullableFilter<"Notifications"> | string | null
    isViewed?: BoolFilter<"Notifications"> | boolean
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
  }

  export type TrackingUserUpsertWithWhereUniqueWithoutUserInput = {
    where: TrackingUserWhereUniqueInput
    update: XOR<TrackingUserUpdateWithoutUserInput, TrackingUserUncheckedUpdateWithoutUserInput>
    create: XOR<TrackingUserCreateWithoutUserInput, TrackingUserUncheckedCreateWithoutUserInput>
  }

  export type TrackingUserUpdateWithWhereUniqueWithoutUserInput = {
    where: TrackingUserWhereUniqueInput
    data: XOR<TrackingUserUpdateWithoutUserInput, TrackingUserUncheckedUpdateWithoutUserInput>
  }

  export type TrackingUserUpdateManyWithWhereWithoutUserInput = {
    where: TrackingUserScalarWhereInput
    data: XOR<TrackingUserUpdateManyMutationInput, TrackingUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TrackingUserScalarWhereInput = {
    AND?: TrackingUserScalarWhereInput | TrackingUserScalarWhereInput[]
    OR?: TrackingUserScalarWhereInput[]
    NOT?: TrackingUserScalarWhereInput | TrackingUserScalarWhereInput[]
    id?: StringFilter<"TrackingUser"> | string
    userId?: StringFilter<"TrackingUser"> | string
    name?: StringFilter<"TrackingUser"> | string
    steamid?: StringFilter<"TrackingUser"> | string
    dateBanned?: DateTimeNullableFilter<"TrackingUser"> | Date | string | null
    avatar?: StringFilter<"TrackingUser"> | string
    createdAt?: DateTimeFilter<"TrackingUser"> | Date | string
    updatedAt?: DateTimeFilter<"TrackingUser"> | Date | string
  }

  export type LinksInProfileUpsertWithoutUserInput = {
    update: XOR<LinksInProfileUpdateWithoutUserInput, LinksInProfileUncheckedUpdateWithoutUserInput>
    create: XOR<LinksInProfileCreateWithoutUserInput, LinksInProfileUncheckedCreateWithoutUserInput>
    where?: LinksInProfileWhereInput
  }

  export type LinksInProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: LinksInProfileWhereInput
    data: XOR<LinksInProfileUpdateWithoutUserInput, LinksInProfileUncheckedUpdateWithoutUserInput>
  }

  export type LinksInProfileUpdateWithoutUserInput = {
    tradeLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinksInProfileUncheckedUpdateWithoutUserInput = {
    tradeLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitch?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SteamUserUpsertWithoutUserInput = {
    update: XOR<SteamUserUpdateWithoutUserInput, SteamUserUncheckedUpdateWithoutUserInput>
    create: XOR<SteamUserCreateWithoutUserInput, SteamUserUncheckedCreateWithoutUserInput>
    where?: SteamUserWhereInput
  }

  export type SteamUserUpdateToOneWithWhereWithoutUserInput = {
    where?: SteamUserWhereInput
    data: XOR<SteamUserUpdateWithoutUserInput, SteamUserUncheckedUpdateWithoutUserInput>
  }

  export type SteamUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUpdateManyWithoutRecipientNestedInput
    matches?: MatchUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUncheckedUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUncheckedUpdateManyWithoutRecipientNestedInput
    matches?: MatchUncheckedUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    recipientId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type JwtTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: JwtTokenWhereUniqueInput
    update: XOR<JwtTokenUpdateWithoutUserInput, JwtTokenUncheckedUpdateWithoutUserInput>
    create: XOR<JwtTokenCreateWithoutUserInput, JwtTokenUncheckedCreateWithoutUserInput>
  }

  export type JwtTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: JwtTokenWhereUniqueInput
    data: XOR<JwtTokenUpdateWithoutUserInput, JwtTokenUncheckedUpdateWithoutUserInput>
  }

  export type JwtTokenUpdateManyWithWhereWithoutUserInput = {
    where: JwtTokenScalarWhereInput
    data: XOR<JwtTokenUpdateManyMutationInput, JwtTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type JwtTokenScalarWhereInput = {
    AND?: JwtTokenScalarWhereInput | JwtTokenScalarWhereInput[]
    OR?: JwtTokenScalarWhereInput[]
    NOT?: JwtTokenScalarWhereInput | JwtTokenScalarWhereInput[]
    id?: StringFilter<"JwtToken"> | string
    refreshToken?: StringFilter<"JwtToken"> | string
    userId?: StringFilter<"JwtToken"> | string
    createdAt?: DateTimeFilter<"JwtToken"> | Date | string
    updatedAt?: DateTimeFilter<"JwtToken"> | Date | string
  }

  export type ReportUserUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReportUserWhereUniqueInput
    update: XOR<ReportUserUpdateWithoutAuthorInput, ReportUserUncheckedUpdateWithoutAuthorInput>
    create: XOR<ReportUserCreateWithoutAuthorInput, ReportUserUncheckedCreateWithoutAuthorInput>
  }

  export type ReportUserUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReportUserWhereUniqueInput
    data: XOR<ReportUserUpdateWithoutAuthorInput, ReportUserUncheckedUpdateWithoutAuthorInput>
  }

  export type ReportUserUpdateManyWithWhereWithoutAuthorInput = {
    where: ReportUserScalarWhereInput
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ReportUserScalarWhereInput = {
    AND?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
    OR?: ReportUserScalarWhereInput[]
    NOT?: ReportUserScalarWhereInput | ReportUserScalarWhereInput[]
    id?: StringFilter<"ReportUser"> | string
    youtubeLink?: StringFilter<"ReportUser"> | string
    demoLink?: StringNullableFilter<"ReportUser"> | string | null
    comment?: StringNullableFilter<"ReportUser"> | string | null
    authorId?: StringFilter<"ReportUser"> | string
    recipientId?: StringFilter<"ReportUser"> | string
    createdAt?: DateTimeFilter<"ReportUser"> | Date | string
    updatedAt?: DateTimeFilter<"ReportUser"> | Date | string
  }

  export type VerdictUpsertWithWhereUniqueWithoutUserInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutUserInput, VerdictUncheckedUpdateWithoutUserInput>
    create: XOR<VerdictCreateWithoutUserInput, VerdictUncheckedCreateWithoutUserInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutUserInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutUserInput, VerdictUncheckedUpdateWithoutUserInput>
  }

  export type VerdictUpdateManyWithWhereWithoutUserInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutUserInput>
  }

  export type VerdictScalarWhereInput = {
    AND?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    OR?: VerdictScalarWhereInput[]
    NOT?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    id?: StringFilter<"Verdict"> | string
    userId?: StringFilter<"Verdict"> | string
    reportId?: StringFilter<"Verdict"> | string
    verdicts?: StringNullableListFilter<"Verdict">
    comment?: StringNullableFilter<"Verdict"> | string | null
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
  }

  export type UserCreateWithoutTrackingUsersInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrackingUsersInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrackingUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrackingUsersInput, UserUncheckedCreateWithoutTrackingUsersInput>
  }

  export type UserUpsertWithoutTrackingUsersInput = {
    update: XOR<UserUpdateWithoutTrackingUsersInput, UserUncheckedUpdateWithoutTrackingUsersInput>
    create: XOR<UserCreateWithoutTrackingUsersInput, UserUncheckedCreateWithoutTrackingUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrackingUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrackingUsersInput, UserUncheckedUpdateWithoutTrackingUsersInput>
  }

  export type UserUpdateWithoutTrackingUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrackingUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTokensInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokensInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type UserUpsertWithoutTokensInput = {
    update: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSteamUserInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSteamUserInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSteamUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSteamUserInput, UserUncheckedCreateWithoutSteamUserInput>
  }

  export type SteamUserBansCreateWithoutSteamInput = {
    communityBanned?: boolean | null
    daysSinceLastBan?: number | null
    economyBan?: string | null
    gameBans?: number | null
    vacBanned?: boolean | null
    vacBans?: number | null
    csBan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SteamUserBansUncheckedCreateWithoutSteamInput = {
    communityBanned?: boolean | null
    daysSinceLastBan?: number | null
    economyBan?: string | null
    gameBans?: number | null
    vacBanned?: boolean | null
    vacBans?: number | null
    csBan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SteamUserBansCreateOrConnectWithoutSteamInput = {
    where: SteamUserBansWhereUniqueInput
    create: XOR<SteamUserBansCreateWithoutSteamInput, SteamUserBansUncheckedCreateWithoutSteamInput>
  }

  export type CommentCreateWithoutRecipientInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImagesCreateNestedManyWithoutCommentInput
    author: UserCreateNestedOneWithoutCommentsAsAuthorInput
  }

  export type CommentUncheckedCreateWithoutRecipientInput = {
    id?: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImagesUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRecipientInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRecipientInput, CommentUncheckedCreateWithoutRecipientInput>
  }

  export type CommentCreateManyRecipientInputEnvelope = {
    data: CommentCreateManyRecipientInput | CommentCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type ReportUserCreateWithoutRecipientInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutReportUsersInput
    verdicts?: VerdictCreateNestedManyWithoutReportInput
  }

  export type ReportUserUncheckedCreateWithoutRecipientInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    verdicts?: VerdictUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUserCreateOrConnectWithoutRecipientInput = {
    where: ReportUserWhereUniqueInput
    create: XOR<ReportUserCreateWithoutRecipientInput, ReportUserUncheckedCreateWithoutRecipientInput>
  }

  export type ReportUserCreateManyRecipientInputEnvelope = {
    data: ReportUserCreateManyRecipientInput | ReportUserCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutParticipantsInput = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date | string
    sharedCode: string
    replay: string
    result?: boolean
    duration: string
    createdAt?: Date | string
    updatedAt?: Date | string
    playersStatistic?: PlayerStatisticsInMatchCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutParticipantsInput = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date | string
    sharedCode: string
    replay: string
    result?: boolean
    duration: string
    createdAt?: Date | string
    updatedAt?: Date | string
    playersStatistic?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutParticipantsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput>
  }

  export type PlayerStatisticsInMatchCreateWithoutSteamUserInput = {
    id?: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
    match: MatchCreateNestedOneWithoutPlayersStatisticInput
  }

  export type PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput = {
    id?: string
    matchId: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatisticsInMatchCreateOrConnectWithoutSteamUserInput = {
    where: PlayerStatisticsInMatchWhereUniqueInput
    create: XOR<PlayerStatisticsInMatchCreateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput>
  }

  export type PlayerStatisticsInMatchCreateManySteamUserInputEnvelope = {
    data: PlayerStatisticsInMatchCreateManySteamUserInput | PlayerStatisticsInMatchCreateManySteamUserInput[]
    skipDuplicates?: boolean
  }

  export type GeneralPlayerStatisticsCreateWithoutSteamInput = {
    id?: string
    MapRanks?: MapRanksCreateNestedManyWithoutGeneralPlayerStatisticsInput
    WeaponStats?: WeaponStatsCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsUncheckedCreateWithoutSteamInput = {
    id?: string
    MapRanks?: MapRanksUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput
    WeaponStats?: WeaponStatsUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsCreateOrConnectWithoutSteamInput = {
    where: GeneralPlayerStatisticsWhereUniqueInput
    create: XOR<GeneralPlayerStatisticsCreateWithoutSteamInput, GeneralPlayerStatisticsUncheckedCreateWithoutSteamInput>
  }

  export type UserUpsertWithoutSteamUserInput = {
    update: XOR<UserUpdateWithoutSteamUserInput, UserUncheckedUpdateWithoutSteamUserInput>
    create: XOR<UserCreateWithoutSteamUserInput, UserUncheckedCreateWithoutSteamUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSteamUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSteamUserInput, UserUncheckedUpdateWithoutSteamUserInput>
  }

  export type UserUpdateWithoutSteamUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSteamUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SteamUserBansUpsertWithoutSteamInput = {
    update: XOR<SteamUserBansUpdateWithoutSteamInput, SteamUserBansUncheckedUpdateWithoutSteamInput>
    create: XOR<SteamUserBansCreateWithoutSteamInput, SteamUserBansUncheckedCreateWithoutSteamInput>
    where?: SteamUserBansWhereInput
  }

  export type SteamUserBansUpdateToOneWithWhereWithoutSteamInput = {
    where?: SteamUserBansWhereInput
    data: XOR<SteamUserBansUpdateWithoutSteamInput, SteamUserBansUncheckedUpdateWithoutSteamInput>
  }

  export type SteamUserBansUpdateWithoutSteamInput = {
    communityBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysSinceLastBan?: NullableIntFieldUpdateOperationsInput | number | null
    economyBan?: NullableStringFieldUpdateOperationsInput | string | null
    gameBans?: NullableIntFieldUpdateOperationsInput | number | null
    vacBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vacBans?: NullableIntFieldUpdateOperationsInput | number | null
    csBan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SteamUserBansUncheckedUpdateWithoutSteamInput = {
    communityBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysSinceLastBan?: NullableIntFieldUpdateOperationsInput | number | null
    economyBan?: NullableStringFieldUpdateOperationsInput | string | null
    gameBans?: NullableIntFieldUpdateOperationsInput | number | null
    vacBanned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    vacBans?: NullableIntFieldUpdateOperationsInput | number | null
    csBan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutRecipientInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutRecipientInput, CommentUncheckedUpdateWithoutRecipientInput>
    create: XOR<CommentCreateWithoutRecipientInput, CommentUncheckedCreateWithoutRecipientInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutRecipientInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutRecipientInput, CommentUncheckedUpdateWithoutRecipientInput>
  }

  export type CommentUpdateManyWithWhereWithoutRecipientInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutRecipientInput>
  }

  export type ReportUserUpsertWithWhereUniqueWithoutRecipientInput = {
    where: ReportUserWhereUniqueInput
    update: XOR<ReportUserUpdateWithoutRecipientInput, ReportUserUncheckedUpdateWithoutRecipientInput>
    create: XOR<ReportUserCreateWithoutRecipientInput, ReportUserUncheckedCreateWithoutRecipientInput>
  }

  export type ReportUserUpdateWithWhereUniqueWithoutRecipientInput = {
    where: ReportUserWhereUniqueInput
    data: XOR<ReportUserUpdateWithoutRecipientInput, ReportUserUncheckedUpdateWithoutRecipientInput>
  }

  export type ReportUserUpdateManyWithWhereWithoutRecipientInput = {
    where: ReportUserScalarWhereInput
    data: XOR<ReportUserUpdateManyMutationInput, ReportUserUncheckedUpdateManyWithoutRecipientInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutParticipantsInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutParticipantsInput, MatchUncheckedUpdateWithoutParticipantsInput>
    create: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutParticipantsInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutParticipantsInput, MatchUncheckedUpdateWithoutParticipantsInput>
  }

  export type MatchUpdateManyWithWhereWithoutParticipantsInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutParticipantsInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: StringFilter<"Match"> | string
    type?: EnumMatchTypeFilter<"Match"> | $Enums.MatchType
    matchId?: StringFilter<"Match"> | string
    score?: StringFilter<"Match"> | string
    date?: DateTimeFilter<"Match"> | Date | string
    sharedCode?: StringFilter<"Match"> | string
    replay?: StringFilter<"Match"> | string
    result?: BoolFilter<"Match"> | boolean
    duration?: StringFilter<"Match"> | string
    createdAt?: DateTimeFilter<"Match"> | Date | string
    updatedAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutSteamUserInput = {
    where: PlayerStatisticsInMatchWhereUniqueInput
    update: XOR<PlayerStatisticsInMatchUpdateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedUpdateWithoutSteamUserInput>
    create: XOR<PlayerStatisticsInMatchCreateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedCreateWithoutSteamUserInput>
  }

  export type PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutSteamUserInput = {
    where: PlayerStatisticsInMatchWhereUniqueInput
    data: XOR<PlayerStatisticsInMatchUpdateWithoutSteamUserInput, PlayerStatisticsInMatchUncheckedUpdateWithoutSteamUserInput>
  }

  export type PlayerStatisticsInMatchUpdateManyWithWhereWithoutSteamUserInput = {
    where: PlayerStatisticsInMatchScalarWhereInput
    data: XOR<PlayerStatisticsInMatchUpdateManyMutationInput, PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserInput>
  }

  export type PlayerStatisticsInMatchScalarWhereInput = {
    AND?: PlayerStatisticsInMatchScalarWhereInput | PlayerStatisticsInMatchScalarWhereInput[]
    OR?: PlayerStatisticsInMatchScalarWhereInput[]
    NOT?: PlayerStatisticsInMatchScalarWhereInput | PlayerStatisticsInMatchScalarWhereInput[]
    id?: StringFilter<"PlayerStatisticsInMatch"> | string
    userId?: StringFilter<"PlayerStatisticsInMatch"> | string
    matchId?: StringFilter<"PlayerStatisticsInMatch"> | string
    kills_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    deaths_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    assists_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    headshot_kills_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    ace_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k4_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k3_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    k2_rounds_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    damage_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    objective_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    utility_damage_total?: IntFilter<"PlayerStatisticsInMatch"> | number
    mvps?: IntFilter<"PlayerStatisticsInMatch"> | number
    crosshair_code?: StringFilter<"PlayerStatisticsInMatch"> | string
    player_color?: StringFilter<"PlayerStatisticsInMatch"> | string
    rank_if_win?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank_if_loss?: IntFilter<"PlayerStatisticsInMatch"> | number
    rank_if_tie?: IntFilter<"PlayerStatisticsInMatch"> | number
    createdAt?: DateTimeFilter<"PlayerStatisticsInMatch"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerStatisticsInMatch"> | Date | string
  }

  export type GeneralPlayerStatisticsUpsertWithoutSteamInput = {
    update: XOR<GeneralPlayerStatisticsUpdateWithoutSteamInput, GeneralPlayerStatisticsUncheckedUpdateWithoutSteamInput>
    create: XOR<GeneralPlayerStatisticsCreateWithoutSteamInput, GeneralPlayerStatisticsUncheckedCreateWithoutSteamInput>
    where?: GeneralPlayerStatisticsWhereInput
  }

  export type GeneralPlayerStatisticsUpdateToOneWithWhereWithoutSteamInput = {
    where?: GeneralPlayerStatisticsWhereInput
    data: XOR<GeneralPlayerStatisticsUpdateWithoutSteamInput, GeneralPlayerStatisticsUncheckedUpdateWithoutSteamInput>
  }

  export type GeneralPlayerStatisticsUpdateWithoutSteamInput = {
    id?: StringFieldUpdateOperationsInput | string
    MapRanks?: MapRanksUpdateManyWithoutGeneralPlayerStatisticsNestedInput
    WeaponStats?: WeaponStatsUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type GeneralPlayerStatisticsUncheckedUpdateWithoutSteamInput = {
    id?: StringFieldUpdateOperationsInput | string
    MapRanks?: MapRanksUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput
    WeaponStats?: WeaponStatsUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type SteamUserCreateWithoutMatchesInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSteamUserInput
    steamUserBans?: SteamUserBansCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserCreateNestedManyWithoutRecipientInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUncheckedCreateWithoutMatchesInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansUncheckedCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentUncheckedCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserUncheckedCreateNestedManyWithoutRecipientInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput
  }

  export type SteamUserCreateOrConnectWithoutMatchesInput = {
    where: SteamUserWhereUniqueInput
    create: XOR<SteamUserCreateWithoutMatchesInput, SteamUserUncheckedCreateWithoutMatchesInput>
  }

  export type PlayerStatisticsInMatchCreateWithoutMatchInput = {
    id?: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUser: SteamUserCreateNestedOneWithoutPlayerStatisticsInMatchInput
  }

  export type PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput = {
    id?: string
    userId: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatisticsInMatchCreateOrConnectWithoutMatchInput = {
    where: PlayerStatisticsInMatchWhereUniqueInput
    create: XOR<PlayerStatisticsInMatchCreateWithoutMatchInput, PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput>
  }

  export type PlayerStatisticsInMatchCreateManyMatchInputEnvelope = {
    data: PlayerStatisticsInMatchCreateManyMatchInput | PlayerStatisticsInMatchCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type SteamUserUpsertWithWhereUniqueWithoutMatchesInput = {
    where: SteamUserWhereUniqueInput
    update: XOR<SteamUserUpdateWithoutMatchesInput, SteamUserUncheckedUpdateWithoutMatchesInput>
    create: XOR<SteamUserCreateWithoutMatchesInput, SteamUserUncheckedCreateWithoutMatchesInput>
  }

  export type SteamUserUpdateWithWhereUniqueWithoutMatchesInput = {
    where: SteamUserWhereUniqueInput
    data: XOR<SteamUserUpdateWithoutMatchesInput, SteamUserUncheckedUpdateWithoutMatchesInput>
  }

  export type SteamUserUpdateManyWithWhereWithoutMatchesInput = {
    where: SteamUserScalarWhereInput
    data: XOR<SteamUserUpdateManyMutationInput, SteamUserUncheckedUpdateManyWithoutMatchesInput>
  }

  export type SteamUserScalarWhereInput = {
    AND?: SteamUserScalarWhereInput | SteamUserScalarWhereInput[]
    OR?: SteamUserScalarWhereInput[]
    NOT?: SteamUserScalarWhereInput | SteamUserScalarWhereInput[]
    id?: StringFilter<"SteamUser"> | string
    personaName?: StringFilter<"SteamUser"> | string
    profileUrl?: StringFilter<"SteamUser"> | string
    avatar?: StringFilter<"SteamUser"> | string
    realname?: StringNullableFilter<"SteamUser"> | string | null
    level?: StringNullableFilter<"SteamUser"> | string | null
    timeCreated?: StringFilter<"SteamUser"> | string
    steamId2?: StringNullableFilter<"SteamUser"> | string | null
    steamId3?: StringNullableFilter<"SteamUser"> | string | null
    steamIdHex?: StringNullableFilter<"SteamUser"> | string | null
    countryCode?: StringNullableFilter<"SteamUser"> | string | null
    lastUpdateSteamInformation?: DateTimeFilter<"SteamUser"> | Date | string
    viewers?: IntFilter<"SteamUser"> | number
    userId?: StringNullableFilter<"SteamUser"> | string | null
    sharedCode?: StringNullableFilter<"SteamUser"> | string | null
    gameAuthenticationCode?: StringNullableFilter<"SteamUser"> | string | null
    createdAt?: DateTimeFilter<"SteamUser"> | Date | string
    updatedAt?: DateTimeFilter<"SteamUser"> | Date | string
  }

  export type PlayerStatisticsInMatchUpsertWithWhereUniqueWithoutMatchInput = {
    where: PlayerStatisticsInMatchWhereUniqueInput
    update: XOR<PlayerStatisticsInMatchUpdateWithoutMatchInput, PlayerStatisticsInMatchUncheckedUpdateWithoutMatchInput>
    create: XOR<PlayerStatisticsInMatchCreateWithoutMatchInput, PlayerStatisticsInMatchUncheckedCreateWithoutMatchInput>
  }

  export type PlayerStatisticsInMatchUpdateWithWhereUniqueWithoutMatchInput = {
    where: PlayerStatisticsInMatchWhereUniqueInput
    data: XOR<PlayerStatisticsInMatchUpdateWithoutMatchInput, PlayerStatisticsInMatchUncheckedUpdateWithoutMatchInput>
  }

  export type PlayerStatisticsInMatchUpdateManyWithWhereWithoutMatchInput = {
    where: PlayerStatisticsInMatchScalarWhereInput
    data: XOR<PlayerStatisticsInMatchUpdateManyMutationInput, PlayerStatisticsInMatchUncheckedUpdateManyWithoutMatchInput>
  }

  export type SteamUserCreateWithoutGeneralPlayerStatisticsInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSteamUserInput
    steamUserBans?: SteamUserBansCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserCreateNestedManyWithoutRecipientInput
    matches?: MatchCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput
  }

  export type SteamUserUncheckedCreateWithoutGeneralPlayerStatisticsInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansUncheckedCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentUncheckedCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserUncheckedCreateNestedManyWithoutRecipientInput
    matches?: MatchUncheckedCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput
  }

  export type SteamUserCreateOrConnectWithoutGeneralPlayerStatisticsInput = {
    where: SteamUserWhereUniqueInput
    create: XOR<SteamUserCreateWithoutGeneralPlayerStatisticsInput, SteamUserUncheckedCreateWithoutGeneralPlayerStatisticsInput>
  }

  export type MapRanksCreateWithoutGeneralPlayerStatisticsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mapStat?: MapStatsCreateNestedManyWithoutMapRanksInput
  }

  export type MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mapStat?: MapStatsUncheckedCreateNestedManyWithoutMapRanksInput
  }

  export type MapRanksCreateOrConnectWithoutGeneralPlayerStatisticsInput = {
    where: MapRanksWhereUniqueInput
    create: XOR<MapRanksCreateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput>
  }

  export type MapRanksCreateManyGeneralPlayerStatisticsInputEnvelope = {
    data: MapRanksCreateManyGeneralPlayerStatisticsInput | MapRanksCreateManyGeneralPlayerStatisticsInput[]
    skipDuplicates?: boolean
  }

  export type WeaponStatsCreateWithoutGeneralPlayerStatisticsInput = {
    id?: string
    name: string
    fire: number
    hits?: HitCreateNestedManyWithoutWeaponInput
  }

  export type WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput = {
    id?: string
    name: string
    fire: number
    hits?: HitUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponStatsCreateOrConnectWithoutGeneralPlayerStatisticsInput = {
    where: WeaponStatsWhereUniqueInput
    create: XOR<WeaponStatsCreateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput>
  }

  export type WeaponStatsCreateManyGeneralPlayerStatisticsInputEnvelope = {
    data: WeaponStatsCreateManyGeneralPlayerStatisticsInput | WeaponStatsCreateManyGeneralPlayerStatisticsInput[]
    skipDuplicates?: boolean
  }

  export type SteamUserUpsertWithoutGeneralPlayerStatisticsInput = {
    update: XOR<SteamUserUpdateWithoutGeneralPlayerStatisticsInput, SteamUserUncheckedUpdateWithoutGeneralPlayerStatisticsInput>
    create: XOR<SteamUserCreateWithoutGeneralPlayerStatisticsInput, SteamUserUncheckedCreateWithoutGeneralPlayerStatisticsInput>
    where?: SteamUserWhereInput
  }

  export type SteamUserUpdateToOneWithWhereWithoutGeneralPlayerStatisticsInput = {
    where?: SteamUserWhereInput
    data: XOR<SteamUserUpdateWithoutGeneralPlayerStatisticsInput, SteamUserUncheckedUpdateWithoutGeneralPlayerStatisticsInput>
  }

  export type SteamUserUpdateWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSteamUserNestedInput
    steamUserBans?: SteamUserBansUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUpdateManyWithoutRecipientNestedInput
    matches?: MatchUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput
  }

  export type SteamUserUncheckedUpdateWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUncheckedUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUncheckedUpdateManyWithoutRecipientNestedInput
    matches?: MatchUncheckedUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput
  }

  export type MapRanksUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput = {
    where: MapRanksWhereUniqueInput
    update: XOR<MapRanksUpdateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedUpdateWithoutGeneralPlayerStatisticsInput>
    create: XOR<MapRanksCreateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedCreateWithoutGeneralPlayerStatisticsInput>
  }

  export type MapRanksUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput = {
    where: MapRanksWhereUniqueInput
    data: XOR<MapRanksUpdateWithoutGeneralPlayerStatisticsInput, MapRanksUncheckedUpdateWithoutGeneralPlayerStatisticsInput>
  }

  export type MapRanksUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput = {
    where: MapRanksScalarWhereInput
    data: XOR<MapRanksUpdateManyMutationInput, MapRanksUncheckedUpdateManyWithoutGeneralPlayerStatisticsInput>
  }

  export type MapRanksScalarWhereInput = {
    AND?: MapRanksScalarWhereInput | MapRanksScalarWhereInput[]
    OR?: MapRanksScalarWhereInput[]
    NOT?: MapRanksScalarWhereInput | MapRanksScalarWhereInput[]
    id?: StringFilter<"MapRanks"> | string
    name?: StringFilter<"MapRanks"> | string
    playerId?: StringFilter<"MapRanks"> | string
    createdAt?: DateTimeFilter<"MapRanks"> | Date | string
    updatedAt?: DateTimeFilter<"MapRanks"> | Date | string
  }

  export type WeaponStatsUpsertWithWhereUniqueWithoutGeneralPlayerStatisticsInput = {
    where: WeaponStatsWhereUniqueInput
    update: XOR<WeaponStatsUpdateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedUpdateWithoutGeneralPlayerStatisticsInput>
    create: XOR<WeaponStatsCreateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedCreateWithoutGeneralPlayerStatisticsInput>
  }

  export type WeaponStatsUpdateWithWhereUniqueWithoutGeneralPlayerStatisticsInput = {
    where: WeaponStatsWhereUniqueInput
    data: XOR<WeaponStatsUpdateWithoutGeneralPlayerStatisticsInput, WeaponStatsUncheckedUpdateWithoutGeneralPlayerStatisticsInput>
  }

  export type WeaponStatsUpdateManyWithWhereWithoutGeneralPlayerStatisticsInput = {
    where: WeaponStatsScalarWhereInput
    data: XOR<WeaponStatsUpdateManyMutationInput, WeaponStatsUncheckedUpdateManyWithoutGeneralPlayerStatisticsInput>
  }

  export type WeaponStatsScalarWhereInput = {
    AND?: WeaponStatsScalarWhereInput | WeaponStatsScalarWhereInput[]
    OR?: WeaponStatsScalarWhereInput[]
    NOT?: WeaponStatsScalarWhereInput | WeaponStatsScalarWhereInput[]
    id?: StringFilter<"WeaponStats"> | string
    name?: StringFilter<"WeaponStats"> | string
    fire?: IntFilter<"WeaponStats"> | number
    userId?: StringFilter<"WeaponStats"> | string
  }

  export type MapStatsCreateWithoutMapRanksInput = {
    id?: string
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapStatsUncheckedCreateWithoutMapRanksInput = {
    id?: string
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapStatsCreateOrConnectWithoutMapRanksInput = {
    where: MapStatsWhereUniqueInput
    create: XOR<MapStatsCreateWithoutMapRanksInput, MapStatsUncheckedCreateWithoutMapRanksInput>
  }

  export type MapStatsCreateManyMapRanksInputEnvelope = {
    data: MapStatsCreateManyMapRanksInput | MapStatsCreateManyMapRanksInput[]
    skipDuplicates?: boolean
  }

  export type GeneralPlayerStatisticsCreateWithoutMapRanksInput = {
    id?: string
    steam: SteamUserCreateNestedOneWithoutGeneralPlayerStatisticsInput
    WeaponStats?: WeaponStatsCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsUncheckedCreateWithoutMapRanksInput = {
    id?: string
    userId: string
    WeaponStats?: WeaponStatsUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsCreateOrConnectWithoutMapRanksInput = {
    where: GeneralPlayerStatisticsWhereUniqueInput
    create: XOR<GeneralPlayerStatisticsCreateWithoutMapRanksInput, GeneralPlayerStatisticsUncheckedCreateWithoutMapRanksInput>
  }

  export type MapStatsUpsertWithWhereUniqueWithoutMapRanksInput = {
    where: MapStatsWhereUniqueInput
    update: XOR<MapStatsUpdateWithoutMapRanksInput, MapStatsUncheckedUpdateWithoutMapRanksInput>
    create: XOR<MapStatsCreateWithoutMapRanksInput, MapStatsUncheckedCreateWithoutMapRanksInput>
  }

  export type MapStatsUpdateWithWhereUniqueWithoutMapRanksInput = {
    where: MapStatsWhereUniqueInput
    data: XOR<MapStatsUpdateWithoutMapRanksInput, MapStatsUncheckedUpdateWithoutMapRanksInput>
  }

  export type MapStatsUpdateManyWithWhereWithoutMapRanksInput = {
    where: MapStatsScalarWhereInput
    data: XOR<MapStatsUpdateManyMutationInput, MapStatsUncheckedUpdateManyWithoutMapRanksInput>
  }

  export type MapStatsScalarWhereInput = {
    AND?: MapStatsScalarWhereInput | MapStatsScalarWhereInput[]
    OR?: MapStatsScalarWhereInput[]
    NOT?: MapStatsScalarWhereInput | MapStatsScalarWhereInput[]
    id?: StringFilter<"MapStats"> | string
    total_matches?: IntFilter<"MapStats"> | number
    win_matches?: IntFilter<"MapStats"> | number
    ct_total_rounds?: IntFilter<"MapStats"> | number
    ct_win_rounds?: IntFilter<"MapStats"> | number
    t_total_rounds?: IntFilter<"MapStats"> | number
    t_win_rounds?: IntFilter<"MapStats"> | number
    mapId?: StringFilter<"MapStats"> | string
    createdAt?: DateTimeFilter<"MapStats"> | Date | string
    updatedAt?: DateTimeFilter<"MapStats"> | Date | string
  }

  export type GeneralPlayerStatisticsUpsertWithoutMapRanksInput = {
    update: XOR<GeneralPlayerStatisticsUpdateWithoutMapRanksInput, GeneralPlayerStatisticsUncheckedUpdateWithoutMapRanksInput>
    create: XOR<GeneralPlayerStatisticsCreateWithoutMapRanksInput, GeneralPlayerStatisticsUncheckedCreateWithoutMapRanksInput>
    where?: GeneralPlayerStatisticsWhereInput
  }

  export type GeneralPlayerStatisticsUpdateToOneWithWhereWithoutMapRanksInput = {
    where?: GeneralPlayerStatisticsWhereInput
    data: XOR<GeneralPlayerStatisticsUpdateWithoutMapRanksInput, GeneralPlayerStatisticsUncheckedUpdateWithoutMapRanksInput>
  }

  export type GeneralPlayerStatisticsUpdateWithoutMapRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    steam?: SteamUserUpdateOneRequiredWithoutGeneralPlayerStatisticsNestedInput
    WeaponStats?: WeaponStatsUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type GeneralPlayerStatisticsUncheckedUpdateWithoutMapRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    WeaponStats?: WeaponStatsUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type MapRanksCreateWithoutMapStatInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    generalPlayerStatistics: GeneralPlayerStatisticsCreateNestedOneWithoutMapRanksInput
  }

  export type MapRanksUncheckedCreateWithoutMapStatInput = {
    id?: string
    name: string
    playerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapRanksCreateOrConnectWithoutMapStatInput = {
    where: MapRanksWhereUniqueInput
    create: XOR<MapRanksCreateWithoutMapStatInput, MapRanksUncheckedCreateWithoutMapStatInput>
  }

  export type MapRanksUpsertWithoutMapStatInput = {
    update: XOR<MapRanksUpdateWithoutMapStatInput, MapRanksUncheckedUpdateWithoutMapStatInput>
    create: XOR<MapRanksCreateWithoutMapStatInput, MapRanksUncheckedCreateWithoutMapStatInput>
    where?: MapRanksWhereInput
  }

  export type MapRanksUpdateToOneWithWhereWithoutMapStatInput = {
    where?: MapRanksWhereInput
    data: XOR<MapRanksUpdateWithoutMapStatInput, MapRanksUncheckedUpdateWithoutMapStatInput>
  }

  export type MapRanksUpdateWithoutMapStatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneRequiredWithoutMapRanksNestedInput
  }

  export type MapRanksUncheckedUpdateWithoutMapStatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneralPlayerStatisticsCreateWithoutWeaponStatsInput = {
    id?: string
    steam: SteamUserCreateNestedOneWithoutGeneralPlayerStatisticsInput
    MapRanks?: MapRanksCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsUncheckedCreateWithoutWeaponStatsInput = {
    id?: string
    userId: string
    MapRanks?: MapRanksUncheckedCreateNestedManyWithoutGeneralPlayerStatisticsInput
  }

  export type GeneralPlayerStatisticsCreateOrConnectWithoutWeaponStatsInput = {
    where: GeneralPlayerStatisticsWhereUniqueInput
    create: XOR<GeneralPlayerStatisticsCreateWithoutWeaponStatsInput, GeneralPlayerStatisticsUncheckedCreateWithoutWeaponStatsInput>
  }

  export type HitCreateWithoutWeaponInput = {
    id?: string
    hitLocation: string
    hits: number
    totalDamage: number
    kills: number
  }

  export type HitUncheckedCreateWithoutWeaponInput = {
    id?: string
    hitLocation: string
    hits: number
    totalDamage: number
    kills: number
  }

  export type HitCreateOrConnectWithoutWeaponInput = {
    where: HitWhereUniqueInput
    create: XOR<HitCreateWithoutWeaponInput, HitUncheckedCreateWithoutWeaponInput>
  }

  export type HitCreateManyWeaponInputEnvelope = {
    data: HitCreateManyWeaponInput | HitCreateManyWeaponInput[]
    skipDuplicates?: boolean
  }

  export type GeneralPlayerStatisticsUpsertWithoutWeaponStatsInput = {
    update: XOR<GeneralPlayerStatisticsUpdateWithoutWeaponStatsInput, GeneralPlayerStatisticsUncheckedUpdateWithoutWeaponStatsInput>
    create: XOR<GeneralPlayerStatisticsCreateWithoutWeaponStatsInput, GeneralPlayerStatisticsUncheckedCreateWithoutWeaponStatsInput>
    where?: GeneralPlayerStatisticsWhereInput
  }

  export type GeneralPlayerStatisticsUpdateToOneWithWhereWithoutWeaponStatsInput = {
    where?: GeneralPlayerStatisticsWhereInput
    data: XOR<GeneralPlayerStatisticsUpdateWithoutWeaponStatsInput, GeneralPlayerStatisticsUncheckedUpdateWithoutWeaponStatsInput>
  }

  export type GeneralPlayerStatisticsUpdateWithoutWeaponStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    steam?: SteamUserUpdateOneRequiredWithoutGeneralPlayerStatisticsNestedInput
    MapRanks?: MapRanksUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type GeneralPlayerStatisticsUncheckedUpdateWithoutWeaponStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    MapRanks?: MapRanksUncheckedUpdateManyWithoutGeneralPlayerStatisticsNestedInput
  }

  export type HitUpsertWithWhereUniqueWithoutWeaponInput = {
    where: HitWhereUniqueInput
    update: XOR<HitUpdateWithoutWeaponInput, HitUncheckedUpdateWithoutWeaponInput>
    create: XOR<HitCreateWithoutWeaponInput, HitUncheckedCreateWithoutWeaponInput>
  }

  export type HitUpdateWithWhereUniqueWithoutWeaponInput = {
    where: HitWhereUniqueInput
    data: XOR<HitUpdateWithoutWeaponInput, HitUncheckedUpdateWithoutWeaponInput>
  }

  export type HitUpdateManyWithWhereWithoutWeaponInput = {
    where: HitScalarWhereInput
    data: XOR<HitUpdateManyMutationInput, HitUncheckedUpdateManyWithoutWeaponInput>
  }

  export type HitScalarWhereInput = {
    AND?: HitScalarWhereInput | HitScalarWhereInput[]
    OR?: HitScalarWhereInput[]
    NOT?: HitScalarWhereInput | HitScalarWhereInput[]
    id?: StringFilter<"Hit"> | string
    weaponId?: StringFilter<"Hit"> | string
    hitLocation?: StringFilter<"Hit"> | string
    hits?: IntFilter<"Hit"> | number
    totalDamage?: IntFilter<"Hit"> | number
    kills?: IntFilter<"Hit"> | number
  }

  export type WeaponStatsCreateWithoutHitsInput = {
    id?: string
    name: string
    fire: number
    generalPlayerStatistics: GeneralPlayerStatisticsCreateNestedOneWithoutWeaponStatsInput
  }

  export type WeaponStatsUncheckedCreateWithoutHitsInput = {
    id?: string
    name: string
    fire: number
    userId: string
  }

  export type WeaponStatsCreateOrConnectWithoutHitsInput = {
    where: WeaponStatsWhereUniqueInput
    create: XOR<WeaponStatsCreateWithoutHitsInput, WeaponStatsUncheckedCreateWithoutHitsInput>
  }

  export type WeaponStatsUpsertWithoutHitsInput = {
    update: XOR<WeaponStatsUpdateWithoutHitsInput, WeaponStatsUncheckedUpdateWithoutHitsInput>
    create: XOR<WeaponStatsCreateWithoutHitsInput, WeaponStatsUncheckedCreateWithoutHitsInput>
    where?: WeaponStatsWhereInput
  }

  export type WeaponStatsUpdateToOneWithWhereWithoutHitsInput = {
    where?: WeaponStatsWhereInput
    data: XOR<WeaponStatsUpdateWithoutHitsInput, WeaponStatsUncheckedUpdateWithoutHitsInput>
  }

  export type WeaponStatsUpdateWithoutHitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneRequiredWithoutWeaponStatsNestedInput
  }

  export type WeaponStatsUncheckedUpdateWithoutHitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SteamUserCreateWithoutPlayerStatisticsInMatchInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSteamUserInput
    steamUserBans?: SteamUserBansCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserCreateNestedManyWithoutRecipientInput
    matches?: MatchCreateNestedManyWithoutParticipantsInput
    generalPlayerStatistics?: GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUncheckedCreateWithoutPlayerStatisticsInMatchInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansUncheckedCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentUncheckedCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserUncheckedCreateNestedManyWithoutRecipientInput
    matches?: MatchUncheckedCreateNestedManyWithoutParticipantsInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput
  }

  export type SteamUserCreateOrConnectWithoutPlayerStatisticsInMatchInput = {
    where: SteamUserWhereUniqueInput
    create: XOR<SteamUserCreateWithoutPlayerStatisticsInMatchInput, SteamUserUncheckedCreateWithoutPlayerStatisticsInMatchInput>
  }

  export type MatchCreateWithoutPlayersStatisticInput = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date | string
    sharedCode: string
    replay: string
    result?: boolean
    duration: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: SteamUserCreateNestedManyWithoutMatchesInput
  }

  export type MatchUncheckedCreateWithoutPlayersStatisticInput = {
    id: string
    type: $Enums.MatchType
    matchId: string
    score: string
    date: Date | string
    sharedCode: string
    replay: string
    result?: boolean
    duration: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: SteamUserUncheckedCreateNestedManyWithoutMatchesInput
  }

  export type MatchCreateOrConnectWithoutPlayersStatisticInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutPlayersStatisticInput, MatchUncheckedCreateWithoutPlayersStatisticInput>
  }

  export type SteamUserUpsertWithoutPlayerStatisticsInMatchInput = {
    update: XOR<SteamUserUpdateWithoutPlayerStatisticsInMatchInput, SteamUserUncheckedUpdateWithoutPlayerStatisticsInMatchInput>
    create: XOR<SteamUserCreateWithoutPlayerStatisticsInMatchInput, SteamUserUncheckedCreateWithoutPlayerStatisticsInMatchInput>
    where?: SteamUserWhereInput
  }

  export type SteamUserUpdateToOneWithWhereWithoutPlayerStatisticsInMatchInput = {
    where?: SteamUserWhereInput
    data: XOR<SteamUserUpdateWithoutPlayerStatisticsInMatchInput, SteamUserUncheckedUpdateWithoutPlayerStatisticsInMatchInput>
  }

  export type SteamUserUpdateWithoutPlayerStatisticsInMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSteamUserNestedInput
    steamUserBans?: SteamUserBansUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUpdateManyWithoutRecipientNestedInput
    matches?: MatchUpdateManyWithoutParticipantsNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateWithoutPlayerStatisticsInMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUncheckedUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUncheckedUpdateManyWithoutRecipientNestedInput
    matches?: MatchUncheckedUpdateManyWithoutParticipantsNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput
  }

  export type MatchUpsertWithoutPlayersStatisticInput = {
    update: XOR<MatchUpdateWithoutPlayersStatisticInput, MatchUncheckedUpdateWithoutPlayersStatisticInput>
    create: XOR<MatchCreateWithoutPlayersStatisticInput, MatchUncheckedCreateWithoutPlayersStatisticInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutPlayersStatisticInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutPlayersStatisticInput, MatchUncheckedUpdateWithoutPlayersStatisticInput>
  }

  export type MatchUpdateWithoutPlayersStatisticInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: SteamUserUpdateManyWithoutMatchesNestedInput
  }

  export type MatchUncheckedUpdateWithoutPlayersStatisticInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: SteamUserUncheckedUpdateManyWithoutMatchesNestedInput
  }

  export type SteamUserCreateWithoutSteamUserBansInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSteamUserInput
    commentsAsRecipient?: CommentCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserCreateNestedManyWithoutRecipientInput
    matches?: MatchCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUncheckedCreateWithoutSteamUserBansInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentsAsRecipient?: CommentUncheckedCreateNestedManyWithoutRecipientInput
    reportsAsRecipient?: ReportUserUncheckedCreateNestedManyWithoutRecipientInput
    matches?: MatchUncheckedCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput
  }

  export type SteamUserCreateOrConnectWithoutSteamUserBansInput = {
    where: SteamUserWhereUniqueInput
    create: XOR<SteamUserCreateWithoutSteamUserBansInput, SteamUserUncheckedCreateWithoutSteamUserBansInput>
  }

  export type SteamUserUpsertWithoutSteamUserBansInput = {
    update: XOR<SteamUserUpdateWithoutSteamUserBansInput, SteamUserUncheckedUpdateWithoutSteamUserBansInput>
    create: XOR<SteamUserCreateWithoutSteamUserBansInput, SteamUserUncheckedCreateWithoutSteamUserBansInput>
    where?: SteamUserWhereInput
  }

  export type SteamUserUpdateToOneWithWhereWithoutSteamUserBansInput = {
    where?: SteamUserWhereInput
    data: XOR<SteamUserUpdateWithoutSteamUserBansInput, SteamUserUncheckedUpdateWithoutSteamUserBansInput>
  }

  export type SteamUserUpdateWithoutSteamUserBansInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSteamUserNestedInput
    commentsAsRecipient?: CommentUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUpdateManyWithoutRecipientNestedInput
    matches?: MatchUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateWithoutSteamUserBansInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentsAsRecipient?: CommentUncheckedUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUncheckedUpdateManyWithoutRecipientNestedInput
    matches?: MatchUncheckedUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput
  }

  export type UserCreateWithoutLinksInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLinksInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
  }

  export type UserUpsertWithoutLinksInput = {
    update: XOR<UserUpdateWithoutLinksInput, UserUncheckedUpdateWithoutLinksInput>
    create: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLinksInput, UserUncheckedUpdateWithoutLinksInput>
  }

  export type UserUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImagesCreateWithoutCommentInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagesUncheckedCreateWithoutCommentInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagesCreateOrConnectWithoutCommentInput = {
    where: ImagesWhereUniqueInput
    create: XOR<ImagesCreateWithoutCommentInput, ImagesUncheckedCreateWithoutCommentInput>
  }

  export type ImagesCreateManyCommentInputEnvelope = {
    data: ImagesCreateManyCommentInput | ImagesCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCommentsAsAuthorInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsAsAuthorInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsAsAuthorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsAsAuthorInput, UserUncheckedCreateWithoutCommentsAsAuthorInput>
  }

  export type SteamUserCreateWithoutCommentsAsRecipientInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSteamUserInput
    steamUserBans?: SteamUserBansCreateNestedOneWithoutSteamInput
    reportsAsRecipient?: ReportUserCreateNestedManyWithoutRecipientInput
    matches?: MatchCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUncheckedCreateWithoutCommentsAsRecipientInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansUncheckedCreateNestedOneWithoutSteamInput
    reportsAsRecipient?: ReportUserUncheckedCreateNestedManyWithoutRecipientInput
    matches?: MatchUncheckedCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput
  }

  export type SteamUserCreateOrConnectWithoutCommentsAsRecipientInput = {
    where: SteamUserWhereUniqueInput
    create: XOR<SteamUserCreateWithoutCommentsAsRecipientInput, SteamUserUncheckedCreateWithoutCommentsAsRecipientInput>
  }

  export type ImagesUpsertWithWhereUniqueWithoutCommentInput = {
    where: ImagesWhereUniqueInput
    update: XOR<ImagesUpdateWithoutCommentInput, ImagesUncheckedUpdateWithoutCommentInput>
    create: XOR<ImagesCreateWithoutCommentInput, ImagesUncheckedCreateWithoutCommentInput>
  }

  export type ImagesUpdateWithWhereUniqueWithoutCommentInput = {
    where: ImagesWhereUniqueInput
    data: XOR<ImagesUpdateWithoutCommentInput, ImagesUncheckedUpdateWithoutCommentInput>
  }

  export type ImagesUpdateManyWithWhereWithoutCommentInput = {
    where: ImagesScalarWhereInput
    data: XOR<ImagesUpdateManyMutationInput, ImagesUncheckedUpdateManyWithoutCommentInput>
  }

  export type ImagesScalarWhereInput = {
    AND?: ImagesScalarWhereInput | ImagesScalarWhereInput[]
    OR?: ImagesScalarWhereInput[]
    NOT?: ImagesScalarWhereInput | ImagesScalarWhereInput[]
    id?: StringFilter<"Images"> | string
    url?: StringFilter<"Images"> | string
    commentId?: StringFilter<"Images"> | string
    createdAt?: DateTimeFilter<"Images"> | Date | string
    updatedAt?: DateTimeFilter<"Images"> | Date | string
  }

  export type UserUpsertWithoutCommentsAsAuthorInput = {
    update: XOR<UserUpdateWithoutCommentsAsAuthorInput, UserUncheckedUpdateWithoutCommentsAsAuthorInput>
    create: XOR<UserCreateWithoutCommentsAsAuthorInput, UserUncheckedCreateWithoutCommentsAsAuthorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsAsAuthorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsAsAuthorInput, UserUncheckedUpdateWithoutCommentsAsAuthorInput>
  }

  export type UserUpdateWithoutCommentsAsAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsAsAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SteamUserUpsertWithoutCommentsAsRecipientInput = {
    update: XOR<SteamUserUpdateWithoutCommentsAsRecipientInput, SteamUserUncheckedUpdateWithoutCommentsAsRecipientInput>
    create: XOR<SteamUserCreateWithoutCommentsAsRecipientInput, SteamUserUncheckedCreateWithoutCommentsAsRecipientInput>
    where?: SteamUserWhereInput
  }

  export type SteamUserUpdateToOneWithWhereWithoutCommentsAsRecipientInput = {
    where?: SteamUserWhereInput
    data: XOR<SteamUserUpdateWithoutCommentsAsRecipientInput, SteamUserUncheckedUpdateWithoutCommentsAsRecipientInput>
  }

  export type SteamUserUpdateWithoutCommentsAsRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSteamUserNestedInput
    steamUserBans?: SteamUserBansUpdateOneWithoutSteamNestedInput
    reportsAsRecipient?: ReportUserUpdateManyWithoutRecipientNestedInput
    matches?: MatchUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateWithoutCommentsAsRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput
    reportsAsRecipient?: ReportUserUncheckedUpdateManyWithoutRecipientNestedInput
    matches?: MatchUncheckedUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput
  }

  export type CommentCreateWithoutImagesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsAsAuthorInput
    recipient: SteamUserCreateNestedOneWithoutCommentsAsRecipientInput
  }

  export type CommentUncheckedCreateWithoutImagesInput = {
    id?: string
    content: string
    authorId: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutImagesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutImagesInput, CommentUncheckedCreateWithoutImagesInput>
  }

  export type CommentUpsertWithoutImagesInput = {
    update: XOR<CommentUpdateWithoutImagesInput, CommentUncheckedUpdateWithoutImagesInput>
    create: XOR<CommentCreateWithoutImagesInput, CommentUncheckedCreateWithoutImagesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutImagesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutImagesInput, CommentUncheckedUpdateWithoutImagesInput>
  }

  export type CommentUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsAsAuthorNestedInput
    recipient?: SteamUserUpdateOneRequiredWithoutCommentsAsRecipientNestedInput
  }

  export type CommentUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutJwtTokensInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJwtTokensInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJwtTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJwtTokensInput, UserUncheckedCreateWithoutJwtTokensInput>
  }

  export type UserUpsertWithoutJwtTokensInput = {
    update: XOR<UserUpdateWithoutJwtTokensInput, UserUncheckedUpdateWithoutJwtTokensInput>
    create: XOR<UserCreateWithoutJwtTokensInput, UserUncheckedCreateWithoutJwtTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJwtTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJwtTokensInput, UserUncheckedUpdateWithoutJwtTokensInput>
  }

  export type UserUpdateWithoutJwtTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJwtTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReportUsersInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    verdicts?: VerdictCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportUsersInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportUsersInput, UserUncheckedCreateWithoutReportUsersInput>
  }

  export type SteamUserCreateWithoutReportsAsRecipientInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutSteamUserInput
    steamUserBans?: SteamUserBansCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentCreateNestedManyWithoutRecipientInput
    matches?: MatchCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsCreateNestedOneWithoutSteamInput
  }

  export type SteamUserUncheckedCreateWithoutReportsAsRecipientInput = {
    id: string
    personaName: string
    profileUrl: string
    avatar: string
    realname?: string | null
    level?: string | null
    timeCreated: string
    steamId2?: string | null
    steamId3?: string | null
    steamIdHex?: string | null
    countryCode?: string | null
    lastUpdateSteamInformation: Date | string
    viewers?: number
    userId?: string | null
    sharedCode?: string | null
    gameAuthenticationCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steamUserBans?: SteamUserBansUncheckedCreateNestedOneWithoutSteamInput
    commentsAsRecipient?: CommentUncheckedCreateNestedManyWithoutRecipientInput
    matches?: MatchUncheckedCreateNestedManyWithoutParticipantsInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedCreateNestedManyWithoutSteamUserInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedCreateNestedOneWithoutSteamInput
  }

  export type SteamUserCreateOrConnectWithoutReportsAsRecipientInput = {
    where: SteamUserWhereUniqueInput
    create: XOR<SteamUserCreateWithoutReportsAsRecipientInput, SteamUserUncheckedCreateWithoutReportsAsRecipientInput>
  }

  export type VerdictCreateWithoutReportInput = {
    id?: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVerdictsInput
  }

  export type VerdictUncheckedCreateWithoutReportInput = {
    id?: string
    userId: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictCreateOrConnectWithoutReportInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutReportInput, VerdictUncheckedCreateWithoutReportInput>
  }

  export type VerdictCreateManyReportInputEnvelope = {
    data: VerdictCreateManyReportInput | VerdictCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReportUsersInput = {
    update: XOR<UserUpdateWithoutReportUsersInput, UserUncheckedUpdateWithoutReportUsersInput>
    create: XOR<UserCreateWithoutReportUsersInput, UserUncheckedCreateWithoutReportUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportUsersInput, UserUncheckedUpdateWithoutReportUsersInput>
  }

  export type UserUpdateWithoutReportUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    verdicts?: VerdictUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SteamUserUpsertWithoutReportsAsRecipientInput = {
    update: XOR<SteamUserUpdateWithoutReportsAsRecipientInput, SteamUserUncheckedUpdateWithoutReportsAsRecipientInput>
    create: XOR<SteamUserCreateWithoutReportsAsRecipientInput, SteamUserUncheckedCreateWithoutReportsAsRecipientInput>
    where?: SteamUserWhereInput
  }

  export type SteamUserUpdateToOneWithWhereWithoutReportsAsRecipientInput = {
    where?: SteamUserWhereInput
    data: XOR<SteamUserUpdateWithoutReportsAsRecipientInput, SteamUserUncheckedUpdateWithoutReportsAsRecipientInput>
  }

  export type SteamUserUpdateWithoutReportsAsRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSteamUserNestedInput
    steamUserBans?: SteamUserBansUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUpdateManyWithoutRecipientNestedInput
    matches?: MatchUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateWithoutReportsAsRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUncheckedUpdateManyWithoutRecipientNestedInput
    matches?: MatchUncheckedUpdateManyWithoutParticipantsNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput
  }

  export type VerdictUpsertWithWhereUniqueWithoutReportInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutReportInput, VerdictUncheckedUpdateWithoutReportInput>
    create: XOR<VerdictCreateWithoutReportInput, VerdictUncheckedCreateWithoutReportInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutReportInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutReportInput, VerdictUncheckedUpdateWithoutReportInput>
  }

  export type VerdictUpdateManyWithWhereWithoutReportInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutReportInput>
  }

  export type UserCreateWithoutVerdictsInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutUserInput
    notifications?: NotificationsCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserCreateNestedManyWithoutUserInput
    links?: LinksInProfileCreateNestedOneWithoutUserInput
    steamUser?: SteamUserCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutVerdictsInput = {
    id?: string
    email: string
    username: string
    password: string
    avatar?: string | null
    role?: $Enums.UserRole
    additionalRole?: $Enums.AdditionalRole
    isEmailVerified?: boolean
    isBanned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutUserInput
    trackingUsers?: TrackingUserUncheckedCreateNestedManyWithoutUserInput
    links?: LinksInProfileUncheckedCreateNestedOneWithoutUserInput
    steamUser?: SteamUserUncheckedCreateNestedOneWithoutUserInput
    commentsAsAuthor?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    jwtTokens?: JwtTokenUncheckedCreateNestedManyWithoutUserInput
    reportUsers?: ReportUserUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutVerdictsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerdictsInput, UserUncheckedCreateWithoutVerdictsInput>
  }

  export type ReportUserCreateWithoutVerdictsInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutReportUsersInput
    recipient: SteamUserCreateNestedOneWithoutReportsAsRecipientInput
  }

  export type ReportUserUncheckedCreateWithoutVerdictsInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    authorId: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUserCreateOrConnectWithoutVerdictsInput = {
    where: ReportUserWhereUniqueInput
    create: XOR<ReportUserCreateWithoutVerdictsInput, ReportUserUncheckedCreateWithoutVerdictsInput>
  }

  export type UserUpsertWithoutVerdictsInput = {
    update: XOR<UserUpdateWithoutVerdictsInput, UserUncheckedUpdateWithoutVerdictsInput>
    create: XOR<UserCreateWithoutVerdictsInput, UserUncheckedCreateWithoutVerdictsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerdictsInput, UserUncheckedUpdateWithoutVerdictsInput>
  }

  export type UserUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    additionalRole?: EnumAdditionalRoleFieldUpdateOperationsInput | $Enums.AdditionalRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutUserNestedInput
    trackingUsers?: TrackingUserUncheckedUpdateManyWithoutUserNestedInput
    links?: LinksInProfileUncheckedUpdateOneWithoutUserNestedInput
    steamUser?: SteamUserUncheckedUpdateOneWithoutUserNestedInput
    commentsAsAuthor?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    jwtTokens?: JwtTokenUncheckedUpdateManyWithoutUserNestedInput
    reportUsers?: ReportUserUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ReportUserUpsertWithoutVerdictsInput = {
    update: XOR<ReportUserUpdateWithoutVerdictsInput, ReportUserUncheckedUpdateWithoutVerdictsInput>
    create: XOR<ReportUserCreateWithoutVerdictsInput, ReportUserUncheckedCreateWithoutVerdictsInput>
    where?: ReportUserWhereInput
  }

  export type ReportUserUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: ReportUserWhereInput
    data: XOR<ReportUserUpdateWithoutVerdictsInput, ReportUserUncheckedUpdateWithoutVerdictsInput>
  }

  export type ReportUserUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReportUsersNestedInput
    recipient?: SteamUserUpdateOneRequiredWithoutReportsAsRecipientNestedInput
  }

  export type ReportUserUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expiresIn: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    description?: string | null
    isViewed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrackingUserCreateManyUserInput = {
    id?: string
    name: string
    steamid: string
    dateBanned?: Date | string | null
    avatar: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JwtTokenCreateManyUserInput = {
    id?: string
    refreshToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUserCreateManyAuthorInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    recipientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictCreateManyUserInput = {
    id?: string
    reportId: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expiresIn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steamid?: StringFieldUpdateOperationsInput | string
    dateBanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steamid?: StringFieldUpdateOperationsInput | string
    dateBanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    steamid?: StringFieldUpdateOperationsInput | string
    dateBanned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImagesUpdateManyWithoutCommentNestedInput
    recipient?: SteamUserUpdateOneRequiredWithoutCommentsAsRecipientNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImagesUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwtTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwtTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JwtTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: SteamUserUpdateOneRequiredWithoutReportsAsRecipientNestedInput
    verdicts?: VerdictUpdateManyWithoutReportNestedInput
  }

  export type ReportUserUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdicts?: VerdictUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUserUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    recipientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ReportUserUpdateOneRequiredWithoutVerdictsNestedInput
  }

  export type VerdictUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyRecipientInput = {
    id?: string
    content: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUserCreateManyRecipientInput = {
    id?: string
    youtubeLink: string
    demoLink?: string | null
    comment?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerStatisticsInMatchCreateManySteamUserInput = {
    id?: string
    matchId: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImagesUpdateManyWithoutCommentNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsAsAuthorNestedInput
  }

  export type CommentUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImagesUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUserUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReportUsersNestedInput
    verdicts?: VerdictUpdateManyWithoutReportNestedInput
  }

  export type ReportUserUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdicts?: VerdictUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUserUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    youtubeLink?: StringFieldUpdateOperationsInput | string
    demoLink?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playersStatistic?: PlayerStatisticsInMatchUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playersStatistic?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    matchId?: StringFieldUpdateOperationsInput | string
    score?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedCode?: StringFieldUpdateOperationsInput | string
    replay?: StringFieldUpdateOperationsInput | string
    result?: BoolFieldUpdateOperationsInput | boolean
    duration?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatisticsInMatchUpdateWithoutSteamUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MatchUpdateOneRequiredWithoutPlayersStatisticNestedInput
  }

  export type PlayerStatisticsInMatchUncheckedUpdateWithoutSteamUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatisticsInMatchCreateManyMatchInput = {
    id?: string
    userId: string
    kills_total: number
    deaths_total: number
    assists_total: number
    headshot_kills_total: number
    ace_rounds_total: number
    k4_rounds_total: number
    k3_rounds_total: number
    k2_rounds_total: number
    damage_total: number
    objective_total: number
    utility_damage_total: number
    mvps: number
    crosshair_code: string
    player_color: string
    rank_if_win: number
    rank: number
    rank_if_loss: number
    rank_if_tie: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SteamUserUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSteamUserNestedInput
    steamUserBans?: SteamUserBansUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUpdateManyWithoutRecipientNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUserBans?: SteamUserBansUncheckedUpdateOneWithoutSteamNestedInput
    commentsAsRecipient?: CommentUncheckedUpdateManyWithoutRecipientNestedInput
    reportsAsRecipient?: ReportUserUncheckedUpdateManyWithoutRecipientNestedInput
    playerStatisticsInMatch?: PlayerStatisticsInMatchUncheckedUpdateManyWithoutSteamUserNestedInput
    generalPlayerStatistics?: GeneralPlayerStatisticsUncheckedUpdateOneWithoutSteamNestedInput
  }

  export type SteamUserUncheckedUpdateManyWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    personaName?: StringFieldUpdateOperationsInput | string
    profileUrl?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    realname?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    timeCreated?: StringFieldUpdateOperationsInput | string
    steamId2?: NullableStringFieldUpdateOperationsInput | string | null
    steamId3?: NullableStringFieldUpdateOperationsInput | string | null
    steamIdHex?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdateSteamInformation?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: IntFieldUpdateOperationsInput | number
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sharedCode?: NullableStringFieldUpdateOperationsInput | string | null
    gameAuthenticationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatisticsInMatchUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steamUser?: SteamUserUpdateOneRequiredWithoutPlayerStatisticsInMatchNestedInput
  }

  export type PlayerStatisticsInMatchUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerStatisticsInMatchUncheckedUpdateManyWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    kills_total?: IntFieldUpdateOperationsInput | number
    deaths_total?: IntFieldUpdateOperationsInput | number
    assists_total?: IntFieldUpdateOperationsInput | number
    headshot_kills_total?: IntFieldUpdateOperationsInput | number
    ace_rounds_total?: IntFieldUpdateOperationsInput | number
    k4_rounds_total?: IntFieldUpdateOperationsInput | number
    k3_rounds_total?: IntFieldUpdateOperationsInput | number
    k2_rounds_total?: IntFieldUpdateOperationsInput | number
    damage_total?: IntFieldUpdateOperationsInput | number
    objective_total?: IntFieldUpdateOperationsInput | number
    utility_damage_total?: IntFieldUpdateOperationsInput | number
    mvps?: IntFieldUpdateOperationsInput | number
    crosshair_code?: StringFieldUpdateOperationsInput | string
    player_color?: StringFieldUpdateOperationsInput | string
    rank_if_win?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    rank_if_loss?: IntFieldUpdateOperationsInput | number
    rank_if_tie?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapRanksCreateManyGeneralPlayerStatisticsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeaponStatsCreateManyGeneralPlayerStatisticsInput = {
    id?: string
    name: string
    fire: number
  }

  export type MapRanksUpdateWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapStat?: MapStatsUpdateManyWithoutMapRanksNestedInput
  }

  export type MapRanksUncheckedUpdateWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mapStat?: MapStatsUncheckedUpdateManyWithoutMapRanksNestedInput
  }

  export type MapRanksUncheckedUpdateManyWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeaponStatsUpdateWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
    hits?: HitUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponStatsUncheckedUpdateWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
    hits?: HitUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponStatsUncheckedUpdateManyWithoutGeneralPlayerStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fire?: IntFieldUpdateOperationsInput | number
  }

  export type MapStatsCreateManyMapRanksInput = {
    id?: string
    total_matches: number
    win_matches: number
    ct_total_rounds: number
    ct_win_rounds: number
    t_total_rounds: number
    t_win_rounds: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapStatsUpdateWithoutMapRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_matches?: IntFieldUpdateOperationsInput | number
    win_matches?: IntFieldUpdateOperationsInput | number
    ct_total_rounds?: IntFieldUpdateOperationsInput | number
    ct_win_rounds?: IntFieldUpdateOperationsInput | number
    t_total_rounds?: IntFieldUpdateOperationsInput | number
    t_win_rounds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapStatsUncheckedUpdateWithoutMapRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_matches?: IntFieldUpdateOperationsInput | number
    win_matches?: IntFieldUpdateOperationsInput | number
    ct_total_rounds?: IntFieldUpdateOperationsInput | number
    ct_win_rounds?: IntFieldUpdateOperationsInput | number
    t_total_rounds?: IntFieldUpdateOperationsInput | number
    t_win_rounds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapStatsUncheckedUpdateManyWithoutMapRanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_matches?: IntFieldUpdateOperationsInput | number
    win_matches?: IntFieldUpdateOperationsInput | number
    ct_total_rounds?: IntFieldUpdateOperationsInput | number
    ct_win_rounds?: IntFieldUpdateOperationsInput | number
    t_total_rounds?: IntFieldUpdateOperationsInput | number
    t_win_rounds?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HitCreateManyWeaponInput = {
    id?: string
    hitLocation: string
    hits: number
    totalDamage: number
    kills: number
  }

  export type HitUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    hitLocation?: StringFieldUpdateOperationsInput | string
    hits?: IntFieldUpdateOperationsInput | number
    totalDamage?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
  }

  export type HitUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    hitLocation?: StringFieldUpdateOperationsInput | string
    hits?: IntFieldUpdateOperationsInput | number
    totalDamage?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
  }

  export type HitUncheckedUpdateManyWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    hitLocation?: StringFieldUpdateOperationsInput | string
    hits?: IntFieldUpdateOperationsInput | number
    totalDamage?: IntFieldUpdateOperationsInput | number
    kills?: IntFieldUpdateOperationsInput | number
  }

  export type ImagesCreateManyCommentInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImagesUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagesUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImagesUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictCreateManyReportInput = {
    id?: string
    userId: string
    verdicts?: VerdictCreateverdictsInput | string[]
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVerdictsNestedInput
  }

  export type VerdictUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    verdicts?: VerdictUpdateverdictsInput | string[]
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}